This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
.prettierignore
.prettierrc
docs/ACCESSIBILITY.md
docs/ANIMATIONS.md
docs/ARCHITECTURE.md
docs/DESIGN_SYSTEM.md
docs/FEATURES.md
docs/IMPLEMENTATION_PLAN.md
eslint.config.js
index.html
package.json
postcss.config.js
README.md
src/App.vue
src/components/canvas/index.ts
src/components/canvas/ParticleSystem.ts
src/components/canvas/shaders/fog.frag
src/components/canvas/shaders/fog.vert
src/components/canvas/shaders/rain.frag
src/components/canvas/shaders/rain.vert
src/components/canvas/WeatherCanvas.vue
src/components/layout/AppHeader.vue
src/components/layout/BottomNav.vue
src/components/layout/index.ts
src/components/layout/SettingsDrawer.vue
src/components/layout/SplashScreen.vue
src/components/search/CitySearch.vue
src/components/search/CitySearchResults.vue
src/components/search/RecentCities.vue
src/components/ui/AnimatedNumber.vue
src/components/ui/ErrorDisplay.vue
src/components/ui/GlassmorphicCard.vue
src/components/ui/IconWrapper.vue
src/components/ui/index.ts
src/components/ui/MagneticButton.vue
src/components/ui/OfflineIndicator.vue
src/components/ui/SkeletonLoader.vue
src/components/ui/WeatherCard.vue
src/components/ui/WeatherIcon.vue
src/components/weather/CurrentWeather.vue
src/components/weather/HourlyForecast.vue
src/components/weather/index.ts
src/components/weather/PrecipitationBar.vue
src/components/weather/SunriseSunsetArc.vue
src/components/weather/TemperatureGraph.vue
src/components/weather/TimelineScrubber.vue
src/components/weather/UVIndexGauge.vue
src/components/weather/WeeklyForecast.vue
src/components/weather/WindCompass.vue
src/composables/useAudio.ts
src/composables/useFocusTrap.ts
src/composables/useGeolocation.ts
src/composables/useHaptics.ts
src/composables/useKeyboardShortcuts.ts
src/composables/useMagneticEffect.ts
src/composables/useParallax.ts
src/composables/useReducedMotion.ts
src/composables/useSonification.ts
src/composables/useTheme.ts
src/composables/useWeather.ts
src/config/env.ts
src/main.ts
src/services/cache.test.ts
src/services/cache.ts
src/services/geocodingApi.ts
src/services/index.ts
src/services/sonification.ts
src/services/translationApi.ts
src/services/weatherApi.ts
src/stores/index.ts
src/stores/locationStore.ts
src/stores/settingsStore.ts
src/stores/weatherStore.ts
src/styles/animations.css
src/styles/main.css
src/styles/variables.css
src/types/index.ts
src/types/location.ts
src/types/theme.ts
src/types/weather.ts
src/utils/animations.ts
src/utils/constants.ts
src/utils/formatters.ts
src/utils/haptics.ts
src/utils/index.ts
src/utils/interpolation.ts
src/utils/weatherCodes.test.ts
src/utils/weatherCodes.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.json
tsconfig.node.json
vite.config.d.ts
vite.config.js
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Azure Translator API Configuration
 # Get your key from: https://portal.azure.com
 
 # Direct API usage (development only - not recommended for production)
 VITE_AZURE_TRANSLATOR_KEY=your_api_key_here
 VITE_AZURE_TRANSLATOR_REGION=eastus
 
 # Backend proxy (recommended for production)
 # Set to 'true' to use a backend proxy that hides your API key
 VITE_USE_TRANSLATION_PROXY=false
 VITE_TRANSLATION_PROXY_URL=/api/translate
</file>

<file path=".prettierignore">
dist
 node_modules
 *.md
 package-lock.json
 tsconfig.node.tsbuildinfo
</file>

<file path=".prettierrc">
{
   "semi": false,
   "singleQuote": true,
   "tabWidth": 2,
   "trailingComma": "none",
   "printWidth": 100,
   "bracketSpacing": true,
   "arrowParens": "avoid",
   "endOfLine": "lf",
   "vueIndentScriptAndStyle": false
 }
</file>

<file path="docs/ACCESSIBILITY.md">
# WeatherVue 2.0 - Accessibility Guide

> Comprehensive accessibility requirements and implementation patterns

## Table of Contents

1. [Accessibility Philosophy](#accessibility-philosophy)
2. [WCAG Compliance](#wcag-compliance)
3. [Keyboard Navigation](#keyboard-navigation)
4. [Screen Reader Support](#screen-reader-support)
5. [Visual Accessibility](#visual-accessibility)
6. [Motion & Animation](#motion--animation)
7. [Alternative Modes](#alternative-modes)
8. [Testing Checklist](#testing-checklist)

---

## Accessibility Philosophy

### Core Principles

1. **Accessibility is not an afterthought** - It's built into every component from day one
2. **Multiple modalities** - Support visual, auditory, and tactile interaction
3. **Progressive enhancement** - Core functionality works without JavaScript
4. **User control** - Users can customize their experience

### Target Standards

- **WCAG 2.1 Level AA** (minimum)
- **WCAG 2.1 Level AAA** (where feasible)
- **ARIA 1.2** best practices

---

## WCAG Compliance

### Perceivable (Principle 1)

#### 1.1 Text Alternatives

```html
<!-- All images have alt text -->
<img src="weather-icon.svg" alt="Partly cloudy with chance of rain" />

<!-- Decorative images are hidden -->
<img src="decoration.svg" alt="" aria-hidden="true" />

<!-- Complex visualizations have descriptions -->
<figure>
  <div class="temperature-graph" role="img" aria-label="Temperature over 24 hours, 
    ranging from 15°C at 6 AM to 28°C at 2 PM, dropping to 18°C by midnight">
    <!-- D3 chart -->
  </div>
  <figcaption class="sr-only">
    Detailed temperature forecast showing hourly temperatures...
  </figcaption>
</figure>
```

#### 1.2 Time-based Media

- Ambient audio has visual equivalents
- Sonification mode has visual feedback
- All audio is optional and off by default

#### 1.3 Adaptable Content

```html
<!-- Semantic structure -->
<main>
  <header>
    <h1>Weather in Rome</h1>
  </header>
  
  <section aria-labelledby="current-heading">
    <h2 id="current-heading">Current Conditions</h2>
    <!-- content -->
  </section>
  
  <section aria-labelledby="forecast-heading">
    <h2 id="forecast-heading">7-Day Forecast</h2>
    <!-- content -->
  </section>
</main>

<!-- Landmarks -->
<nav aria-label="Main navigation">...</nav>
<aside aria-label="Settings panel">...</aside>
```

#### 1.4 Distinguishable

| Element | Contrast Ratio | Requirement |
|---------|---------------|-------------|
| Body text | 7:1+ | AAA |
| Large text (>18px bold) | 4.5:1+ | AAA |
| UI components | 3:1+ | AA |
| Focus indicators | 3:1+ | AA |

```css
/* Ensure sufficient contrast */
:root {
  --text-primary: #000000;      /* On white: 21:1 */
  --text-secondary: #4b5563;    /* On white: 7.5:1 */
  --text-muted: #6b7280;        /* On white: 5.3:1 - use only for large text */
}

[data-theme="dark"] {
  --text-primary: #ffffff;      /* On black: 21:1 */
  --text-secondary: #d1d5db;    /* On black: 13:1 */
  --text-muted: #9ca3af;        /* On black: 7.5:1 */
}
```

### Operable (Principle 2)

#### 2.1 Keyboard Accessible

All functionality available via keyboard:

| Action | Key(s) |
|--------|--------|
| Navigate forward | Tab |
| Navigate backward | Shift + Tab |
| Activate button/link | Enter, Space |
| Close modal/drawer | Escape |
| Navigate timeline | Arrow Left/Right |
| Jump to time | Home (start), End (end) |
| Select in dropdown | Arrow Up/Down, Enter |
| Toggle checkbox | Space |

#### 2.2 Enough Time

- No automatic content changes without user control
- Timeline scrubber pauses on interaction
- Loading states persist until action complete

#### 2.3 Seizures and Physical Reactions

```css
/* Limit flash frequency */
@keyframes lightning-flash {
  /* Max 3 flashes per second */
  0%, 5% { opacity: 1; }
  6%, 100% { opacity: 0; }
}

/* User can disable all flashing */
@media (prefers-reduced-motion: reduce) {
  .lightning-effect {
    display: none;
  }
}
```

#### 2.4 Navigable

```html
<!-- Skip link -->
<a href="#main-content" class="skip-link">
  Skip to main content
</a>

<!-- Page title updates with city -->
<title>Rome Weather - WeatherVue</title>

<!-- Focus order follows visual order -->
<!-- Heading hierarchy is logical -->
```

#### 2.5 Input Modalities

- Touch targets minimum 44x44px
- Pointer gestures have single-pointer alternatives
- Drag operations have click alternatives

### Understandable (Principle 3)

#### 3.1 Readable

```html
<html lang="en">
<!-- Language changes marked -->
<span lang="it">Roma, Italia</span>

<!-- Abbreviations explained -->
<abbr title="Ultraviolet Index">UV</abbr>
```

#### 3.2 Predictable

- Consistent navigation across all states
- Settings changes don't alter context unexpectedly
- Focus doesn't move unexpectedly

#### 3.3 Input Assistance

```html
<!-- Labels for all inputs -->
<label for="city-search">Search for a city</label>
<input id="city-search" type="text" 
       aria-describedby="search-hint"
       aria-invalid="false">
<span id="search-hint" class="sr-only">
  Type a city name and select from suggestions
</span>

<!-- Error messages are clear -->
<div role="alert" aria-live="assertive">
  Could not find "Roomee". Did you mean "Rome"?
</div>
```

### Robust (Principle 4)

#### 4.1 Compatible

- Valid HTML5
- ARIA roles used correctly
- Works with assistive technologies

---

## Keyboard Navigation

### Focus Management

```typescript
// Focus trap for modals/drawers
const useFocusTrap = (containerRef: Ref<HTMLElement>) => {
  const focusableSelector = 
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  
  const trapFocus = (e: KeyboardEvent) => {
    if (e.key !== 'Tab') return
    
    const focusable = containerRef.value.querySelectorAll(focusableSelector)
    const first = focusable[0] as HTMLElement
    const last = focusable[focusable.length - 1] as HTMLElement
    
    if (e.shiftKey && document.activeElement === first) {
      e.preventDefault()
      last.focus()
    } else if (!e.shiftKey && document.activeElement === last) {
      e.preventDefault()
      first.focus()
    }
  }
  
  onMounted(() => document.addEventListener('keydown', trapFocus))
  onUnmounted(() => document.removeEventListener('keydown', trapFocus))
}
```

### Focus Indicators

```css
/* Visible focus ring */
:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* Remove default outline when using focus-visible */
:focus:not(:focus-visible) {
  outline: none;
}

/* Enhanced focus for key elements */
.btn:focus-visible,
.card:focus-visible {
  outline-width: 3px;
  box-shadow: 0 0 0 4px rgba(220, 38, 38, 0.3);
}
```

### Roving Tabindex

For composite widgets like timeline:

```typescript
// TimelineScrubber keyboard navigation
const useRovingTabindex = (items: Ref<HTMLElement[]>, currentIndex: Ref<number>) => {
  const handleKeydown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'ArrowRight':
      case 'ArrowDown':
        e.preventDefault()
        currentIndex.value = Math.min(currentIndex.value + 1, items.value.length - 1)
        items.value[currentIndex.value].focus()
        break
      case 'ArrowLeft':
      case 'ArrowUp':
        e.preventDefault()
        currentIndex.value = Math.max(currentIndex.value - 1, 0)
        items.value[currentIndex.value].focus()
        break
      case 'Home':
        e.preventDefault()
        currentIndex.value = 0
        items.value[0].focus()
        break
      case 'End':
        e.preventDefault()
        currentIndex.value = items.value.length - 1
        items.value[currentIndex.value].focus()
        break
    }
  }
  
  return { handleKeydown }
}
```

---

## Screen Reader Support

### Live Regions

```html
<!-- Weather updates announced -->
<div id="weather-announcer" 
     role="status" 
     aria-live="polite" 
     aria-atomic="true"
     class="sr-only">
</div>

<script>
const announceWeather = (weather: CurrentWeather) => {
  const announcer = document.getElementById('weather-announcer')
  announcer.textContent = `Weather updated. ${weather.city}: 
    ${weather.temperature} degrees ${weather.unit}, 
    ${weather.condition}. 
    Feels like ${weather.feelsLike} degrees.`
}
</script>
```

### Descriptive Labels

```html
<!-- Icon buttons need labels -->
<button aria-label="Open settings" class="icon-btn">
  <SettingsIcon aria-hidden="true" />
</button>

<!-- Toggle buttons show state -->
<button 
  aria-label="Dark mode"
  aria-pressed="true"
  class="theme-toggle"
>
  <MoonIcon aria-hidden="true" />
</button>

<!-- Expandable sections -->
<button 
  aria-expanded="false"
  aria-controls="hourly-forecast"
>
  Hourly Forecast
</button>
<section id="hourly-forecast" hidden>...</section>
```

### Data Visualization Descriptions

```html
<!-- Temperature graph -->
<div 
  role="img"
  aria-label="24-hour temperature forecast"
  aria-describedby="temp-graph-desc"
>
  <!-- SVG chart -->
</div>
<div id="temp-graph-desc" class="sr-only">
  Temperature starts at 18 degrees Celsius at midnight,
  rises to 24 degrees by 8 AM,
  peaks at 29 degrees at 2 PM,
  then falls to 20 degrees by midnight.
  Rain is expected between 4 PM and 7 PM.
</div>

<!-- Provide data table alternative -->
<details class="sr-only">
  <summary>View temperature data as table</summary>
  <table>
    <thead>
      <tr><th>Time</th><th>Temperature</th><th>Conditions</th></tr>
    </thead>
    <tbody>
      <tr><td>12 AM</td><td>18°C</td><td>Clear</td></tr>
      <!-- ... -->
    </tbody>
  </table>
</details>
```

### Screen Reader Utilities

```css
/* Visually hidden but accessible */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* Show on focus (skip links) */
.sr-only-focusable:focus,
.sr-only-focusable:focus-within {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}
```

---

## Visual Accessibility

### Color Independence

Never rely on color alone:

```html
<!-- Bad: Color only -->
<span class="text-red-500">Error</span>

<!-- Good: Color + icon + text -->
<span class="text-red-500">
  <AlertIcon aria-hidden="true" />
  Error: City not found
</span>

<!-- Weather conditions: icon + text -->
<div class="weather-condition">
  <SunIcon aria-hidden="true" />
  <span>Clear Sky</span>
</div>
```

### Text Sizing

```css
/* Use relative units */
html {
  font-size: 100%; /* Respects user preference */
}

body {
  font-size: 1rem;
  line-height: 1.5;
}

/* Support up to 200% zoom */
@media (min-width: 320px) {
  /* Content reflows, no horizontal scroll */
}
```

### High Contrast Support

```css
/* Windows High Contrast Mode */
@media (forced-colors: active) {
  .btn {
    border: 2px solid ButtonText;
  }
  
  .card {
    border: 1px solid CanvasText;
  }
  
  .weather-icon {
    forced-color-adjust: none; /* Preserve weather colors */
  }
}
```

### Dark Mode

```css
/* Automatic dark mode */
@media (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) {
    --bg-body: #000000;
    --text-primary: #ffffff;
    /* ... */
  }
}
```

---

## Motion & Animation

### Reduced Motion

```css
/* Global reduced motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}
```

```typescript
// Composable for reduced motion
const useReducedMotion = () => {
  const prefersReducedMotion = ref(
    window.matchMedia('(prefers-reduced-motion: reduce)').matches
  )
  
  onMounted(() => {
    const mq = window.matchMedia('(prefers-reduced-motion: reduce)')
    const handler = (e: MediaQueryListEvent) => {
      prefersReducedMotion.value = e.matches
    }
    mq.addEventListener('change', handler)
    onUnmounted(() => mq.removeEventListener('change', handler))
  })
  
  return { prefersReducedMotion }
}

// Usage in components
const { prefersReducedMotion } = useReducedMotion()

const animationDuration = computed(() => 
  prefersReducedMotion.value ? 0 : 1000
)
```

### Safe Animation Patterns

```typescript
// Respect user preference in GSAP
const animateElement = (el: HTMLElement, prefersReducedMotion: boolean) => {
  if (prefersReducedMotion) {
    // Instant state change
    gsap.set(el, { opacity: 1, y: 0 })
  } else {
    // Animated transition
    gsap.fromTo(el, 
      { opacity: 0, y: 20 },
      { opacity: 1, y: 0, duration: 0.5 }
    )
  }
}
```

### WebGL Fallback

```vue
<template>
  <div class="weather-background">
    <!-- WebGL for capable devices with motion enabled -->
    <WeatherCanvas v-if="supportsWebGL && !prefersReducedMotion" />
    
    <!-- CSS gradient fallback -->
    <div v-else class="gradient-background" :style="gradientStyle" />
  </div>
</template>
```

---

## Alternative Modes

### Terminal Theme (High Contrast)

```css
[data-theme="terminal"] {
  /* Maximum contrast */
  --bg-body: #0a0a0a;
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --accent: #00ff00;
  
  /* Monospace for clarity */
  --font-family: 'JetBrains Mono', monospace;
  
  /* Clear borders */
  --border-style: dashed;
  --border-color: #00ff00;
}

[data-theme="terminal"] * {
  font-family: var(--font-family) !important;
  border-radius: 0 !important;
}

[data-theme="terminal"] .card {
  border: 1px dashed var(--border-color);
  background: transparent;
}
```

### Sonification Mode

```typescript
// Audio representation of weather data
const useSonification = () => {
  const audioContext = ref<AudioContext | null>(null)
  
  const init = () => {
    audioContext.value = new AudioContext()
  }
  
  const playTemperature = (temp: number) => {
    if (!audioContext.value) return
    
    const oscillator = audioContext.value.createOscillator()
    const gain = audioContext.value.createGain()
    
    // Map temperature to frequency
    // -20°C = 200Hz, 40°C = 800Hz
    const frequency = mapRange(temp, -20, 40, 200, 800)
    
    oscillator.type = 'sine'
    oscillator.frequency.value = frequency
    gain.gain.value = 0.1
    
    oscillator.connect(gain)
    gain.connect(audioContext.value.destination)
    
    oscillator.start()
    oscillator.stop(audioContext.value.currentTime + 0.5)
  }
  
  const playWeatherAmbience = (weatherType: WeatherType) => {
    // Play corresponding ambient sound
    const sounds = {
      rain: '/sounds/rain-ambient.mp3',
      storm: '/sounds/thunder.mp3',
      wind: '/sounds/wind-ambient.mp3'
    }
    // ...
  }
  
  return { init, playTemperature, playWeatherAmbience }
}
```

### Text-Only Mode

For extremely low bandwidth or assistive technology:

```html
<!-- Provide plain text alternative -->
<noscript>
  <style>
    .weather-canvas, .animated-graph { display: none; }
    .text-fallback { display: block; }
  </style>
</noscript>

<div class="text-fallback" hidden>
  <h1>Weather in Rome, Italy</h1>
  <p>Temperature: 24°C (feels like 26°C)</p>
  <p>Conditions: Partly Cloudy</p>
  <p>Wind: 15 km/h from the Northeast</p>
  <p>Humidity: 65%</p>
  <p>UV Index: 7 (High)</p>
</div>
```

---

## Testing Checklist

### Automated Testing

- [ ] Run axe-core on all pages
- [ ] Run Lighthouse accessibility audit
- [ ] Validate HTML (no duplicate IDs, valid ARIA)
- [ ] Check color contrast ratios

### Manual Testing

#### Keyboard
- [ ] Tab through entire page
- [ ] All interactive elements focusable
- [ ] Focus order logical
- [ ] Focus visible at all times
- [ ] Escape closes modals/drawers
- [ ] Enter/Space activates buttons
- [ ] Arrow keys work in widgets

#### Screen Reader (test with multiple)
- [ ] VoiceOver (macOS/iOS)
- [ ] NVDA (Windows)
- [ ] TalkBack (Android)
- [ ] Content read in logical order
- [ ] Buttons/links announced correctly
- [ ] Form labels associated
- [ ] Live regions announce updates
- [ ] Images have alt text
- [ ] Graphs have descriptions

#### Visual
- [ ] 200% zoom - no horizontal scroll
- [ ] 400% zoom - content still usable
- [ ] High contrast mode works
- [ ] Dark mode readable
- [ ] Color not sole indicator

#### Motion
- [ ] Reduced motion preference respected
- [ ] No content flashes >3 times/second
- [ ] Animations can be paused/stopped

#### Mobile
- [ ] Touch targets 44x44px minimum
- [ ] Gestures have alternatives
- [ ] Orientation not locked
- [ ] Zoom not disabled

### Assistive Technology Compatibility

| Technology | Status | Notes |
|------------|--------|-------|
| VoiceOver macOS | ✓ | Tested |
| VoiceOver iOS | ✓ | Tested |
| NVDA | ✓ | Tested |
| JAWS | ○ | To test |
| TalkBack | ○ | To test |
| Dragon | ○ | To test |
| Switch Control | ○ | To test |

### WCAG Checklist Summary

| Criterion | Level | Status |
|-----------|-------|--------|
| 1.1.1 Non-text Content | A | ✓ |
| 1.2.1 Audio-only/Video-only | A | N/A |
| 1.3.1 Info and Relationships | A | ✓ |
| 1.3.2 Meaningful Sequence | A | ✓ |
| 1.3.3 Sensory Characteristics | A | ✓ |
| 1.4.1 Use of Color | A | ✓ |
| 1.4.2 Audio Control | A | ✓ |
| 1.4.3 Contrast (Minimum) | AA | ✓ |
| 1.4.4 Resize Text | AA | ✓ |
| 1.4.5 Images of Text | AA | ✓ |
| 1.4.10 Reflow | AA | ✓ |
| 1.4.11 Non-text Contrast | AA | ✓ |
| 1.4.12 Text Spacing | AA | ✓ |
| 1.4.13 Content on Hover | AA | ✓ |
| 2.1.1 Keyboard | A | ✓ |
| 2.1.2 No Keyboard Trap | A | ✓ |
| 2.1.4 Character Key Shortcuts | A | ✓ |
| 2.2.1 Timing Adjustable | A | ✓ |
| 2.2.2 Pause, Stop, Hide | A | ✓ |
| 2.3.1 Three Flashes | A | ✓ |
| 2.4.1 Bypass Blocks | A | ✓ |
| 2.4.2 Page Titled | A | ✓ |
| 2.4.3 Focus Order | A | ✓ |
| 2.4.4 Link Purpose | A | ✓ |
| 2.4.5 Multiple Ways | AA | ✓ |
| 2.4.6 Headings and Labels | AA | ✓ |
| 2.4.7 Focus Visible | AA | ✓ |
| 2.5.1 Pointer Gestures | A | ✓ |
| 2.5.2 Pointer Cancellation | A | ✓ |
| 2.5.3 Label in Name | A | ✓ |
| 2.5.4 Motion Actuation | A | ✓ |
| 3.1.1 Language of Page | A | ✓ |
| 3.1.2 Language of Parts | AA | ✓ |
| 3.2.1 On Focus | A | ✓ |
| 3.2.2 On Input | A | ✓ |
| 3.2.3 Consistent Navigation | AA | ✓ |
| 3.2.4 Consistent Identification | AA | ✓ |
| 3.3.1 Error Identification | A | ✓ |
| 3.3.2 Labels or Instructions | A | ✓ |
| 3.3.3 Error Suggestion | AA | ✓ |
| 3.3.4 Error Prevention | AA | ✓ |
| 4.1.1 Parsing | A | ✓ |
| 4.1.2 Name, Role, Value | A | ✓ |
| 4.1.3 Status Messages | AA | ✓ |

---

*Accessibility Guide Version: 2.0.0*
*Last Updated: 2025-01-04*
</file>

<file path="docs/ANIMATIONS.md">
# WeatherVue 2.0 - Animation & Motion Design

> Comprehensive motion design specifications for an award-winning experience

## Table of Contents

1. [Motion Philosophy](#motion-philosophy)
2. [Timing & Easing](#timing--easing)
3. [Entrance Animations](#entrance-animations)
4. [Micro-interactions](#micro-interactions)
5. [Data Animations](#data-animations)
6. [Weather Effects](#weather-effects)
7. [Page Transitions](#page-transitions)
8. [Performance Guidelines](#performance-guidelines)

---

## Motion Philosophy

### Core Principles

| Principle | Description |
|-----------|-------------|
| **Purposeful** | Every animation serves a function (feedback, continuity, or delight) |
| **Natural** | Motion follows physics—ease in/out, momentum, spring dynamics |
| **Responsive** | Animations react to user input instantly |
| **Accessible** | All motion respects reduced-motion preferences |
| **Performant** | 60fps target, GPU-accelerated properties only |

### Motion Hierarchy

```
1. FEEDBACK (fastest)     - Button press, toggle, hover
   └─ 100-200ms
   
2. TRANSITION (medium)    - State changes, reveals
   └─ 200-400ms
   
3. ORCHESTRATION (slower) - Page transitions, complex sequences
   └─ 400-800ms
   
4. AMBIENT (continuous)   - Weather effects, floating particles
   └─ Infinite, subtle
```

---

## Timing & Easing

### Duration Scale

```typescript
const durations = {
  instant: 0,           // Reduced motion fallback
  fastest: 100,         // Micro-feedback
  fast: 200,            // Hovers, toggles
  normal: 300,          // Standard transitions
  slow: 500,            // Reveals, slides
  slower: 700,          // Complex animations
  slowest: 1000,        // Hero animations
  
  // Stagger delays
  stagger: {
    fast: 50,
    normal: 100,
    slow: 150
  }
}
```

### Easing Functions

```typescript
const easings = {
  // Standard easings
  linear: 'linear',
  easeIn: 'cubic-bezier(0.4, 0, 1, 0.2)',
  easeOut: 'cubic-bezier(0, 0, 0.2, 1)',
  easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  
  // Expressive easings
  easeOutBack: 'cubic-bezier(0.34, 1.56, 0.64, 1)',
  easeOutExpo: 'cubic-bezier(0.16, 1, 0.3, 1)',
  easeInOutExpo: 'cubic-bezier(0.87, 0, 0.13, 1)',
  
  // Spring physics (GSAP)
  spring: 'elastic.out(1, 0.5)',
  springTight: 'elastic.out(1, 0.75)',
  springLoose: 'elastic.out(1, 0.3)',
  
  // Bounce
  bounce: 'bounce.out',
  
  // Weather-specific
  wind: 'sine.inOut',          // Oscillating motion
  rain: 'power1.in',           // Accelerating fall
  float: 'sine.inOut',         // Gentle floating
}
```

### CSS Custom Properties

```css
:root {
  /* Durations */
  --duration-instant: 0ms;
  --duration-fast: 150ms;
  --duration-normal: 300ms;
  --duration-slow: 500ms;
  --duration-slower: 700ms;
  
  /* Easings */
  --ease-default: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-in: cubic-bezier(0.4, 0, 1, 0.2);
  --ease-out: cubic-bezier(0, 0, 0.2, 1);
  --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
  --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
}

/* Reduced motion overrides */
@media (prefers-reduced-motion: reduce) {
  :root {
    --duration-fast: 0ms;
    --duration-normal: 0ms;
    --duration-slow: 0ms;
    --duration-slower: 0ms;
  }
}
```

---

## Entrance Animations

### Splash Screen

```typescript
// Splash screen sequence
const splashTimeline = gsap.timeline()

// 1. Logo letters reveal
splashTimeline.fromTo('.logo-letter', 
  { y: 50, opacity: 0 },
  { 
    y: 0, 
    opacity: 1, 
    duration: 0.8,
    stagger: 0.1,
    ease: 'power3.out'
  }
)

// 2. Accent line expands
.fromTo('.accent-line',
  { scaleX: 0 },
  { 
    scaleX: 1, 
    duration: 0.6,
    ease: 'power2.out'
  },
  '-=0.3'
)

// 3. Fade out splash
.to('.splash-screen',
  {
    opacity: 0,
    duration: 0.5,
    ease: 'power2.inOut',
    onComplete: () => splashScreen.style.display = 'none'
  },
  '+=0.3'
)
```

```css
/* CSS fallback for splash */
@keyframes logo-reveal {
  from {
    opacity: 0;
    transform: translateY(50px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.logo-letter {
  animation: logo-reveal 0.8s var(--ease-out-expo) forwards;
  animation-delay: calc(var(--index) * 0.1s);
}
```

### Page Load / Weather Cards

```typescript
// Staggered card entrance
const animateCards = (cards: HTMLElement[]) => {
  gsap.fromTo(cards,
    {
      opacity: 0,
      y: 40,
      scale: 0.95
    },
    {
      opacity: 1,
      y: 0,
      scale: 1,
      duration: 0.6,
      stagger: 0.1,
      ease: 'power3.out'
    }
  )
}
```

### Drawer Slide

```typescript
// Settings drawer animation
const openDrawer = () => {
  gsap.to('.settings-drawer', {
    x: 0,
    duration: 0.5,
    ease: 'power3.out'
  })
  
  // Stagger content items
  gsap.fromTo('.drawer-item',
    { opacity: 0, x: 20 },
    {
      opacity: 1,
      x: 0,
      duration: 0.4,
      stagger: 0.05,
      delay: 0.2,
      ease: 'power2.out'
    }
  )
}

const closeDrawer = () => {
  gsap.to('.settings-drawer', {
    x: '100%',
    duration: 0.4,
    ease: 'power3.inOut'
  })
}
```

### Scroll Reveals

```typescript
// Intersection Observer + GSAP
const useScrollReveal = () => {
  onMounted(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            gsap.to(entry.target, {
              opacity: 1,
              y: 0,
              duration: 0.6,
              ease: 'power3.out'
            })
            observer.unobserve(entry.target)
          }
        })
      },
      { threshold: 0.2 }
    )
    
    document.querySelectorAll('.reveal').forEach(el => {
      gsap.set(el, { opacity: 0, y: 30 })
      observer.observe(el)
    })
  })
}
```

---

## Micro-interactions

### Button Hover

```css
.btn {
  transition: 
    transform var(--duration-fast) var(--ease-out),
    box-shadow var(--duration-fast) var(--ease-out),
    background-color var(--duration-fast) var(--ease-out);
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.btn:active {
  transform: translateY(0);
  transition-duration: 50ms;
}
```

### Magnetic Button Effect

```typescript
const useMagneticEffect = (
  element: Ref<HTMLElement>,
  options = { strength: 0.3, radius: 100 }
) => {
  const handleMouseMove = (e: MouseEvent) => {
    const rect = element.value.getBoundingClientRect()
    const centerX = rect.left + rect.width / 2
    const centerY = rect.top + rect.height / 2
    
    const deltaX = e.clientX - centerX
    const deltaY = e.clientY - centerY
    const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2)
    
    if (distance < options.radius) {
      const strength = 1 - (distance / options.radius)
      
      gsap.to(element.value, {
        x: deltaX * strength * options.strength,
        y: deltaY * strength * options.strength,
        duration: 0.3,
        ease: 'power2.out'
      })
    }
  }
  
  const handleMouseLeave = () => {
    gsap.to(element.value, {
      x: 0,
      y: 0,
      duration: 0.5,
      ease: 'elastic.out(1, 0.3)'
    })
  }
  
  onMounted(() => {
    window.addEventListener('mousemove', handleMouseMove)
    element.value.addEventListener('mouseleave', handleMouseLeave)
  })
  
  onUnmounted(() => {
    window.removeEventListener('mousemove', handleMouseMove)
    element.value.removeEventListener('mouseleave', handleMouseLeave)
  })
}
```

### Card Parallax

```typescript
const useCardParallax = (cardRef: Ref<HTMLElement>) => {
  const handleMouseMove = (e: MouseEvent) => {
    const rect = cardRef.value.getBoundingClientRect()
    const x = (e.clientX - rect.left) / rect.width - 0.5
    const y = (e.clientY - rect.top) / rect.height - 0.5
    
    gsap.to(cardRef.value, {
      rotateY: x * 10,
      rotateX: -y * 10,
      transformPerspective: 1000,
      duration: 0.5,
      ease: 'power2.out'
    })
    
    // Move layers at different speeds
    gsap.to(cardRef.value.querySelector('.card-bg'), {
      x: x * 10,
      y: y * 10,
      duration: 0.5
    })
    
    gsap.to(cardRef.value.querySelector('.card-content'), {
      x: x * 20,
      y: y * 20,
      duration: 0.5
    })
    
    gsap.to(cardRef.value.querySelector('.card-icon'), {
      x: x * 30,
      y: y * 30,
      duration: 0.5
    })
  }
  
  const handleMouseLeave = () => {
    gsap.to(cardRef.value, {
      rotateY: 0,
      rotateX: 0,
      duration: 0.5,
      ease: 'power2.out'
    })
    
    gsap.to([
      cardRef.value.querySelector('.card-bg'),
      cardRef.value.querySelector('.card-content'),
      cardRef.value.querySelector('.card-icon')
    ], {
      x: 0,
      y: 0,
      duration: 0.5
    })
  }
  
  // ... event listener setup
}
```

### Toggle Switch

```css
.toggle-track {
  transition: background-color var(--duration-fast) var(--ease-default);
}

.toggle-thumb {
  transition: transform var(--duration-normal) var(--ease-out-back);
}

.toggle-input:checked + .toggle-track {
  background-color: var(--accent);
}

.toggle-input:checked + .toggle-track .toggle-thumb {
  transform: translateX(24px);
}
```

### Checkbox Ticket

```css
.checkbox-ticket {
  transition: 
    transform var(--duration-fast) var(--ease-out),
    background-color var(--duration-fast) var(--ease-out),
    border-color var(--duration-fast) var(--ease-out);
}

.checkbox-ticket:hover {
  transform: translateY(-1px);
}

.checkbox-ticket.active {
  transform: translateY(-2px);
  background-color: var(--accent);
}

.checkbox-ticket:active {
  transform: translateY(0) scale(0.98);
}
```

---

## Data Animations

### Animated Numbers

```typescript
// Counting animation with easing
const useAnimatedNumber = (
  targetValue: Ref<number>,
  options = { duration: 1000, decimals: 0 }
) => {
  const displayValue = ref(0)
  const previousValue = ref(0)
  
  watch(targetValue, (newVal) => {
    const startValue = previousValue.value
    const startTime = performance.now()
    
    const animate = (currentTime: number) => {
      const elapsed = currentTime - startTime
      const progress = Math.min(elapsed / options.duration, 1)
      
      // Ease out expo
      const eased = 1 - Math.pow(1 - progress, 4)
      
      displayValue.value = Number(
        (startValue + (newVal - startValue) * eased).toFixed(options.decimals)
      )
      
      if (progress < 1) {
        requestAnimationFrame(animate)
      } else {
        previousValue.value = newVal
      }
    }
    
    requestAnimationFrame(animate)
  })
  
  return displayValue
}
```

### Temperature Graph Drawing

```typescript
// D3 line drawing animation
const animateTemperatureLine = (pathElement: SVGPathElement) => {
  const length = pathElement.getTotalLength()
  
  // Set up initial state
  pathElement.style.strokeDasharray = `${length}`
  pathElement.style.strokeDashoffset = `${length}`
  
  // Animate
  gsap.to(pathElement, {
    strokeDashoffset: 0,
    duration: 1.5,
    ease: 'power2.inOut'
  })
}

// Area fill fade in
const animateAreaFill = (areaElement: SVGPathElement) => {
  gsap.fromTo(areaElement,
    { opacity: 0 },
    { 
      opacity: 1, 
      duration: 0.8, 
      delay: 0.5,
      ease: 'power2.out'
    }
  )
}
```

### Timeline Scrubber

```typescript
// Smooth scrubbing with momentum
const useTimelineScrub = () => {
  const position = ref(0)
  const velocity = ref(0)
  const isDragging = ref(false)
  
  const handleDrag = (deltaX: number) => {
    const newPosition = position.value + deltaX / containerWidth
    position.value = Math.max(0, Math.min(1, newPosition))
    velocity.value = deltaX
  }
  
  const handleRelease = () => {
    isDragging.value = false
    
    // Momentum scroll
    const decelerate = () => {
      if (Math.abs(velocity.value) < 0.1) return
      
      velocity.value *= 0.95 // Friction
      position.value = Math.max(0, Math.min(1, 
        position.value + velocity.value / containerWidth
      ))
      
      requestAnimationFrame(decelerate)
    }
    
    decelerate()
  }
}
```

### Wind Compass

```typescript
// Particle flow animation
const animateWindParticles = (
  particles: Particle[],
  windSpeed: number,
  windDirection: number
) => {
  const baseSpeed = mapRange(windSpeed, 0, 100, 0.5, 5)
  const directionRad = (windDirection - 90) * (Math.PI / 180)
  
  particles.forEach((particle, i) => {
    // Stagger start positions
    const delay = i * 0.1
    
    gsap.to(particle, {
      x: `+=${Math.cos(directionRad) * 100}`,
      y: `+=${Math.sin(directionRad) * 100}`,
      opacity: 0,
      duration: 2 / baseSpeed,
      delay,
      ease: 'none',
      repeat: -1,
      onRepeat: () => {
        // Reset to start position
        particle.x = centerX + (Math.random() - 0.5) * 20
        particle.y = centerY + (Math.random() - 0.5) * 20
        particle.opacity = 1
      }
    })
  })
}
```

### UV Gauge Needle

```typescript
// Animated gauge needle
const animateUVNeedle = (needle: HTMLElement, uvIndex: number) => {
  // Map UV 0-11+ to angle -90 to 90
  const angle = mapRange(Math.min(uvIndex, 11), 0, 11, -90, 90)
  
  gsap.to(needle, {
    rotation: angle,
    duration: 1,
    ease: 'elastic.out(1, 0.5)'
  })
}
```

---

## Weather Effects

### Rain Particles (Three.js)

```typescript
// Rain particle system
const createRainSystem = (scene: THREE.Scene, intensity: number) => {
  const particleCount = Math.floor(intensity * 1000)
  const geometry = new THREE.BufferGeometry()
  
  const positions = new Float32Array(particleCount * 3)
  const velocities = new Float32Array(particleCount)
  
  for (let i = 0; i < particleCount; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 100      // x
    positions[i * 3 + 1] = Math.random() * 100          // y
    positions[i * 3 + 2] = (Math.random() - 0.5) * 50   // z
    velocities[i] = 0.5 + Math.random() * 0.5           // fall speed
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  
  const material = new THREE.PointsMaterial({
    color: 0x8899aa,
    size: 0.1,
    transparent: true,
    opacity: 0.6
  })
  
  const rain = new THREE.Points(geometry, material)
  scene.add(rain)
  
  // Animation loop
  const animate = () => {
    const positions = geometry.attributes.position.array as Float32Array
    
    for (let i = 0; i < particleCount; i++) {
      positions[i * 3 + 1] -= velocities[i] // Fall down
      
      // Reset when below ground
      if (positions[i * 3 + 1] < -10) {
        positions[i * 3 + 1] = 50
        // Trigger splash effect at impact point
      }
    }
    
    geometry.attributes.position.needsUpdate = true
    requestAnimationFrame(animate)
  }
  
  animate()
  
  return rain
}
```

### Snow Particles

```typescript
// Gentler snow with drift
const createSnowSystem = (scene: THREE.Scene, intensity: number) => {
  const particleCount = Math.floor(intensity * 500)
  
  // Use instanced mesh for performance
  const geometry = new THREE.CircleGeometry(0.05, 6)
  const material = new THREE.MeshBasicMaterial({ 
    color: 0xffffff,
    transparent: true,
    opacity: 0.8
  })
  
  const snow = new THREE.InstancedMesh(geometry, material, particleCount)
  
  // Animation with gentle drift
  const animate = (time: number) => {
    const matrix = new THREE.Matrix4()
    
    for (let i = 0; i < particleCount; i++) {
      const x = Math.sin(time * 0.001 + i) * 0.5 // Horizontal drift
      const y = -((time * 0.02 + i * 10) % 100)  // Fall
      const z = Math.cos(time * 0.001 + i) * 0.3 // Depth drift
      
      matrix.setPosition(x + positions[i].x, y, z + positions[i].z)
      snow.setMatrixAt(i, matrix)
    }
    
    snow.instanceMatrix.needsUpdate = true
    requestAnimationFrame(() => animate(performance.now()))
  }
  
  animate(0)
  return snow
}
```

### Lightning Flash

```typescript
// Lightning effect
const triggerLightning = () => {
  const overlay = document.querySelector('.lightning-overlay')
  
  gsap.timeline()
    // Quick flash
    .to(overlay, { opacity: 0.8, duration: 0.05 })
    .to(overlay, { opacity: 0, duration: 0.1 })
    // Second flash (optional)
    .to(overlay, { opacity: 0.5, duration: 0.05 }, '+=0.1')
    .to(overlay, { opacity: 0, duration: 0.15 })
  
  // Thunder sound (delayed for realism)
  setTimeout(() => {
    playSound('thunder')
    triggerHaptic('thunder')
  }, 500 + Math.random() * 2000)
}

// Random lightning during storms
const startLightningLoop = () => {
  const scheduleNext = () => {
    const delay = 3000 + Math.random() * 10000 // 3-13 seconds
    setTimeout(() => {
      triggerLightning()
      scheduleNext()
    }, delay)
  }
  scheduleNext()
}
```

### Fog Shader

```glsl
// fog.frag
uniform float uTime;
uniform vec2 uMouse;
uniform float uDensity;
uniform vec3 uColor;

varying vec2 vUv;

// Simplex noise function
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
// ... full noise implementation

void main() {
  vec2 uv = vUv;
  
  // Mouse influence
  vec2 mouseInfluence = (uMouse - 0.5) * 0.1;
  uv += mouseInfluence;
  
  // Multi-layer noise for depth
  float noise1 = snoise(vec3(uv * 2.0, uTime * 0.1)) * 0.5;
  float noise2 = snoise(vec3(uv * 4.0, uTime * 0.15)) * 0.25;
  float noise3 = snoise(vec3(uv * 8.0, uTime * 0.2)) * 0.125;
  
  float fog = noise1 + noise2 + noise3;
  fog = smoothstep(0.0, 1.0, fog * uDensity + 0.5);
  
  gl_FragColor = vec4(uColor, fog * 0.3);
}
```

### Sky Color Transitions

```typescript
// Smooth sky gradient transitions
const transitionSkyColors = (
  from: { start: string; end: string },
  to: { start: string; end: string },
  duration: number
) => {
  gsap.to(':root', {
    '--sky-start': to.start,
    '--sky-end': to.end,
    duration,
    ease: 'power2.inOut'
  })
}

// Time-of-day color mapping
const skyColors = {
  night: { start: '#0f0f23', end: '#1a1a2e' },
  dawn: { start: '#ff6b6b', end: '#4ecdc4' },
  morning: { start: '#87ceeb', end: '#1e90ff' },
  noon: { start: '#87ceeb', end: '#0066cc' },
  afternoon: { start: '#ffd93d', end: '#ff6b6b' },
  dusk: { start: '#ff6b6b', end: '#4a0080' },
  evening: { start: '#2d1f3d', end: '#0f0f23' }
}
```

---

## Page Transitions

### City Portal Transition

```typescript
// Full city change transition
const transitionToCity = async (newCity: City) => {
  const tl = gsap.timeline()
  
  // Phase 1: Current content zooms and blurs
  tl.to('.weather-content', {
    scale: 1.5,
    filter: 'blur(20px)',
    opacity: 0,
    duration: 0.4,
    ease: 'power2.in'
  })
  
  // Phase 2: Particle acceleration
  tl.to('.weather-canvas', {
    '--particle-speed': 10,
    duration: 0.3
  }, '-=0.2')
  
  // Fetch data during animation
  const dataPromise = fetchWeather(newCity)
  
  // Phase 3: Color shift
  tl.to(':root', {
    '--sky-start': newCity.skyColors.start,
    '--sky-end': newCity.skyColors.end,
    duration: 0.4,
    ease: 'power2.inOut'
  }, '-=0.2')
  
  // Wait for data
  await dataPromise
  
  // Phase 4: Normalize particles
  tl.to('.weather-canvas', {
    '--particle-speed': 1,
    duration: 0.3
  })
  
  // Phase 5: New content emerges
  tl.fromTo('.weather-content',
    {
      scale: 0.8,
      filter: 'blur(10px)',
      opacity: 0
    },
    {
      scale: 1,
      filter: 'blur(0px)',
      opacity: 1,
      duration: 0.5,
      ease: 'power2.out'
    }
  )
  
  // Phase 6: Cards stagger in
  tl.fromTo('.weather-card',
    { y: 30, opacity: 0 },
    {
      y: 0,
      opacity: 1,
      stagger: 0.08,
      duration: 0.4,
      ease: 'power2.out'
    },
    '-=0.3'
  )
  
  return tl
}
```

### Theme Transition

```typescript
// Smooth theme change
const transitionTheme = (newTheme: Theme) => {
  // Add transition class
  document.documentElement.classList.add('theme-transitioning')
  
  // Change theme
  document.documentElement.setAttribute('data-theme', newTheme)
  
  // Animate specific elements
  gsap.fromTo('.theme-sensitive',
    { opacity: 0.5 },
    { opacity: 1, duration: 0.5, stagger: 0.02 }
  )
  
  // Remove transition class
  setTimeout(() => {
    document.documentElement.classList.remove('theme-transitioning')
  }, 500)
}
```

```css
.theme-transitioning,
.theme-transitioning * {
  transition: 
    background-color 0.5s ease,
    color 0.5s ease,
    border-color 0.5s ease !important;
}
```

---

## Performance Guidelines

### GPU-Accelerated Properties Only

```css
/* ✅ DO - GPU accelerated */
.animate-good {
  transform: translateX(100px);
  opacity: 0.5;
  filter: blur(10px);
}

/* ❌ DON'T - Triggers layout */
.animate-bad {
  left: 100px;
  width: 200px;
  margin-left: 50px;
}
```

### Will-Change Hints

```css
/* Use sparingly - only on elements that WILL animate */
.weather-card {
  will-change: transform;
}

.weather-canvas {
  will-change: transform, opacity;
}

/* Remove after animation */
.animation-complete {
  will-change: auto;
}
```

### Debounce & Throttle

```typescript
// Throttle mouse move handlers
const throttledMouseMove = throttle((e: MouseEvent) => {
  updateParallax(e)
}, 16) // ~60fps

// Debounce resize handlers
const debouncedResize = debounce(() => {
  recalculateLayout()
}, 100)
```

### Conditional Animations

```typescript
// Reduce particles on mobile
const particleCount = computed(() => {
  if (isMobile.value) return 300
  if (isTablet.value) return 600
  return 1000
})

// Skip animations when tab not visible
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    gsap.globalTimeline.pause()
  } else {
    gsap.globalTimeline.resume()
  }
})
```

### Animation Cleanup

```typescript
// Always clean up GSAP animations
onUnmounted(() => {
  gsap.killTweensOf('.weather-card')
  gsap.killTweensOf('.weather-canvas')
  timeline.kill()
})
```

### Performance Monitoring

```typescript
// Monitor frame rate
const monitorPerformance = () => {
  let frames = 0
  let lastTime = performance.now()
  
  const checkFPS = () => {
    frames++
    const now = performance.now()
    
    if (now - lastTime >= 1000) {
      const fps = frames
      frames = 0
      lastTime = now
      
      // Reduce effects if FPS drops
      if (fps < 30) {
        reduceAnimationComplexity()
      }
    }
    
    requestAnimationFrame(checkFPS)
  }
  
  checkFPS()
}
```

---

## Animation Cheat Sheet

| Animation | Duration | Easing | Trigger |
|-----------|----------|--------|---------|
| Button hover | 150ms | ease-out | mouseenter |
| Button press | 50ms | ease-in | mousedown |
| Card hover | 300ms | ease-out | mouseenter |
| Drawer open | 500ms | power3.out | click |
| Drawer close | 400ms | power3.inOut | click/escape |
| Number count | 1000ms | power4.out | value change |
| Card entrance | 600ms | power3.out | page load |
| Card stagger | 100ms | - | each card |
| Graph draw | 1500ms | power2.inOut | scroll reveal |
| City transition | 1000ms | mixed | city change |
| Theme change | 500ms | power2.inOut | theme toggle |
| Lightning flash | 150ms | linear | random |
| Rain particle | infinite | linear | weather state |
| Fog drift | infinite | sine.inOut | weather state |

---

*Animation Guide Version: 2.0.0*
*Last Updated: 2025-01-04*
</file>

<file path="docs/ARCHITECTURE.md">
# WeatherVue 2.0 - System Architecture

> Award-winning weather application with immersive atmospheric design

## Table of Contents

1. [Overview](#overview)
2. [Technology Stack](#technology-stack)
3. [Project Structure](#project-structure)
4. [Component Architecture](#component-architecture)
5. [State Management](#state-management)
6. [Data Flow](#data-flow)
7. [API Integration](#api-integration)
8. [Performance Architecture](#performance-architecture)
9. [Build & Deployment](#build--deployment)

---

## Overview

### Design Philosophy: "Atmospheric Brutalism"

WeatherVue 2.0 combines **editorial typography** with **organic, living weather effects**. The tension between rigid grids and fluid atmospheric motion creates the artistic feel that wins design awards.

### Key Architectural Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Framework | Vue 3 + Composition API | Reactive, composable, excellent TypeScript support |
| Build Tool | Vite | Fast HMR, native ESM, optimized builds |
| Language | TypeScript (strict) | Type safety, better DX, portfolio signal |
| Styling | Tailwind CSS + CSS Variables | Utility-first with dynamic theming |
| State | Pinia | Official Vue store, devtools integration |
| Animation | GSAP + Three.js | Industry-standard motion + WebGL |
| Data Viz | D3.js | Powerful, customizable charts |
| Icons | Lucide Vue | Tree-shakeable, consistent |

---

## Technology Stack

### Core Dependencies

```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "@vueuse/core": "^10.7.0",
    "three": "^0.160.0",
    "@types/three": "^0.160.0",
    "gsap": "^3.12.0",
    "d3": "^7.8.0",
    "lucide-vue-next": "^0.300.0"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "typescript": "^5.3.0",
    "@vitejs/plugin-vue": "^4.5.0",
    "tailwindcss": "^3.4.0",
    "autoprefixer": "^10.4.0",
    "postcss": "^8.4.0",
    "@vue/tsconfig": "^0.5.0",
    "vite-plugin-pwa": "^0.17.0"
  }
}
```

### Browser Support

- Chrome 90+ (primary)
- Firefox 88+
- Safari 14+
- Edge 90+
- Mobile Safari iOS 14+
- Chrome Android 90+

---

## Project Structure

```
weathervue/
├── docs/                          # Documentation
│   ├── ARCHITECTURE.md            # This file
│   ├── DESIGN_SYSTEM.md           # Design tokens & guidelines
│   ├── FEATURES.md                # Feature specifications
│   ├── IMPLEMENTATION_PLAN.md     # Development roadmap
│   ├── ACCESSIBILITY.md           # A11y requirements
│   └── ANIMATIONS.md              # Motion design specs
│
├── public/
│   ├── favicon.ico
│   ├── robots.txt
│   └── manifest.json              # PWA manifest
│
├── src/
│   ├── assets/
│   │   ├── fonts/                 # Self-hosted fonts
│   │   │   ├── playfair-display/
│   │   │   └── inter-variable/
│   │   ├── sounds/                # Ambient audio files
│   │   │   ├── rain-ambient.mp3
│   │   │   ├── wind-ambient.mp3
│   │   │   └── thunder.mp3
│   │   └── images/
│   │       └── city-blurhash/     # BlurHash placeholders
│   │
│   ├── components/
│   │   ├── canvas/                # WebGL components
│   │   │   ├── WeatherCanvas.vue  # Three.js atmosphere
│   │   │   ├── ParticleSystem.ts  # Rain/snow particles
│   │   │   └── shaders/
│   │   │       ├── fog.vert
│   │   │       ├── fog.frag
│   │   │       ├── rain.vert
│   │   │       └── rain.frag
│   │   │
│   │   ├── ui/                    # Base UI components
│   │   │   ├── MagneticButton.vue
│   │   │   ├── GlassmorphicCard.vue
│   │   │   ├── AnimatedNumber.vue
│   │   │   ├── SkeletonLoader.vue
│   │   │   ├── IconWrapper.vue
│   │   │   └── index.ts           # Barrel export
│   │   │
│   │   ├── weather/               # Weather-specific components
│   │   │   ├── WeatherCard.vue
│   │   │   ├── TemperatureGraph.vue
│   │   │   ├── WindCompass.vue
│   │   │   ├── TimelineScrubber.vue
│   │   │   ├── SunriseSunsetArc.vue
│   │   │   ├── UVIndexGauge.vue
│   │   │   ├── PrecipitationBar.vue
│   │   │   ├── WeeklyForecast.vue
│   │   │   ├── HourlyForecast.vue
│   │   │   └── index.ts
│   │   │
│   │   ├── layout/                # Layout components
│   │   │   ├── AppHeader.vue
│   │   │   ├── SettingsDrawer.vue
│   │   │   ├── BottomNav.vue
│   │   │   ├── SplashScreen.vue
│   │   │   └── index.ts
│   │   │
│   │   └── search/                # City search
│   │       ├── CitySearch.vue
│   │       ├── CitySearchResults.vue
│   │       └── RecentCities.vue
│   │
│   ├── composables/               # Vue composables
│   │   ├── useWeather.ts          # Weather data fetching
│   │   ├── useGeolocation.ts      # Browser geolocation
│   │   ├── useTheme.ts            # Theme management
│   │   ├── useMagneticEffect.ts   # Magnetic cursor
│   │   ├── useParallax.ts         # Parallax effects
│   │   ├── useHaptics.ts          # Vibration API
│   │   ├── useAudio.ts            # Ambient sounds
│   │   ├── useSonification.ts     # Data sonification
│   │   ├── useReducedMotion.ts    # Motion preferences
│   │   └── index.ts
│   │
│   ├── stores/                    # Pinia stores
│   │   ├── weatherStore.ts        # Weather data state
│   │   ├── locationStore.ts       # City/location state
│   │   ├── settingsStore.ts       # User preferences
│   │   └── index.ts
│   │
│   ├── services/                  # API services
│   │   ├── weatherApi.ts          # Open-Meteo integration
│   │   ├── geocodingApi.ts        # City search API
│   │   ├── translationApi.ts      # Azure Translator
│   │   └── cache.ts               # SWR-like caching
│   │
│   ├── types/                     # TypeScript types
│   │   ├── weather.ts             # Weather data types
│   │   ├── location.ts            # Location types
│   │   ├── theme.ts               # Theme types
│   │   └── index.ts
│   │
│   ├── utils/                     # Utility functions
│   │   ├── animations.ts          # GSAP helpers
│   │   ├── interpolation.ts       # Data interpolation
│   │   ├── formatters.ts          # Number/date formatting
│   │   ├── weatherCodes.ts        # WMO code mapping
│   │   └── constants.ts           # App constants
│   │
│   ├── styles/                    # Global styles
│   │   ├── main.css               # Tailwind imports
│   │   ├── variables.css          # CSS custom properties
│   │   ├── animations.css         # Keyframe animations
│   │   ├── fonts.css              # Font-face declarations
│   │   └── utilities.css          # Custom utilities
│   │
│   ├── App.vue                    # Root component
│   ├── main.ts                    # App entry point
│   └── vite-env.d.ts              # Vite type declarations
│
├── .env.example                   # Environment template
├── .eslintrc.cjs                  # ESLint config
├── .prettierrc                    # Prettier config
├── index.html                     # HTML entry point
├── package.json
├── postcss.config.js
├── tailwind.config.js
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts
```

---

## Component Architecture

### Component Hierarchy

```
App.vue
├── SplashScreen.vue (conditional)
├── WeatherCanvas.vue (WebGL background)
├── AppHeader.vue
│   ├── Logo + ThemeToggle
│   └── SettingsButton
├── main content
│   ├── CitySearch.vue
│   │   ├── SearchInput
│   │   ├── CitySearchResults.vue
│   │   └── RecentCities.vue
│   ├── CurrentWeather section
│   │   ├── AnimatedNumber.vue (temperature)
│   │   └── WeatherCard.vue (conditions)
│   ├── TimelineScrubber.vue
│   ├── TemperatureGraph.vue (D3)
│   ├── Weather Metrics Grid
│   │   ├── WindCompass.vue
│   │   ├── UVIndexGauge.vue
│   │   ├── PrecipitationBar.vue
│   │   ├── SunriseSunsetArc.vue
│   │   └── WeatherCard.vue (humidity, pressure, etc.)
│   ├── HourlyForecast.vue
│   └── WeeklyForecast.vue
├── SettingsDrawer.vue (off-canvas)
│   ├── ThemeSelector
│   ├── UnitsSelector
│   ├── AccessibilityToggles
│   └── AudioSettings
└── BottomNav.vue (mobile only)
```

### Component Communication

```
┌─────────────────────────────────────────────────────────────┐
│                        Pinia Stores                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ weatherStore│  │locationStore│  │settingsStore│          │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘          │
│         │                │                │                  │
└─────────┼────────────────┼────────────────┼──────────────────┘
          │                │                │
    ┌─────▼─────┐    ┌─────▼─────┐    ┌─────▼─────┐
    │ Weather   │    │ City      │    │ Theme     │
    │ Components│    │ Search    │    │ Components│
    └───────────┘    └───────────┘    └───────────┘
```

### Component Props Pattern

```typescript
// All components follow this pattern
interface Props {
  // Required props first
  value: number
  
  // Optional props with defaults
  size?: 'sm' | 'md' | 'lg'
  animated?: boolean
  
  // Callbacks
  onChange?: (value: number) => void
}

// Emits are typed
interface Emits {
  (e: 'update:value', value: number): void
  (e: 'animationComplete'): void
}
```

---

## State Management

### Store Structure

#### weatherStore.ts
```typescript
interface WeatherState {
  // Current conditions
  current: CurrentWeather | null
  
  // Forecasts
  hourly: HourlyForecast[]
  daily: DailyForecast[]
  
  // Loading states
  isLoading: boolean
  error: Error | null
  
  // Cache metadata
  lastFetched: Date | null
  
  // Timeline state
  timelinePosition: number // 0-1 for 24h scrub
  interpolatedWeather: CurrentWeather | null
}

interface WeatherActions {
  fetchWeather(lat: number, lng: number): Promise<void>
  setTimelinePosition(position: number): void
  clearError(): void
}
```

#### locationStore.ts
```typescript
interface LocationState {
  // Current location
  currentCity: City | null
  coordinates: Coordinates | null
  
  // Search
  searchQuery: string
  searchResults: City[]
  isSearching: boolean
  
  // History
  recentCities: City[]
  favoriteCities: City[]
  
  // Geolocation
  isGeolocating: boolean
  geoError: GeolocationError | null
}
```

#### settingsStore.ts
```typescript
interface SettingsState {
  // Appearance
  theme: 'light' | 'dark' | 'system' | 'terminal'
  reducedMotion: boolean
  
  // Units
  temperatureUnit: 'celsius' | 'fahrenheit'
  speedUnit: 'kmh' | 'mph' | 'ms'
  
  // Accessibility
  sonificationEnabled: boolean
  highContrast: boolean
  
  // Audio
  ambientAudioEnabled: boolean
  ambientVolume: number
  
  // Haptics
  hapticsEnabled: boolean
}
```

---

## Data Flow

### Weather Data Fetch Flow

```
User Action (city select / geolocation)
         │
         ▼
┌─────────────────────┐
│  locationStore      │
│  setCurrentCity()   │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  weatherStore       │
│  fetchWeather()     │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐     ┌─────────────────────┐
│  cache.ts           │────▶│  Return cached data │
│  checkCache()       │     │  if fresh (<5min)   │
└──────────┬──────────┘     └─────────────────────┘
           │ cache miss
           ▼
┌─────────────────────┐
│  weatherApi.ts      │
│  fetchFromOpenMeteo │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Transform data     │
│  to internal types  │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Update store +     │
│  Update cache       │
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  Components react   │
│  via computed props │
└─────────────────────┘
```

### Timeline Scrub Data Flow

```
User drags TimelineScrubber
         │
         ▼
┌─────────────────────────┐
│  Emit position (0-1)     │
│  Debounced to 16ms       │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│  weatherStore           │
│  setTimelinePosition()  │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│  Computed: interpolate  │
│  between hourly points  │
└───────────┬─────────────┘
            │
            ▼
┌─────────────────────────┐
│  All components react:  │
│  - Temperature updates  │
│  - Canvas colors shift  │
│  - Graph marker moves   │
└─────────────────────────┘
```

---

## API Integration

### Open-Meteo Weather API

```typescript
// Base URL
const BASE_URL = 'https://api.open-meteo.com/v1/forecast'

// Current weather params
const CURRENT_PARAMS = [
  'temperature_2m',
  'relative_humidity_2m',
  'apparent_temperature',
  'is_day',
  'precipitation',
  'rain',
  'weather_code',
  'cloud_cover',
  'pressure_msl',
  'wind_speed_10m',
  'wind_direction_10m',
  'uv_index'
]

// Hourly params (for timeline)
const HOURLY_PARAMS = [
  'temperature_2m',
  'precipitation_probability',
  'weather_code',
  'wind_speed_10m'
]

// Daily params (for 7-day)
const DAILY_PARAMS = [
  'weather_code',
  'temperature_2m_max',
  'temperature_2m_min',
  'sunrise',
  'sunset',
  'uv_index_max',
  'precipitation_probability_max'
]
```

### Open-Meteo Geocoding API

```typescript
// City search
const GEOCODING_URL = 'https://geocoding-api.open-meteo.com/v1/search'

// Params
interface GeocodingParams {
  name: string       // Search query
  count?: number     // Max results (default 10)
  language?: string  // Result language
}
```

### Azure Translator API

```typescript
// Translation endpoint
const TRANSLATOR_URL = 'https://api.cognitive.microsofttranslator.com/translate'

// Headers required
const headers = {
  'Ocp-Apim-Subscription-Key': AZURE_API_KEY,
  'Ocp-Apim-Subscription-Region': AZURE_REGION,
  'Content-Type': 'application/json'
}
```

---

## Performance Architecture

### Optimization Strategies

| Strategy | Implementation |
|----------|---------------|
| **Code Splitting** | Dynamic imports for heavy components (Three.js, D3) |
| **Tree Shaking** | ES modules, named exports, sideEffects: false |
| **Font Loading** | Preload critical fonts, font-display: swap |
| **Image Optimization** | BlurHash placeholders, lazy loading |
| **Caching** | SWR pattern with 5-min stale time |
| **Bundle Analysis** | vite-plugin-bundle-analyzer |

### Lazy Loading Strategy

```typescript
// Heavy components loaded on demand
const WeatherCanvas = defineAsyncComponent(() => 
  import('./components/canvas/WeatherCanvas.vue')
)

const TemperatureGraph = defineAsyncComponent(() => 
  import('./components/weather/TemperatureGraph.vue')
)

// Settings drawer loaded on interaction
const SettingsDrawer = defineAsyncComponent(() =>
  import('./components/layout/SettingsDrawer.vue')
)
```

### Performance Budgets

| Metric | Target |
|--------|--------|
| First Contentful Paint | < 1.5s |
| Largest Contentful Paint | < 2.5s |
| Time to Interactive | < 3.5s |
| Cumulative Layout Shift | < 0.1 |
| Total Bundle Size | < 200KB (gzipped) |
| Main Thread Work | < 4s |

---

## Build & Deployment

### Build Configuration

```typescript
// vite.config.ts
export default defineConfig({
  plugins: [
    vue(),
    VitePWA({
      registerType: 'autoUpdate',
      manifest: {
        name: 'WeatherVue',
        short_name: 'WeatherVue',
        theme_color: '#000000',
        icons: [/* ... */]
      }
    })
  ],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'three': ['three'],
          'd3': ['d3'],
          'gsap': ['gsap']
        }
      }
    }
  }
})
```

### Environment Variables

```bash
# .env.example
VITE_AZURE_API_KEY=your_azure_key
VITE_AZURE_REGION=your_region
VITE_APP_VERSION=$npm_package_version
```

### Deployment Targets

- **Primary**: Vercel (automatic Git integration)
- **Alternative**: Netlify, Cloudflare Pages
- **Preview**: Branch deploys for PR review

---

## Security Considerations

| Concern | Mitigation |
|---------|------------|
| API Key Exposure | Server-side proxy for Azure API in production |
| XSS | Vue's automatic template escaping |
| CSP | Strict Content Security Policy headers |
| Dependencies | Dependabot for automated updates |

---

## Monitoring & Analytics

- **Error Tracking**: Sentry integration
- **Performance**: Web Vitals reporting
- **Usage**: Privacy-respecting analytics (optional)

---

*Last updated: 2025-01-04*
*Version: 2.0.0-alpha*
</file>

<file path="docs/DESIGN_SYSTEM.md">
# WeatherVue 2.0 - Design System

> A comprehensive design system for an award-winning weather application

## Table of Contents

1. [Design Philosophy](#design-philosophy)
2. [Color System](#color-system)
3. [Typography](#typography)
4. [Spacing & Layout](#spacing--layout)
5. [Components](#components)
6. [Effects & Treatments](#effects--treatments)
7. [Iconography](#iconography)
8. [Responsive Design](#responsive-design)

---

## Design Philosophy

### "Atmospheric Brutalism"

WeatherVue combines two contrasting design languages:

1. **Brutalist Typography**: Bold, stark, high-contrast editorial type
2. **Organic Atmosphere**: Soft, fluid, living weather effects

This tension creates visual interest and separates the app from generic weather UIs.

### Core Principles

| Principle | Description |
|-----------|-------------|
| **Data as Art** | Weather data should feel like a living canvas, not a spreadsheet |
| **Immersive** | The entire UI should reflect current weather conditions |
| **Accessible** | Beauty should never compromise usability |
| **Performant** | Smooth 60fps animations, even on mobile |
| **Delightful** | Micro-interactions that reward exploration |

---

## Color System

### Base Palette

```css
:root {
  /* Neutrals */
  --color-white: #ffffff;
  --color-black: #000000;
  --color-gray-50: #fafafa;
  --color-gray-100: #f4f4f5;
  --color-gray-200: #e4e4e7;
  --color-gray-300: #d4d4d8;
  --color-gray-400: #a1a1aa;
  --color-gray-500: #71717a;
  --color-gray-600: #52525b;
  --color-gray-700: #3f3f46;
  --color-gray-800: #27272a;
  --color-gray-900: #18181b;
  --color-gray-950: #09090b;
  
  /* Primary Accent */
  --color-accent: #dc2626;
  --color-accent-light: #ef4444;
  --color-accent-dark: #b91c1c;
}
```

### Semantic Colors

```css
:root {
  /* Light Theme */
  --bg-body: var(--color-white);
  --bg-card: var(--color-gray-100);
  --bg-card-hover: var(--color-gray-200);
  --bg-drawer: var(--color-gray-50);
  --bg-glass: rgba(255, 255, 255, 0.7);
  
  --text-primary: var(--color-black);
  --text-secondary: var(--color-gray-600);
  --text-muted: var(--color-gray-500);
  --text-inverse: var(--color-white);
  
  --border-default: var(--color-gray-200);
  --border-strong: var(--color-gray-400);
  
  --accent: var(--color-accent);
}

[data-theme="dark"] {
  --bg-body: var(--color-black);
  --bg-card: var(--color-gray-900);
  --bg-card-hover: var(--color-gray-800);
  --bg-drawer: var(--color-gray-950);
  --bg-glass: rgba(0, 0, 0, 0.7);
  
  --text-primary: var(--color-white);
  --text-secondary: var(--color-gray-400);
  --text-muted: var(--color-gray-500);
  --text-inverse: var(--color-black);
  
  --border-default: var(--color-gray-800);
  --border-strong: var(--color-gray-600);
}

[data-theme="terminal"] {
  --bg-body: #0a0a0a;
  --bg-card: #0f0f0f;
  --bg-card-hover: #1a1a1a;
  --bg-drawer: #050505;
  --bg-glass: rgba(0, 255, 0, 0.1);
  
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --text-muted: #009900;
  --text-inverse: #000000;
  
  --border-default: #003300;
  --border-strong: #00ff00;
  
  --accent: #00ff00;
  
  /* Terminal-specific */
  --font-family-override: 'JetBrains Mono', monospace;
  --border-style: dashed;
}
```

### Weather-Reactive Colors

The entire UI color palette shifts based on current weather conditions:

```css
/* Clear Sky */
:root[data-weather="clear"][data-time="day"] {
  --sky-start: #87CEEB;
  --sky-end: #1E90FF;
  --atmosphere: rgba(255, 215, 0, 0.1);
  --sun-glow: rgba(255, 200, 50, 0.3);
}

:root[data-weather="clear"][data-time="night"] {
  --sky-start: #0f0f23;
  --sky-end: #1a1a2e;
  --atmosphere: rgba(100, 100, 200, 0.1);
  --moon-glow: rgba(200, 200, 255, 0.2);
}

/* Cloudy */
:root[data-weather="cloudy"] {
  --sky-start: #94a3b8;
  --sky-end: #64748b;
  --atmosphere: rgba(150, 150, 150, 0.2);
}

/* Rainy */
:root[data-weather="rain"] {
  --sky-start: #4a5568;
  --sky-end: #2d3748;
  --atmosphere: rgba(100, 150, 200, 0.2);
  --rain-color: rgba(150, 200, 255, 0.6);
}

/* Storm */
:root[data-weather="storm"] {
  --sky-start: #1a202c;
  --sky-end: #0d1117;
  --atmosphere: rgba(80, 50, 120, 0.3);
  --lightning-color: rgba(255, 255, 200, 0.9);
}

/* Snow */
:root[data-weather="snow"] {
  --sky-start: #e2e8f0;
  --sky-end: #cbd5e0;
  --atmosphere: rgba(220, 230, 240, 0.3);
  --snow-color: rgba(255, 255, 255, 0.8);
}

/* Fog */
:root[data-weather="fog"] {
  --sky-start: #d1d5db;
  --sky-end: #9ca3af;
  --atmosphere: rgba(180, 180, 180, 0.5);
  --fog-density: 0.7;
}
```

### Temperature Gradient

For temperature visualizations:

```css
:root {
  /* Freezing to Hot: -20°C to 40°C */
  --temp-freezing: #60a5fa;   /* -20°C and below */
  --temp-cold: #93c5fd;       /* -10°C */
  --temp-cool: #bfdbfe;       /* 0°C */
  --temp-mild: #fef3c7;       /* 10°C */
  --temp-warm: #fcd34d;       /* 20°C */
  --temp-hot: #f97316;        /* 30°C */
  --temp-extreme: #dc2626;    /* 40°C and above */
}
```

---

## Typography

### Font Stack

```css
:root {
  /* Display/Headlines - Playfair Display */
  --font-display: 'Playfair Display', Georgia, 'Times New Roman', serif;
  
  /* Body/UI - Inter Variable */
  --font-body: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  
  /* Monospace - JetBrains Mono */
  --font-mono: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
}
```

### Type Scale

```css
:root {
  /* Base: 16px */
  --text-xs: 0.75rem;      /* 12px */
  --text-sm: 0.875rem;     /* 14px */
  --text-base: 1rem;       /* 16px */
  --text-lg: 1.125rem;     /* 18px */
  --text-xl: 1.25rem;      /* 20px */
  --text-2xl: 1.5rem;      /* 24px */
  --text-3xl: 1.875rem;    /* 30px */
  --text-4xl: 2.25rem;     /* 36px */
  --text-5xl: 3rem;        /* 48px */
  --text-6xl: 3.75rem;     /* 60px */
  --text-7xl: 4.5rem;      /* 72px */
  --text-8xl: 6rem;        /* 96px */
  --text-9xl: 8rem;        /* 128px */
  
  /* Fluid display sizes */
  --text-hero: clamp(3rem, 10vw, 8rem);
  --text-display: clamp(2rem, 6vw, 4rem);
}
```

### Font Weights

```css
:root {
  --font-thin: 100;
  --font-light: 300;
  --font-normal: 400;
  --font-medium: 500;
  --font-semibold: 600;
  --font-bold: 700;
  --font-extrabold: 800;
  --font-black: 900;
}
```

### Letter Spacing

```css
:root {
  --tracking-tighter: -0.05em;
  --tracking-tight: -0.025em;
  --tracking-normal: 0;
  --tracking-wide: 0.025em;
  --tracking-wider: 0.05em;
  --tracking-widest: 0.1em;
  --tracking-mega: 0.2em;    /* For labels */
  --tracking-ultra: 0.3em;   /* For tiny caps */
}
```

### Typography Styles

| Element | Font | Size | Weight | Tracking | Transform |
|---------|------|------|--------|----------|-----------|
| Hero Temperature | Display | hero | 400 | tight | - |
| City Name | Display | display | 700 | tight | - |
| Card Value | Display | 4xl | 400 | normal | - |
| Section Label | Body | xs | 800 | ultra | uppercase |
| Card Label | Body | xs | 700 | mega | uppercase |
| Body Text | Body | base | 400 | normal | - |
| Button | Body | sm | 700 | widest | uppercase |
| Caption | Body | xs | 500 | wide | - |

### Variable Font Animations

For wind-reactive text "shivering":

```css
.text-weather-reactive {
  font-variation-settings: 'wght' var(--dynamic-weight, 400);
  transition: font-variation-settings 0.1s ease;
}

/* When windy, weight oscillates */
@keyframes text-shiver {
  0%, 100% { font-variation-settings: 'wght' 400; }
  25% { font-variation-settings: 'wght' 380; }
  75% { font-variation-settings: 'wght' 420; }
}

.windy .text-weather-reactive {
  animation: text-shiver 0.3s ease-in-out infinite;
}
```

---

## Spacing & Layout

### Spacing Scale

```css
:root {
  --space-px: 1px;
  --space-0: 0;
  --space-0.5: 0.125rem;   /* 2px */
  --space-1: 0.25rem;      /* 4px */
  --space-1.5: 0.375rem;   /* 6px */
  --space-2: 0.5rem;       /* 8px */
  --space-2.5: 0.625rem;   /* 10px */
  --space-3: 0.75rem;      /* 12px */
  --space-3.5: 0.875rem;   /* 14px */
  --space-4: 1rem;         /* 16px */
  --space-5: 1.25rem;      /* 20px */
  --space-6: 1.5rem;       /* 24px */
  --space-7: 1.75rem;      /* 28px */
  --space-8: 2rem;         /* 32px */
  --space-9: 2.25rem;      /* 36px */
  --space-10: 2.5rem;      /* 40px */
  --space-11: 2.75rem;     /* 44px */
  --space-12: 3rem;        /* 48px */
  --space-14: 3.5rem;      /* 56px */
  --space-16: 4rem;        /* 64px */
  --space-20: 5rem;        /* 80px */
  --space-24: 6rem;        /* 96px */
  --space-28: 7rem;        /* 112px */
  --space-32: 8rem;        /* 128px */
}
```

### Layout Grid

```css
:root {
  /* Container widths */
  --container-sm: 640px;
  --container-md: 768px;
  --container-lg: 1024px;
  --container-xl: 1280px;
  --container-2xl: 1536px;
  
  /* Content width */
  --content-max: 1400px;
  
  /* Grid */
  --grid-cols-mobile: 4;
  --grid-cols-tablet: 8;
  --grid-cols-desktop: 12;
  --grid-gap: var(--space-6);
}
```

### Bento Grid

Weather data displayed in a "bento box" layout:

```
Desktop (12 cols):
┌─────────────────┬─────────┬─────────┐
│                 │         │         │
│   Temperature   │  Wind   │  UV     │
│   (4 cols)      │ (2 cols)│(2 cols) │
│                 │         │         │
├─────────┬───────┼─────────┴─────────┤
│         │       │                   │
│ Humidity│Precip │   Temperature     │
│ (2 cols)│(2 cols)│   Graph (4 cols) │
│         │       │                   │
├─────────┴───────┼─────────┬─────────┤
│                 │         │         │
│  Sunrise/Sunset │ Pressure│ Clouds  │
│   (4 cols)      │ (2 cols)│(2 cols) │
│                 │         │         │
└─────────────────┴─────────┴─────────┘

Mobile (4 cols):
┌───────────────────┐
│   Temperature     │
│   (4 cols)        │
├─────────┬─────────┤
│  Wind   │   UV    │
│ (2 cols)│(2 cols) │
├─────────┴─────────┤
│  Temperature      │
│  Graph (4 cols)   │
├─────────┬─────────┤
│ Humidity│ Precip  │
└─────────┴─────────┘
```

---

## Components

### Button Variants

#### Primary Button
```css
.btn-primary {
  background: var(--text-primary);
  color: var(--bg-body);
  padding: var(--space-4) var(--space-8);
  font-size: var(--text-sm);
  font-weight: var(--font-bold);
  text-transform: uppercase;
  letter-spacing: var(--tracking-widest);
  transition: all 0.3s ease;
}

.btn-primary:hover {
  background: var(--accent);
  color: white;
}
```

#### Ghost Button
```css
.btn-ghost {
  background: transparent;
  color: var(--text-primary);
  border: 1px solid var(--border-default);
  /* ... same padding/text styles */
}

.btn-ghost:hover {
  border-color: var(--text-primary);
}
```

#### Magnetic Button (Interactive)
Buttons that "attract" to cursor before click:
- Cursor within 100px: button starts moving toward cursor
- Max displacement: 15px
- Elastic snap-back on mouse leave

### Card Variants

#### Glassmorphic Card
```css
.card-glass {
  background: var(--bg-glass);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: var(--space-4);
  box-shadow: 
    0 4px 6px rgba(0, 0, 0, 0.1),
    0 10px 20px rgba(0, 0, 0, 0.05);
}
```

#### Weather Card
```css
.card-weather {
  background: var(--bg-card);
  border: 1px solid var(--border-default);
  padding: var(--space-8);
  min-height: 220px;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
}

.card-weather:hover {
  transform: translateY(-5px);
  border-color: var(--accent);
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
}

/* Watermark icon */
.card-weather .watermark {
  position: absolute;
  bottom: -20px;
  right: -10px;
  font-size: 140px;
  opacity: 0.05;
  transition: all 0.5s ease;
}

.card-weather:hover .watermark {
  color: var(--accent);
  opacity: 0.1;
  transform: scale(1.1) rotate(-10deg);
}
```

### Input Components

#### Search Input
```css
.input-search {
  background: transparent;
  border: none;
  border-bottom: 2px solid var(--border-default);
  padding: var(--space-4) 0;
  font-family: var(--font-display);
  font-size: var(--text-3xl);
  font-weight: var(--font-bold);
  color: var(--text-primary);
  transition: border-color 0.3s ease;
}

.input-search:focus {
  outline: none;
  border-color: var(--accent);
}

.input-search::placeholder {
  color: var(--text-muted);
}
```

#### Checkbox Ticket
```css
.checkbox-ticket {
  display: inline-flex;
  align-items: center;
  padding: var(--space-3) var(--space-4);
  border: 1px solid var(--border-default);
  font-size: var(--text-xs);
  font-weight: var(--font-bold);
  text-transform: uppercase;
  letter-spacing: var(--tracking-wider);
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
}

.checkbox-ticket:hover {
  border-color: var(--text-primary);
  color: var(--text-primary);
}

.checkbox-ticket.active {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
  transform: translateY(-1px);
}

/* Hidden but accessible checkbox */
.checkbox-ticket input {
  position: absolute;
  opacity: 0;
  width: 1px;
  height: 1px;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
}
```

---

## Effects & Treatments

### Glassmorphism

```css
.glass {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid rgba(255, 255, 255, 0.15);
}

[data-theme="dark"] .glass {
  background: rgba(0, 0, 0, 0.3);
  border-color: rgba(255, 255, 255, 0.1);
}
```

### Text Outline

```css
.text-outline {
  -webkit-text-stroke: 2px var(--text-secondary);
  color: transparent;
}

[data-theme="dark"] .text-outline {
  -webkit-text-stroke-color: rgba(255, 255, 255, 0.2);
}
```

### Parallax Depth

Cards have 3 depth layers that move at different speeds:

| Layer | Speed | Contains |
|-------|-------|----------|
| Background | 0.5x | Watermark icon |
| Content | 1x | Labels, values |
| Accent | 1.5x | Icon overlays |

### Glow Effects

```css
.glow-accent {
  box-shadow: 0 0 20px rgba(220, 38, 38, 0.3);
}

.glow-sun {
  box-shadow: 0 0 60px rgba(255, 200, 50, 0.4);
}

.glow-moon {
  box-shadow: 0 0 40px rgba(200, 200, 255, 0.3);
}
```

### Noise Texture

Subtle film grain overlay for depth:

```css
.noise::before {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
  opacity: 0.03;
  pointer-events: none;
}
```

---

## Iconography

### Icon System

Using **Lucide Vue** for consistent, tree-shakeable icons.

### Weather Icons Mapping

| Condition | Icon | Color |
|-----------|------|-------|
| Clear Day | `Sun` | --temp-warm |
| Clear Night | `Moon` | --text-secondary |
| Cloudy | `Cloud` | --text-secondary |
| Partly Cloudy | `CloudSun` | --text-secondary |
| Rain | `CloudRain` | --rain-color |
| Heavy Rain | `CloudRainWind` | --rain-color |
| Storm | `CloudLightning` | --lightning-color |
| Snow | `Snowflake` | --snow-color |
| Fog | `CloudFog` | --text-muted |
| Wind | `Wind` | --text-secondary |

### Icon Sizes

```css
:root {
  --icon-xs: 12px;
  --icon-sm: 16px;
  --icon-md: 24px;
  --icon-lg: 32px;
  --icon-xl: 48px;
  --icon-2xl: 64px;
  --icon-hero: 128px;
}
```

### Watermark Icons

Large, faded icons used as card backgrounds:
- Size: 140px
- Opacity: 5% (light), 10% (dark)
- Position: bottom-right, offset outside card bounds

---

## Responsive Design

### Breakpoints

```css
:root {
  --bp-sm: 640px;
  --bp-md: 768px;
  --bp-lg: 1024px;
  --bp-xl: 1280px;
  --bp-2xl: 1536px;
}
```

### Tailwind Config

```javascript
// tailwind.config.js
module.exports = {
  theme: {
    screens: {
      'sm': '640px',
      'md': '768px',
      'lg': '1024px',
      'xl': '1280px',
      '2xl': '1536px',
    },
  },
}
```

### Mobile-First Approach

All styles written mobile-first, then enhanced for larger screens:

```css
/* Mobile (default) */
.hero-temp {
  font-size: var(--text-6xl);
}

/* Tablet and up */
@media (min-width: 768px) {
  .hero-temp {
    font-size: var(--text-8xl);
  }
}

/* Desktop and up */
@media (min-width: 1024px) {
  .hero-temp {
    font-size: var(--text-9xl);
  }
}
```

### Touch Targets

All interactive elements have minimum 44x44px touch targets on mobile:

```css
@media (max-width: 768px) {
  .btn, .checkbox-ticket, .icon-btn {
    min-height: 44px;
    min-width: 44px;
  }
}
```

### Safe Areas

Account for device notches and home indicators:

```css
.bottom-nav {
  padding-bottom: env(safe-area-inset-bottom);
}

.header {
  padding-top: env(safe-area-inset-top);
}
```

---

## Z-Index Scale

```css
:root {
  --z-below: -1;
  --z-base: 0;
  --z-above: 1;
  --z-header: 10;
  --z-dropdown: 20;
  --z-drawer: 30;
  --z-modal: 40;
  --z-toast: 50;
  --z-splash: 100;
}
```

---

## Shadow System

```css
:root {
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.15);
  --shadow-2xl: 0 25px 50px rgba(0, 0, 0, 0.25);
  --shadow-inner: inset 0 2px 4px rgba(0, 0, 0, 0.05);
  
  /* Colored shadows for glow effects */
  --shadow-accent: 0 10px 40px rgba(220, 38, 38, 0.3);
}
```

---

## Border Radius

```css
:root {
  --radius-none: 0;
  --radius-sm: 0.125rem;   /* 2px */
  --radius-md: 0.375rem;   /* 6px */
  --radius-lg: 0.5rem;     /* 8px */
  --radius-xl: 0.75rem;    /* 12px */
  --radius-2xl: 1rem;      /* 16px */
  --radius-3xl: 1.5rem;    /* 24px */
  --radius-full: 9999px;
}
```

---

*Design System Version: 2.0.0*
*Last Updated: 2025-01-04*
</file>

<file path="docs/FEATURES.md">
# WeatherVue 2.0 - Feature Specifications

> Detailed specifications for all features in the award-winning redesign

## Table of Contents

1. [Hero Features](#hero-features)
2. [Core Weather Features](#core-weather-features)
3. [Data Visualizations](#data-visualizations)
4. [Interactive Elements](#interactive-elements)
5. [Search & Location](#search--location)
6. [Settings & Preferences](#settings--preferences)
7. [Accessibility Features](#accessibility-features)
8. [Progressive Web App](#progressive-web-app)

---

## Hero Features

### 1. Time-Scrub Interface

**Priority**: ⭐⭐⭐ Critical (Primary Differentiator)

**Description**: A draggable timeline that allows users to scrub through the next 24-48 hours, with the entire UI morphing in real-time to reflect the weather at that time.

**User Story**: As a user, I want to drag a timeline to see how the weather will change throughout the day, so I can plan my activities accordingly.

#### Specifications

| Aspect | Specification |
|--------|---------------|
| Timeline Range | Next 48 hours from current time |
| Granularity | 15-minute interpolation between hourly data points |
| Position | Fixed at bottom of viewport |
| Height | 80px (mobile), 100px (desktop) |
| Interaction | Drag, tap, keyboard arrows |

#### Visual Elements

```
┌────────────────────────────────────────────────────────────┐
│  NOW    6AM    9AM    12PM   3PM    6PM    9PM   12AM     │
│   ●──────────────●───────────────────────────────────────  │
│   ↑                                                        │
│   Current position indicator (draggable)                   │
│                                                            │
│  Temperature curve preview (mini sparkline)                │
│  ░░░░░█████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░  │
└────────────────────────────────────────────────────────────┘
```

#### Reactive Elements

When timeline position changes, these elements update:

| Element | Behavior |
|---------|----------|
| Hero Temperature | Animated count to new value |
| Weather Condition | Crossfade to new icon/text |
| Sky Color | Smooth gradient transition |
| WebGL Background | Particle intensity/type changes |
| Sun/Moon Position | Arc position updates |
| Graph Marker | Moves along temperature curve |

#### Technical Requirements

```typescript
interface TimelineScrubberProps {
  hourlyData: HourlyForecast[]
  currentPosition: number // 0-1
  onPositionChange: (position: number) => void
}

// Interpolation function
function interpolateWeather(
  data: HourlyForecast[],
  position: number
): InterpolatedWeather {
  const totalHours = data.length - 1
  const exactIndex = position * totalHours
  const lowerIndex = Math.floor(exactIndex)
  const upperIndex = Math.min(lowerIndex + 1, totalHours)
  const fraction = exactIndex - lowerIndex
  
  return {
    temperature: lerp(data[lowerIndex].temp, data[upperIndex].temp, fraction),
    humidity: lerp(data[lowerIndex].humidity, data[upperIndex].humidity, fraction),
    precipitation: lerp(data[lowerIndex].precip, data[upperIndex].precip, fraction),
    // ... other interpolated values
  }
}
```

#### Accessibility

- Keyboard: Arrow keys move in 1-hour increments
- Screen reader: Announces time and conditions at each stop
- Reduced motion: Instant updates instead of animations

---

### 2. WebGL Atmospheric Background

**Priority**: ⭐⭐⭐ Critical (Visual Impact)

**Description**: A Three.js-powered canvas that renders living weather effects behind all content, reacting to current conditions and user interaction.

**User Story**: As a user, I want the app to feel immersive and alive, with visual effects that match the current weather.

#### Weather Effects

| Weather | Effect Description |
|---------|-------------------|
| **Clear Day** | Subtle floating dust particles, lens flare from sun position, warm color wash |
| **Clear Night** | Twinkling stars, subtle aurora at high latitudes, cool color wash |
| **Cloudy** | Procedural noise-based cloud layers drifting across screen |
| **Rain** | Particle rain falling at angle based on wind, splash effects on "glass" surface |
| **Heavy Rain** | Dense particles, occasional lightning flash, screen "wetness" effect |
| **Snow** | Gentle falling snowflakes with depth blur, accumulation at bottom |
| **Storm** | Dark atmosphere, lightning flashes, faster rain, camera shake on thunder |
| **Fog** | Dense noise shader, reduced visibility, muted colors |

#### Technical Architecture

```typescript
// WeatherCanvas.vue structure
interface WeatherCanvasState {
  scene: THREE.Scene
  camera: THREE.PerspectiveCamera
  renderer: THREE.WebGLRenderer
  
  // Effect systems
  particleSystem: ParticleSystem
  cloudShader: ShaderMaterial
  lightningSystem: LightningEffect
  
  // Reactive state
  weatherType: WeatherType
  windSpeed: number
  windDirection: number
  timeOfDay: number // 0-1 for day/night cycle
}

// Shader uniforms
interface FogShaderUniforms {
  uTime: { value: number }
  uMouse: { value: THREE.Vector2 }
  uDensity: { value: number }
  uColor: { value: THREE.Color }
}
```

#### Performance Targets

| Metric | Target |
|--------|--------|
| Frame Rate | 60fps on desktop, 30fps on mobile |
| GPU Memory | < 50MB |
| Draw Calls | < 10 per frame |
| Particle Count | 1000 (desktop), 300 (mobile) |

#### Fallback Strategy

```typescript
// Progressive enhancement
const supportsWebGL = (): boolean => {
  try {
    const canvas = document.createElement('canvas')
    return !!(
      window.WebGLRenderingContext &&
      (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))
    )
  } catch (e) {
    return false
  }
}

// Fallback: CSS gradient background with animated clouds
```

---

### 3. City Portal Transitions

**Priority**: ⭐⭐ High (Polish)

**Description**: When switching between cities, create a cinematic "flying through" effect rather than a simple fade.

**User Story**: As a user, I want city changes to feel like a journey, reinforcing the global nature of the weather data.

#### Transition Sequence

```
1. Current View (0ms)
   └─ All content visible

2. Zoom Into Cards (0-300ms)
   └─ Cards scale up 150%
   └─ Cards blur progressively
   └─ Content fades out

3. Abstract Particle Tunnel (300-700ms)
   └─ Particle system intensifies
   └─ Colors shift to destination weather
   └─ Motion blur effect

4. Emerge at Destination (700-1000ms)
   └─ New city name fades in
   └─ Cards materialize with stagger
   └─ Weather effects initialize

5. Full View (1000ms+)
   └─ All content visible
   └─ Normal interactivity restored
```

#### Technical Implementation

```typescript
// Using GSAP for orchestration
const transitionToCity = async (newCity: City) => {
  const tl = gsap.timeline()
  
  // Phase 1: Zoom out current content
  tl.to('.weather-card', {
    scale: 1.5,
    opacity: 0,
    filter: 'blur(20px)',
    stagger: 0.05,
    duration: 0.3,
    ease: 'power2.in'
  })
  
  // Phase 2: Particle acceleration
  tl.to(particleSystem, {
    speed: 10,
    density: 2,
    duration: 0.4
  }, '-=0.1')
  
  // Fetch new data during transition
  const weatherPromise = fetchWeather(newCity)
  
  // Phase 3: Color shift
  tl.to(':root', {
    '--sky-start': newCity.skyColors.start,
    '--sky-end': newCity.skyColors.end,
    duration: 0.4
  }, '-=0.2')
  
  // Wait for data
  await weatherPromise
  
  // Phase 4: Emerge
  tl.to(particleSystem, {
    speed: 1,
    density: 1,
    duration: 0.3
  })
  
  tl.fromTo('.weather-card', 
    { scale: 0.8, opacity: 0, y: 50 },
    { scale: 1, opacity: 1, y: 0, stagger: 0.08, duration: 0.4, ease: 'power2.out' }
  )
  
  return tl
}
```

---

## Core Weather Features

### 4. Current Weather Display

**Priority**: ⭐⭐⭐ Critical

**Description**: The main weather display showing current conditions with animated numbers and weather-reactive styling.

#### Components

| Component | Description |
|-----------|-------------|
| Hero Temperature | Massive animated number (clamp 48-128px) |
| Condition Text | Weather description with icon |
| Feels Like | Secondary temperature |
| High/Low | Daily range |
| Location | City name + country |
| Last Updated | Timestamp with refresh button |

#### Hero Temperature Specs

```typescript
interface AnimatedTemperatureProps {
  value: number
  unit: 'C' | 'F'
  duration?: number // Animation duration in ms
  weatherType: WeatherType // For text effects
}

// Animated counting effect
const AnimatedNumber = ({ value, duration = 1000 }) => {
  const [display, setDisplay] = useState(0)
  
  useEffect(() => {
    const start = display
    const startTime = performance.now()
    
    const animate = (now: number) => {
      const progress = Math.min((now - startTime) / duration, 1)
      const eased = easeOutExpo(progress)
      setDisplay(start + (value - start) * eased)
      
      if (progress < 1) requestAnimationFrame(animate)
    }
    
    requestAnimationFrame(animate)
  }, [value])
  
  return Math.round(display)
}
```

---

### 5. Hourly Forecast

**Priority**: ⭐⭐⭐ Critical

**Description**: Horizontal scrollable view of the next 24 hours.

#### Layout

```
┌─────────────────────────────────────────────────────────┐
│  ← Now   1PM   2PM   3PM   4PM   5PM   6PM   7PM   → │
│    ☀️    ☀️    ⛅    🌧️    🌧️    ⛅    ☀️    🌙    │
│   24°   25°   23°   20°   19°   21°   22°   20°      │
│   0%    0%   20%   60%   80%   40%   10%    0%       │
└─────────────────────────────────────────────────────────┘
        ↑ precipitation probability
```

#### Specifications

| Aspect | Specification |
|--------|---------------|
| Data Points | 24 hours |
| Scroll Behavior | Horizontal, snap to item |
| Current Hour | Highlighted with accent border |
| Visible Items | 6 (mobile), 8 (tablet), 12 (desktop) |
| Interaction | Scroll, swipe, tap for details |

---

### 6. Weekly Forecast

**Priority**: ⭐⭐ High

**Description**: 7-day forecast with temperature range visualization.

#### Layout

```
┌─────────────────────────────────────────────────────────┐
│  Today     ☀️    ████████████░░░░░░░░    24° / 18°    │
│  Tue       🌧️    ░░░░████████░░░░░░░░    20° / 15°    │
│  Wed       ⛅    ░░░░░░████████░░░░░░    22° / 16°    │
│  Thu       ☀️    ░░░░░░░░████████████    26° / 19°    │
│  Fri       ☀️    ░░░░░░░░░████████████   28° / 20°    │
│  Sat       🌧️    ░░░████████░░░░░░░░░    21° / 16°    │
│  Sun       ⛈️    ░░████████░░░░░░░░░░    19° / 14°    │
└─────────────────────────────────────────────────────────┘
              ↑ temperature bar relative to week's range
```

---

## Data Visualizations

### 7. Temperature Graph (D3.js)

**Priority**: ⭐⭐⭐ Critical

**Description**: Interactive 24-hour temperature curve with rich visual details.

#### Visual Features

| Feature | Description |
|---------|-------------|
| **Gradient Fill** | Area under curve filled with temperature-based gradient (blue→red) |
| **Animated Drawing** | Line draws itself on load using stroke-dasharray |
| **Interactive Hover** | Tooltip shows exact time/temperature |
| **Now Marker** | Pulsing dot on current time position |
| **Day/Night Shading** | Background areas shaded for night hours |
| **Weather Icons** | Small icons at significant weather changes |
| **Precipitation Overlay** | Bar chart overlay showing rain probability |

#### Technical Specs

```typescript
interface TemperatureGraphProps {
  hourlyData: HourlyForecast[]
  width?: number
  height?: number
  onHover?: (data: HourlyForecast | null) => void
  currentTimePosition?: number // Links to timeline scrubber
}

// D3 scales
const xScale = d3.scaleTime()
  .domain([startTime, endTime])
  .range([0, width])

const yScale = d3.scaleLinear()
  .domain([minTemp - 2, maxTemp + 2])
  .range([height, 0])

// Temperature color scale
const colorScale = d3.scaleLinear<string>()
  .domain([-20, 0, 15, 30, 40])
  .range(['#60a5fa', '#bfdbfe', '#fef3c7', '#f97316', '#dc2626'])
```

---

### 8. Wind Compass

**Priority**: ⭐⭐ High

**Description**: Animated compass showing wind direction and speed through particle flow.

#### Visual Design

```
         N
         │
    ╭────┼────╮
   ╱      ↖    ╲
  │    ●→→→→    │  ← Particles flowing in wind direction
  │   →→→→→→    │
   ╲     →→    ╱
    ╰────┼────╯
         │
         S
         
Wind: 15 km/h NE
```

#### Specifications

| Aspect | Specification |
|--------|---------------|
| Size | 200x200px (desktop), 150x150px (mobile) |
| Particle Count | 30-50 based on wind speed |
| Particle Speed | Mapped from wind speed (0-100 km/h → slow-fast) |
| Direction | Particles flow in wind direction |
| Compass Needle | Subtle oscillation animation |

---

### 9. UV Index Gauge

**Priority**: ⭐⭐ High

**Description**: Semicircular gauge showing UV index with color-coded risk levels.

#### Visual Design

```
        ╭──────────────╮
       ╱   1  3  5  7  9 11 ╲
      │  ░░░░████████████  │
      │        ↑            │
      ╰────────────────────╯
           UV Index: 7
         ⚠️ High - Wear sunscreen
```

#### Color Zones

| UV Index | Color | Label |
|----------|-------|-------|
| 0-2 | Green | Low |
| 3-5 | Yellow | Moderate |
| 6-7 | Orange | High |
| 8-10 | Red | Very High |
| 11+ | Purple | Extreme |

---

### 10. Sunrise/Sunset Arc

**Priority**: ⭐⭐ High

**Description**: Semicircular arc showing sun position throughout the day.

#### Visual Design

```
        ╭──────☀️──────╮
       ╱      ↑ Now    ╲
      │                  │
      │                  │
      ╰──────────────────╯
    🌅 6:32 AM      7:45 PM 🌇
         ← Golden hour →
```

#### Features

| Feature | Description |
|---------|-------------|
| Sun Position | Current position on arc based on time |
| Golden Hours | Highlighted zones for photographers |
| Moon Position | Shown during night hours |
| Animation | Sun moves in real-time (or with timeline) |

---

### 11. Precipitation Bar

**Priority**: ⭐⭐ Medium

**Description**: Animated bar showing rain/snow probability.

#### Visual Design

```
┌─────────────────────────────────────┐
│  💧 Precipitation: 60%              │
│  ████████████████████░░░░░░░░░░░░░  │
│  └── Animated water fill ──────┘    │
└─────────────────────────────────────┘
```

#### Features

- Animated water fill effect
- Droplet/snowflake particles inside bar at high probability
- Changes color based on type (rain blue, snow white)

---

## Interactive Elements

### 12. Magnetic Buttons

**Priority**: ⭐⭐ High

**Description**: Buttons that "attract" to the cursor, creating a satisfying pre-click interaction.

#### Behavior

```typescript
interface MagneticButtonConfig {
  attractDistance: number  // Default: 100px
  maxDisplacement: number  // Default: 15px
  returnEase: string       // Default: 'elastic.out(1, 0.3)'
  returnDuration: number   // Default: 0.5s
}

const useMagneticEffect = (
  element: Ref<HTMLElement>,
  config: MagneticButtonConfig
) => {
  const handleMouseMove = (e: MouseEvent) => {
    const rect = element.value.getBoundingClientRect()
    const centerX = rect.left + rect.width / 2
    const centerY = rect.top + rect.height / 2
    
    const distanceX = e.clientX - centerX
    const distanceY = e.clientY - centerY
    const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2)
    
    if (distance < config.attractDistance) {
      const strength = 1 - (distance / config.attractDistance)
      const moveX = distanceX * strength * 0.3
      const moveY = distanceY * strength * 0.3
      
      gsap.to(element.value, {
        x: Math.min(Math.max(moveX, -config.maxDisplacement), config.maxDisplacement),
        y: Math.min(Math.max(moveY, -config.maxDisplacement), config.maxDisplacement),
        duration: 0.3,
        ease: 'power2.out'
      })
    }
  }
  
  const handleMouseLeave = () => {
    gsap.to(element.value, {
      x: 0,
      y: 0,
      duration: config.returnDuration,
      ease: config.returnEase
    })
  }
  
  // ... event listener setup
}
```

---

### 13. Parallax Cards

**Priority**: ⭐⭐ Medium

**Description**: Weather cards with 3D depth effect on mouse movement.

#### Layer Structure

| Layer | Speed | Content |
|-------|-------|---------|
| Background | 0.5x | Watermark icon |
| Middle | 1x | Card border, background |
| Foreground | 1.5x | Text, values |

#### Implementation

```typescript
const useParallax = (element: Ref<HTMLElement>, layers: ParallaxLayer[]) => {
  const handleMouseMove = (e: MouseEvent) => {
    const rect = element.value.getBoundingClientRect()
    const centerX = rect.left + rect.width / 2
    const centerY = rect.top + rect.height / 2
    
    const rotateX = (e.clientY - centerY) / 20
    const rotateY = (centerX - e.clientX) / 20
    
    gsap.to(element.value, {
      rotateX,
      rotateY,
      transformPerspective: 1000,
      duration: 0.5,
      ease: 'power2.out'
    })
    
    // Move layers at different speeds
    layers.forEach(layer => {
      const moveX = (e.clientX - centerX) * layer.speed * 0.05
      const moveY = (e.clientY - centerY) * layer.speed * 0.05
      
      gsap.to(layer.element, { x: moveX, y: moveY, duration: 0.5 })
    })
  }
}
```

---

### 14. Variable Font Animations

**Priority**: ⭐⭐ Medium

**Description**: Typography that reacts to weather conditions.

#### Weather-Reactive Behaviors

| Condition | Animation | Property |
|-----------|-----------|----------|
| High Wind | Text "shivers" | font-weight oscillates |
| Extreme Heat | Text expands | font-stretch increases |
| Cold | Text contracts | letter-spacing tightens |
| Storm | Text jitters | subtle skewX animation |

---

## Search & Location

### 15. City Search with Autocomplete

**Priority**: ⭐⭐⭐ Critical

**Description**: Searchable city input with real-time suggestions from Open-Meteo Geocoding API.

#### Features

| Feature | Description |
|---------|-------------|
| Debounced Search | 300ms debounce to reduce API calls |
| Fuzzy Matching | Handles typos and partial matches |
| Recent Cities | Last 5 searched cities stored locally |
| Favorites | User can star cities for quick access |
| Geolocation | "Use my location" button |
| Keyboard Navigation | Arrow keys, Enter to select |

#### UI States

```
┌─────────────────────────────────────┐
│  🔍 Search city...                  │  ← Empty state
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  🔍 Par                             │  ← Typing
├─────────────────────────────────────┤
│  📍 Paris, France                   │  ← Results
│  📍 Parma, Italy                    │
│  📍 Paraná, Argentina               │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│  Recent                             │
├─────────────────────────────────────┤
│  🕐 Rome, Italy                     │
│  🕐 Paris, France                   │
│  🕐 London, UK                      │
└─────────────────────────────────────┘
```

---

### 16. Geolocation

**Priority**: ⭐⭐⭐ Critical

**Description**: Auto-detect user's location with graceful fallbacks.

#### Flow

```
1. App loads
   ├─ Check localStorage for last city
   │  └─ If found: Use cached location (fast start)
   │
   └─ If not found: Check geolocation permission
      ├─ If granted: Get coordinates → reverse geocode → use
      ├─ If denied: Use default city (Rome)
      └─ If prompt: Show "Use my location" button
```

#### Error Handling

| Error | User Message | Fallback |
|-------|--------------|----------|
| PERMISSION_DENIED | "Location access denied. Search for a city instead." | Show search |
| POSITION_UNAVAILABLE | "Couldn't determine your location." | Show search |
| TIMEOUT | "Location request timed out." | Retry button |

---

## Settings & Preferences

### 17. Settings Drawer

**Priority**: ⭐⭐ High

**Description**: Off-canvas panel for all user preferences.

#### Sections

```
┌─────────────────────────────────────┐
│  Settings                        ✕  │
├─────────────────────────────────────┤
│                                     │
│  APPEARANCE                         │
│  ┌─────┬─────┬─────┬─────────┐     │
│  │Light│Dark │System│Terminal │     │
│  └─────┴─────┴─────┴─────────┘     │
│                                     │
│  UNITS                              │
│  Temperature: ○ Celsius ● Fahrenheit│
│  Wind Speed:  ● km/h  ○ mph  ○ m/s │
│                                     │
│  ACCESSIBILITY                      │
│  [✓] Reduce motion                  │
│  [ ] High contrast mode             │
│  [ ] Sound effects                  │
│                                     │
│  AUDIO                              │
│  [ ] Ambient weather sounds         │
│  Volume: ████████░░ 80%             │
│                                     │
│  DATA                               │
│  [ ] Haptic feedback (mobile)       │
│  [ ] Sonification mode              │
│                                     │
├─────────────────────────────────────┤
│  Clear cached data    About         │
└─────────────────────────────────────┘
```

#### Mobile: Bottom Sheet

On mobile, settings open as a bottom sheet instead of side drawer:

```
┌─────────────────────────────────────┐
│                                     │
│         Main Content                │
│                                     │
├─────────────────────────────────────┤
│  ═══════════════════════════════   │ ← Drag handle
│  Settings                           │
│  ...                                │
│                                     │
└─────────────────────────────────────┘
```

---

## Accessibility Features

### 18. Terminal Theme

**Priority**: ⭐⭐ High

**Description**: High-contrast accessibility theme with a "hacker" aesthetic.

#### Specifications

```css
[data-theme="terminal"] {
  --bg-body: #0a0a0a;
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --accent: #00ff00;
  --font-family: 'JetBrains Mono', monospace;
  
  /* Override all fonts to mono */
  * { font-family: var(--font-family) !important; }
  
  /* Add scanlines effect */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      rgba(0, 0, 0, 0.1) 0px,
      rgba(0, 0, 0, 0.1) 1px,
      transparent 1px,
      transparent 2px
    );
    pointer-events: none;
  }
}
```

---

### 19. Sonification Mode

**Priority**: ⭐ Low (Nice-to-have)

**Description**: Convert weather data to audio for accessibility.

#### Audio Mappings

| Data | Audio Representation |
|------|---------------------|
| Temperature | Pitch (low = cold, high = hot) |
| Wind | White noise volume |
| Rain | Rain sound intensity |
| Thunder | Occasional thunder SFX |
| Pressure | Subtle drone pitch |

```typescript
const sonifyTemperature = (temp: number) => {
  const audioCtx = new AudioContext()
  const oscillator = audioCtx.createOscillator()
  const gainNode = audioCtx.createGain()
  
  // Map temp (-20 to 40°C) to frequency (200-800 Hz)
  const frequency = mapRange(temp, -20, 40, 200, 800)
  
  oscillator.type = 'sine'
  oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime)
  gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime)
  
  oscillator.connect(gainNode)
  gainNode.connect(audioCtx.destination)
  
  oscillator.start()
  oscillator.stop(audioCtx.currentTime + 0.5)
}
```

---

### 20. Reduced Motion Support

**Priority**: ⭐⭐⭐ Critical

**Description**: Respect user's motion preferences.

#### Implementation

```css
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
  
  .weather-canvas {
    display: none;
  }
  
  .animated-number {
    transition: none;
  }
}
```

```typescript
const useReducedMotion = () => {
  const prefersReducedMotion = ref(
    window.matchMedia('(prefers-reduced-motion: reduce)').matches
  )
  
  onMounted(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)')
    const handler = (e: MediaQueryListEvent) => {
      prefersReducedMotion.value = e.matches
    }
    mediaQuery.addEventListener('change', handler)
    onUnmounted(() => mediaQuery.removeEventListener('change', handler))
  })
  
  return prefersReducedMotion
}
```

---

## Progressive Web App

### 21. PWA Features

**Priority**: ⭐⭐ High

**Description**: Installable app with offline support.

#### Features

| Feature | Description |
|---------|-------------|
| Installable | Add to Home Screen prompt |
| Offline | Last weather data cached |
| Background Sync | Refresh when connection restored |
| Push Notifications | Severe weather alerts (with permission) |

#### Service Worker Strategy

```typescript
// Cache strategies
const strategies = {
  // API data: Network first, fallback to cache
  weather: new NetworkFirst({
    cacheName: 'weather-api',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 5 // 5 minutes
      })
    ]
  }),
  
  // Static assets: Cache first
  static: new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
      })
    ]
  })
}
```

#### Manifest

```json
{
  "name": "WeatherVue",
  "short_name": "WeatherVue",
  "description": "Award-winning weather application",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#000000",
  "theme_color": "#dc2626",
  "icons": [
    { "src": "/icons/192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/512.png", "sizes": "512x512", "type": "image/png" },
    { "src": "/icons/maskable.png", "sizes": "512x512", "type": "image/png", "purpose": "maskable" }
  ]
}
```

---

### 22. Haptic Feedback

**Priority**: ⭐ Low (Mobile enhancement)

**Description**: Vibration patterns that simulate weather on mobile.

#### Patterns

```typescript
const hapticPatterns = {
  // Interaction feedback
  tap: [10],
  success: [10, 50, 10],
  error: [50, 100, 50],
  
  // Weather simulation
  lightRain: [50, 100, 50, 100, 50],
  heavyRain: [100, 50, 100, 50, 100, 50, 100],
  thunder: [200, 100, 500],
  snow: [30, 200, 30, 200, 30],
  wind: [20, 80, 20, 80, 20, 80, 20]
}

const triggerHaptic = (pattern: keyof typeof hapticPatterns) => {
  if ('vibrate' in navigator && settingsStore.hapticsEnabled) {
    navigator.vibrate(hapticPatterns[pattern])
  }
}
```

---

*Feature Specifications Version: 2.0.0*
*Last Updated: 2025-01-04*
</file>

<file path="docs/IMPLEMENTATION_PLAN.md">
# WeatherVue 2.0 - Implementation Plan

> Phase-by-phase development roadmap with detailed task breakdowns

## Overview

| Phase | Focus | Duration | Priority |
|-------|-------|----------|----------|
| 1 | Foundation & Setup | 2-3 days | Critical |
| 2 | Core Components | 3-4 days | Critical |
| 3 | Hero Features | 3-4 days | Critical |
| 4 | Data Visualizations | 2-3 days | High |
| 5 | Polish & Effects | 2-3 days | High |
| 6 | Accessibility & PWA | 1-2 days | High |
| 7 | Testing & Launch | 1-2 days | Critical |

**Total Estimated Time**: 14-21 days

---

## Phase 1: Foundation & Setup

### 1.1 Project Initialization

- [ ] Create Vite + Vue 3 + TypeScript project
  ```bash
  npm create vite@latest weathervue-v2 -- --template vue-ts
  cd weathervue-v2
  npm install
  ```

- [ ] Install core dependencies
  ```bash
  # Vue ecosystem
  npm install vue-router@4 pinia @vueuse/core
  
  # Styling
  npm install -D tailwindcss postcss autoprefixer
  npx tailwindcss init -p
  
  # Animation & 3D
  npm install gsap three @types/three
  
  # Data visualization
  npm install d3 @types/d3
  
  # Icons
  npm install lucide-vue-next
  
  # PWA
  npm install -D vite-plugin-pwa
  ```

- [ ] Configure TypeScript (`tsconfig.json`)
  - Enable strict mode
  - Configure path aliases
  - Set up module resolution

- [ ] Configure ESLint + Prettier
  - Vue 3 specific rules
  - TypeScript rules
  - Import sorting

### 1.2 Tailwind Configuration

- [ ] Create `tailwind.config.js` with design tokens
  - Custom colors (weather palettes)
  - Typography scale
  - Spacing scale
  - Custom animations

- [ ] Create CSS files structure
  ```
  src/styles/
  ├── main.css        # Tailwind imports
  ├── variables.css   # CSS custom properties
  ├── fonts.css       # @font-face declarations
  ├── animations.css  # Keyframe definitions
  └── utilities.css   # Custom utility classes
  ```

- [ ] Self-host fonts
  - Download Playfair Display (woff2)
  - Download Inter Variable (woff2)
  - Download JetBrains Mono (woff2)
  - Configure font-display: swap

### 1.3 Project Structure

- [ ] Create folder structure as per ARCHITECTURE.md
  ```
  src/
  ├── components/
  │   ├── canvas/
  │   ├── ui/
  │   ├── weather/
  │   ├── layout/
  │   └── search/
  ├── composables/
  ├── stores/
  ├── services/
  ├── types/
  ├── utils/
  └── styles/
  ```

- [ ] Create barrel exports (index.ts) for each folder

- [ ] Set up path aliases in vite.config.ts
  ```typescript
  resolve: {
    alias: {
      '@': '/src',
      '@components': '/src/components',
      '@composables': '/src/composables',
      '@stores': '/src/stores',
      '@services': '/src/services',
      '@types': '/src/types',
      '@utils': '/src/utils'
    }
  }
  ```

### 1.4 Type Definitions

- [ ] Create `types/weather.ts`
  ```typescript
  interface CurrentWeather { ... }
  interface HourlyForecast { ... }
  interface DailyForecast { ... }
  type WeatherCode = 0 | 1 | 2 | 3 | 45 | ... // WMO codes
  type WeatherType = 'clear' | 'cloudy' | 'rain' | 'storm' | 'snow' | 'fog'
  ```

- [ ] Create `types/location.ts`
  ```typescript
  interface City { ... }
  interface Coordinates { ... }
  interface GeocodingResult { ... }
  ```

- [ ] Create `types/theme.ts`
  ```typescript
  type Theme = 'light' | 'dark' | 'system' | 'terminal'
  type TemperatureUnit = 'celsius' | 'fahrenheit'
  type SpeedUnit = 'kmh' | 'mph' | 'ms'
  ```

### 1.5 Pinia Stores

- [ ] Create `stores/weatherStore.ts`
  - State: current, hourly, daily, loading, error
  - Actions: fetchWeather, setTimelinePosition
  - Getters: interpolatedWeather, weatherType

- [ ] Create `stores/locationStore.ts`
  - State: currentCity, coordinates, searchResults, recentCities
  - Actions: setCity, searchCities, detectLocation
  - Getters: cityDisplayName

- [ ] Create `stores/settingsStore.ts`
  - State: theme, units, accessibility, audio
  - Actions: setTheme, toggleSetting
  - Persistence: localStorage integration

---

## Phase 2: Core Components

### 2.1 Base UI Components

- [ ] `MagneticButton.vue`
  - Props: variant, size, disabled
  - Magnetic cursor effect using GSAP
  - Keyboard accessible

- [ ] `GlassmorphicCard.vue`
  - Props: blur, opacity, border
  - CSS backdrop-filter
  - Fallback for unsupported browsers

- [ ] `AnimatedNumber.vue`
  - Props: value, duration, decimals
  - Eased counting animation
  - Format options (with unit suffix)

- [ ] `SkeletonLoader.vue`
  - Props: variant (text, card, graph)
  - Shimmer animation
  - Respects reduced motion

- [ ] `IconWrapper.vue`
  - Lucide icon wrapper with consistent sizing
  - Weather condition mapping

### 2.2 Layout Components

- [ ] `AppHeader.vue`
  - Logo with theme toggle (dot)
  - Settings button
  - Responsive behavior

- [ ] `SettingsDrawer.vue`
  - Off-canvas panel (right side)
  - Theme selector
  - Units selector
  - Accessibility toggles
  - Audio settings
  - Close on escape/outside click

- [ ] `BottomNav.vue` (mobile only)
  - Fixed bottom navigation
  - Cities, Refresh, Settings buttons
  - Safe area padding

- [ ] `SplashScreen.vue`
  - Animated logo reveal
  - Fade out after data loaded
  - Skip on subsequent visits

### 2.3 Composables

- [ ] `useTheme.ts`
  - Theme state management
  - System preference detection
  - CSS variable updates
  - Weather-reactive colors

- [ ] `useReducedMotion.ts`
  - Media query listener
  - Boolean ref for components

- [ ] `useMagneticEffect.ts`
  - Reusable magnetic cursor logic
  - Configuration options

- [ ] `useParallax.ts`
  - Multi-layer parallax effect
  - Mouse position tracking

### 2.4 API Services

- [ ] `services/weatherApi.ts`
  - Open-Meteo current weather
  - Open-Meteo hourly forecast (48h)
  - Open-Meteo daily forecast (7d)
  - Error handling

- [ ] `services/geocodingApi.ts`
  - City search
  - Reverse geocoding
  - Debounced requests

- [ ] `services/cache.ts`
  - SWR-like caching
  - TTL management
  - localStorage persistence

### 2.5 Utility Functions

- [ ] `utils/weatherCodes.ts`
  - WMO code descriptions
  - Weather type mapping
  - Icon mapping

- [ ] `utils/formatters.ts`
  - Temperature formatting (with unit)
  - Time formatting (locale-aware)
  - Wind direction (degrees to cardinal)

- [ ] `utils/interpolation.ts`
  - Linear interpolation (lerp)
  - Weather data interpolation
  - Color interpolation

- [ ] `utils/constants.ts`
  - Default cities
  - API endpoints
  - Animation durations

---

## Phase 3: Hero Features

### 3.1 WeatherCanvas (Three.js Background)

- [ ] Create `WeatherCanvas.vue` component
  - Three.js scene setup
  - Responsive canvas sizing
  - Performance monitoring

- [ ] Implement particle systems
  - Rain particles with splash
  - Snow particles with depth
  - Dust/pollen for clear weather

- [ ] Create fog shader
  - GLSL vertex/fragment shaders
  - Mouse interaction
  - Density based on weather

- [ ] Create sky gradient system
  - Dynamic color based on time of day
  - Weather-reactive color shifts
  - Smooth transitions

- [ ] Add lightning effect
  - Random flash timing
  - Screen flash overlay
  - Optional audio sync

- [ ] Performance optimizations
  - Reduced particles on mobile
  - Frame rate limiting
  - Visibility-based rendering

### 3.2 TimelineScrubber

- [ ] Create `TimelineScrubber.vue`
  - Horizontal draggable slider
  - Time markers (hours)
  - Current position indicator

- [ ] Add touch/mouse interaction
  - Drag to scrub
  - Tap to jump
  - Momentum scrolling

- [ ] Create mini sparkline preview
  - Temperature curve preview
  - Weather condition dots

- [ ] Integrate with weather store
  - Position → interpolated data
  - Real-time UI updates

- [ ] Add keyboard support
  - Arrow keys navigation
  - Home/End for start/end

### 3.3 City Portal Transitions

- [ ] Create `useCityTransition.ts` composable
  - GSAP timeline orchestration
  - State management during transition

- [ ] Implement transition phases
  - Phase 1: Zoom into current cards
  - Phase 2: Particle acceleration
  - Phase 3: Color shift
  - Phase 4: Emerge at destination

- [ ] Coordinate with data fetching
  - Fetch during transition
  - Handle errors gracefully

- [ ] Add loading fallback
  - Show if data takes too long
  - Graceful degradation

---

## Phase 4: Data Visualizations

### 4.1 TemperatureGraph (D3.js)

- [ ] Create `TemperatureGraph.vue`
  - SVG-based chart
  - Responsive sizing
  - 24-hour data display

- [ ] Implement visual features
  - Gradient fill under curve
  - Animated line drawing
  - Day/night shading

- [ ] Add interactive features
  - Hover tooltip
  - "Now" marker
  - Timeline sync marker

- [ ] Add precipitation overlay
  - Bar chart for rain probability
  - Blue coloring

### 4.2 WindCompass

- [ ] Create `WindCompass.vue`
  - SVG compass dial
  - Particle flow system
  - Speed-based particle velocity

- [ ] Animate compass needle
  - Subtle oscillation
  - Direction changes

### 4.3 Other Visualizations

- [ ] `UVIndexGauge.vue`
  - Semicircular gauge
  - Color-coded zones
  - Animated needle

- [ ] `SunriseSunsetArc.vue`
  - Day arc visualization
  - Current sun position
  - Golden hour markers

- [ ] `PrecipitationBar.vue`
  - Animated fill bar
  - Water/snow effect
  - Percentage display

### 4.4 Weather Cards

- [ ] Create `WeatherCard.vue`
  - Parallax depth effect
  - Watermark icon
  - Hover animations

- [ ] Create card variants
  - Temperature (hero size)
  - Standard metric
  - Compact (hourly)

---

## Phase 5: Polish & Effects

### 5.1 Micro-interactions

- [ ] Implement magnetic buttons globally
  - Header buttons
  - Settings drawer buttons
  - FAB buttons

- [ ] Add parallax to all cards
  - Consistent depth settings
  - Performance optimization

- [ ] Variable font animations
  - Wind-reactive text shiver
  - Temperature-reactive weight

- [ ] Scroll-triggered animations
  - Intersection Observer setup
  - Staggered reveals
  - Graph drawing on scroll

### 5.2 Search & Location

- [ ] Create `CitySearch.vue`
  - Search input with icon
  - Debounced API calls
  - Keyboard navigation

- [ ] Create `CitySearchResults.vue`
  - Result list
  - Highlight matching text
  - Loading state

- [ ] Create `RecentCities.vue`
  - Recent/favorite cities list
  - Quick selection
  - Clear history option

- [ ] Implement geolocation
  - Permission handling
  - Error states
  - "Use my location" button

### 5.3 7-Day Forecast

- [ ] Create `WeeklyForecast.vue`
  - 7-day list/grid
  - Temperature range bars
  - Weather icons
  - Tap for details

### 5.4 Hourly Forecast

- [ ] Create `HourlyForecast.vue`
  - Horizontal scroll
  - Snap to items
  - Current hour highlight
  - 24 hours displayed

### 5.5 Translation Feature

- [ ] Port Azure Translator integration
  - Weather summary building
  - Language selection
  - Result display

---

## Phase 6: Accessibility & PWA

### 6.1 Accessibility

- [ ] ARIA labels and roles
  - All interactive elements
  - Live regions for updates
  - Landmarks

- [ ] Keyboard navigation
  - Focus management
  - Skip links
  - Trap focus in modals

- [ ] Screen reader testing
  - VoiceOver (macOS/iOS)
  - NVDA (Windows)
  - Content announcements

- [ ] Terminal theme
  - High contrast colors
  - Monospace font
  - Scanlines effect

- [ ] Reduced motion
  - Query detection
  - Animation disabling
  - Instant transitions

### 6.2 Sonification (Optional)

- [ ] Audio context setup
- [ ] Temperature to pitch mapping
- [ ] Ambient weather sounds
- [ ] Volume controls

### 6.3 PWA Setup

- [ ] Configure vite-plugin-pwa
  - Manifest settings
  - Icon generation
  - Service worker

- [ ] Implement caching strategies
  - Weather API: Network-first
  - Assets: Cache-first
  - Offline fallback page

- [ ] Add install prompt
  - beforeinstallprompt event
  - Custom install UI
  - Installation tracking

- [ ] Offline experience
  - Cached weather display
  - "Last updated" indicator
  - Refresh when online

### 6.4 Haptic Feedback

- [ ] Create `useHaptics.ts`
  - Vibration API wrapper
  - Pattern definitions
  - Settings integration

- [ ] Trigger haptics
  - Button presses
  - Weather simulation
  - Error states

---

## Phase 7: Testing & Launch

### 7.1 Testing

- [ ] Component testing (Vitest)
  - Unit tests for utilities
  - Component render tests
  - Store tests

- [ ] E2E testing (Playwright)
  - Critical user flows
  - Responsive behavior
  - Accessibility checks

- [ ] Performance testing
  - Lighthouse audit
  - Bundle size analysis
  - Core Web Vitals

- [ ] Cross-browser testing
  - Chrome, Firefox, Safari, Edge
  - Mobile browsers
  - PWA installation

### 7.2 Optimization

- [ ] Bundle optimization
  - Code splitting
  - Tree shaking verification
  - Chunk analysis

- [ ] Image optimization
  - BlurHash generation
  - Lazy loading
  - Responsive images

- [ ] Font optimization
  - Subset fonts
  - Preload critical fonts
  - Font-display: swap

### 7.3 Documentation

- [ ] Update README.md
  - Features list
  - Screenshots/GIFs
  - Installation instructions
  - Tech stack badges

- [ ] Code comments
  - Complex logic explanations
  - TODO items for future

- [ ] Storybook (optional)
  - Component documentation
  - Interactive examples

### 7.4 Deployment

- [ ] Vercel setup
  - Project connection
  - Environment variables
  - Build settings

- [ ] Domain/DNS (optional)
  - Custom domain setup
  - SSL verification

- [ ] Analytics (optional)
  - Privacy-respecting tracking
  - Error monitoring

### 7.5 Launch Checklist

- [ ] All features working
- [ ] Responsive on all devices
- [ ] Accessibility audit passed
- [ ] Performance targets met
- [ ] PWA installable
- [ ] No console errors
- [ ] Meta tags / OG images
- [ ] Favicon set
- [ ] 404 page
- [ ] README complete

---

## Success Metrics

| Metric | Target |
|--------|--------|
| Lighthouse Performance | 95+ |
| Lighthouse Accessibility | 100 |
| Lighthouse Best Practices | 100 |
| Lighthouse SEO | 100 |
| First Contentful Paint | < 1.5s |
| Largest Contentful Paint | < 2.5s |
| Cumulative Layout Shift | < 0.1 |
| Total Bundle Size (gzipped) | < 200KB |
| Time to Interactive | < 3.5s |

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Three.js bundle size | Dynamic import, tree-shake |
| D3.js complexity | Start simple, add features incrementally |
| Mobile performance | Test early, reduce effects |
| API rate limits | Aggressive caching, debouncing |
| Browser compatibility | Feature detection, graceful degradation |
| Scope creep | Prioritize core features, defer polish |

---

## Post-Launch Improvements

Future enhancements after initial launch:

1. Weather alerts & notifications
2. Air quality index
3. Pollen count
4. Multiple saved locations
5. Weather widgets (embeddable)
6. Share weather cards (social)
7. Historical weather data
8. Weather comparison between cities
9. Rain radar map integration
10. Astronomy data (moon phases, meteor showers)

---

*Implementation Plan Version: 2.0.0*
*Last Updated: 2025-01-04*
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
 import vue from 'eslint-plugin-vue'
 import tsParser from '@typescript-eslint/parser'
 
 export default [
   js.configs.recommended,
   ...vue.configs['flat/recommended'],
   {
     files: ['**/*.{js,ts,vue}'],
     languageOptions: {
       ecmaVersion: 'latest',
       sourceType: 'module',
       parser: tsParser,
       parserOptions: {
         extraFileExtensions: ['.vue']
       },
       globals: {
         window: 'readonly',
         document: 'readonly',
         navigator: 'readonly',
         console: 'readonly',
         setTimeout: 'readonly',
         clearTimeout: 'readonly',
         setInterval: 'readonly',
         clearInterval: 'readonly',
         fetch: 'readonly',
         URLSearchParams: 'readonly',
         AudioContext: 'readonly',
         OscillatorNode: 'readonly',
         GainNode: 'readonly',
         requestAnimationFrame: 'readonly',
         cancelAnimationFrame: 'readonly',
         HTMLElement: 'readonly',
         MouseEvent: 'readonly',
         KeyboardEvent: 'readonly',
         Event: 'readonly',
         ResizeObserver: 'readonly'
       }
     },
     rules: {
       'vue/multi-word-component-names': 'off',
       'vue/require-default-prop': 'off',
       'vue/no-v-html': 'off',
       '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
       'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
       'no-console': ['warn', { allow: ['warn', 'error'] }]
     }
   },
   {
     ignores: ['dist/**', 'node_modules/**', '*.config.js', '*.config.ts']
   }
 ]
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="src/components/canvas/index.ts">
export { default as WeatherCanvas } from './WeatherCanvas.vue'
</file>

<file path="src/components/canvas/shaders/fog.frag">
uniform float time;
uniform vec3 fogColor;
varying vec2 vUv;

float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

float noise(vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

void main() {
    float n = noise(vUv * 3.0 + time * 0.1);
    float alpha = smoothstep(0.3, 0.7, n) * 0.3;
    gl_FragColor = vec4(fogColor, alpha);
}
</file>

<file path="src/components/canvas/shaders/fog.vert">
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</file>

<file path="src/components/canvas/shaders/rain.frag">
uniform vec3 color;
varying float vAlpha;

void main() {
    // Circular particle
    vec2 coord = gl_PointCoord - vec2(0.5);
    if(length(coord) > 0.5) discard;
    
    gl_FragColor = vec4(color, vAlpha * 0.6);
}
</file>

<file path="src/components/canvas/shaders/rain.vert">
uniform float time;
uniform float rangeY;

attribute float speed;
attribute vec3 velocity;

varying float vAlpha;

void main() {
    vAlpha = 1.0;
    
    vec3 pos = position;
    
    // Animate position
    pos.y -= time * speed;
    pos.x += time * velocity.x;
    pos.z += time * velocity.z;
    
    // Loop
    float top = rangeY / 2.0;
    float bottom = -rangeY / 2.0;
    
    if (pos.y < bottom) {
        pos.y = top - mod(bottom - pos.y, rangeY);
    }
    
    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_PointSize = 2.0 * (300.0 / -mvPosition.z); // Scale by distance
    gl_Position = projectionMatrix * mvPosition;
}
</file>

<file path="src/components/canvas/WeatherCanvas.vue">
<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch, computed } from 'vue'
import { useWeatherStore, useSettingsStore } from '@/stores'
import type { WeatherType } from '@/types'

// Three.js will be dynamically imported to enable code splitting
const canvasRef = ref<HTMLCanvasElement | null>(null)
const isLoaded = ref(false)

const weatherStore = useWeatherStore()
const settingsStore = useSettingsStore()

let animationId: number | null = null
let scene: any = null
let camera: any = null
let renderer: any = null
let particles: any = null
let THREE: any = null

const weatherType = computed<WeatherType>(() => weatherStore.weatherType)

// Particle configurations for different weather types
const particleConfigs: Record<WeatherType, { count: number; speed: number; color: string; size: number }> = {
  clear: { count: 50, speed: 0.5, color: '#ffd700', size: 0.02 },
  cloudy: { count: 100, speed: 0.3, color: '#9ca3af', size: 0.03 },
  rain: { count: 500, speed: 3, color: '#60a5fa', size: 0.01 },
  storm: { count: 800, speed: 5, color: '#4b5563', size: 0.01 },
  snow: { count: 300, speed: 0.5, color: '#ffffff', size: 0.02 },
  fog: { count: 200, speed: 0.1, color: '#d1d5db', size: 0.05 }
}

const initThree = async () => {
  if (!canvasRef.value) return
  
  // Dynamic import of Three.js
  THREE = await import('three')
  
  const width = window.innerWidth
  const height = window.innerHeight
  
  // Scene
  scene = new THREE.Scene()
  
  // Camera
  camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)
  camera.position.z = 5
  
  // Renderer
  renderer = new THREE.WebGLRenderer({
    canvas: canvasRef.value,
    alpha: true,
    antialias: true
  })
  renderer.setSize(width, height)
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
  
  // Create initial particles
  createParticles(weatherType.value)
  
  isLoaded.value = true
  animate()
}

const createParticles = (type: WeatherType) => {
  if (!THREE || !scene) return
  
  // Remove existing particles
  if (particles) {
    scene.remove(particles)
    particles.geometry.dispose()
    particles.material.dispose()
  }
  
  const config = particleConfigs[type]
  const geometry = new THREE.BufferGeometry()
  const positions = new Float32Array(config.count * 3)
  const velocities = new Float32Array(config.count)
  
  for (let i = 0; i < config.count; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 20
    positions[i * 3 + 1] = (Math.random() - 0.5) * 20
    positions[i * 3 + 2] = (Math.random() - 0.5) * 10
    velocities[i] = 0.5 + Math.random() * 0.5
  }
  
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  geometry.userData.velocities = velocities
  geometry.userData.config = config
  
  const material = new THREE.PointsMaterial({
    color: new THREE.Color(config.color),
    size: config.size,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending
  })
  
  particles = new THREE.Points(geometry, material)
  scene.add(particles)
}

const animate = () => {
  if (!renderer || !scene || !camera || !particles) return
  
  animationId = requestAnimationFrame(animate)
  
  const positions = particles.geometry.attributes.position.array
  const velocities = particles.geometry.userData.velocities
  const config = particles.geometry.userData.config
  
  // Update particle positions based on weather type
  for (let i = 0; i < positions.length / 3; i++) {
    const weatherT = weatherType.value
    
    if (weatherT === 'rain' || weatherT === 'storm') {
      // Rain falls down
      positions[i * 3 + 1] -= velocities[i] * config.speed * 0.05
      
      // Reset when below view
      if (positions[i * 3 + 1] < -10) {
        positions[i * 3 + 1] = 10
        positions[i * 3] = (Math.random() - 0.5) * 20
      }
    } else if (weatherT === 'snow') {
      // Snow drifts gently
      positions[i * 3 + 1] -= velocities[i] * config.speed * 0.02
      positions[i * 3] += Math.sin(Date.now() * 0.001 + i) * 0.01
      
      if (positions[i * 3 + 1] < -10) {
        positions[i * 3 + 1] = 10
        positions[i * 3] = (Math.random() - 0.5) * 20
      }
    } else {
      // Gentle floating for other types
      positions[i * 3] += Math.sin(Date.now() * 0.0005 + i * 0.1) * 0.002
      positions[i * 3 + 1] += Math.cos(Date.now() * 0.0003 + i * 0.1) * 0.002
    }
  }
  
  particles.geometry.attributes.position.needsUpdate = true
  
  // Slow rotation
  particles.rotation.y += 0.0002
  
  renderer.render(scene, camera)
}

const handleResize = () => {
  if (!camera || !renderer) return
  
  const width = window.innerWidth
  const height = window.innerHeight
  
  camera.aspect = width / height
  camera.updateProjectionMatrix()
  renderer.setSize(width, height)
}

// Watch for weather type changes
watch(weatherType, (newType) => {
  if (isLoaded.value) {
    createParticles(newType)
  }
})

onMounted(() => {
  if (!settingsStore.prefersReducedMotion) {
    initThree()
    window.addEventListener('resize', handleResize)
  }
})

onUnmounted(() => {
  if (animationId) {
    cancelAnimationFrame(animationId)
  }
  
  if (renderer) {
    renderer.dispose()
  }
  
  window.removeEventListener('resize', handleResize)
})
</script>

<template>
  <div class="weather-canvas-container">
    <!-- Gradient background -->
    <div 
      class="gradient-bg absolute inset-0 transition-colors duration-1000"
      :style="{
        background: `linear-gradient(180deg, var(--sky-start), var(--sky-end))`
      }"
    />
    
    <!-- Three.js canvas -->
    <canvas 
      ref="canvasRef"
      class="absolute inset-0"
      :class="{ 'opacity-0': !isLoaded }"
    />
    
    <!-- Noise texture overlay -->
    <div class="noise-overlay absolute inset-0 pointer-events-none" />
  </div>
</template>

<style scoped>
.weather-canvas-container {
  position: absolute;
  inset: 0;
  overflow: hidden;
}

.gradient-bg {
  z-index: 0;
}

canvas {
  z-index: 1;
  transition: opacity 0.5s ease;
}

.noise-overlay {
  z-index: 2;
  opacity: 0.03;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
}
</style>
</file>

<file path="src/components/layout/AppHeader.vue">
<script setup lang="ts">
import { Menu } from 'lucide-vue-next'
import { useSettingsStore, useLocationStore } from '@/stores'

const settingsStore = useSettingsStore()
const locationStore = useLocationStore()

const handleThemeClick = () => {
  settingsStore.cycleTheme()
}

const handleSettingsClick = () => {
  settingsStore.openDrawer()
}
</script>

<template>
  <header class="fixed top-0 left-0 right-0 z-20 pointer-events-none">
    <nav 
      class="flex justify-between items-center p-6 md:p-8"
      aria-label="Main navigation"
    >
      <!-- Logo / Brand -->
      <div class="flex items-center gap-2 pointer-events-auto">
        <!-- Theme toggle dot -->
        <button
          @click="handleThemeClick"
          class="theme-dot text-accent text-4xl leading-none hover:scale-125 transition-transform focus:outline-none focus-visible:ring-2 focus-visible:ring-accent"
          :title="`Current theme: ${settingsStore.theme}. Click to cycle.`"
          aria-label="Toggle theme"
        >
          .
        </button>
        
        <!-- Brand name -->
        <span 
          class="font-display text-2xl font-bold tracking-tighter"
          style="color: var(--text-primary)"
        >
          WeatherVue
        </span>
      </div>
      
      <!-- Current city (center, optional) -->
      <div 
        v-if="locationStore.currentCity"
        class="hidden md:block absolute left-1/2 -translate-x-1/2 pointer-events-auto"
      >
        <span 
          class="text-xs font-bold uppercase tracking-[0.2em]"
          style="color: var(--text-muted)"
        >
          {{ locationStore.cityDisplayName }}
        </span>
      </div>
      
      <!-- Settings button -->
      <button
        @click="handleSettingsClick"
        class="settings-btn group flex items-center gap-4 pointer-events-auto focus:outline-none"
        aria-label="Open settings"
        :aria-expanded="settingsStore.isDrawerOpen"
        aria-controls="settings-drawer"
      >
        <span 
          class="hidden md:block text-xs font-bold uppercase tracking-[0.2em] transition-colors group-hover:text-accent"
          style="color: var(--text-muted)"
        >
          Configure
        </span>
        
        <div 
          class="w-12 h-12 border flex items-center justify-center transition-all group-hover:bg-accent group-hover:border-accent group-focus-visible:ring-2 group-focus-visible:ring-accent"
          style="border-color: var(--text-primary); color: var(--text-primary)"
        >
          <Menu 
            class="w-5 h-5 transition-colors group-hover:text-white" 
            aria-hidden="true"
          />
        </div>
      </button>
    </nav>
  </header>
</template>

<style scoped>
.theme-dot {
  font-family: theme('fontFamily.display');
  line-height: 0.5;
  cursor: pointer;
}
</style>
</file>

<file path="src/components/layout/BottomNav.vue">
<script setup lang="ts">
import { Home, Search, Settings } from 'lucide-vue-next'
import { useSettingsStore } from '@/stores'

const settingsStore = useSettingsStore()
// const locationStore = useLocationStore() // Removed unused

const scrollToTop = () => {
  window.scrollTo({ top: 0, behavior: 'smooth' })
}

const focusSearch = () => {
  // Logic to focus search input if visible, or scroll to it
  const searchInput = document.querySelector('input[type="text"]') as HTMLInputElement
  if (searchInput) {
    searchInput.focus()
    searchInput.scrollIntoView({ behavior: 'smooth', block: 'center' })
  } else {
    // If search is hidden (e.g. showing weather), maybe reset to search view?
    // For now just scroll top where search likely resides in "empty" state
    scrollToTop()
  }
}
</script>

<template>
  <nav 
    class="fixed bottom-0 left-0 right-0 md:hidden z-30 border-t pb-safe"
    style="background: var(--bg-card); border-color: var(--border-default)"
  >
    <div class="flex justify-around items-center h-16">
      <button 
        @click="scrollToTop"
        class="flex flex-col items-center justify-center w-full h-full space-y-1"
        style="color: var(--text-secondary)"
      >
        <Home class="w-5 h-5" />
        <span class="text-[10px] font-bold uppercase tracking-wider">Home</span>
      </button>
      
      <button 
        @click="focusSearch"
        class="flex flex-col items-center justify-center w-full h-full space-y-1"
        style="color: var(--text-secondary)"
      >
        <Search class="w-5 h-5" />
        <span class="text-[10px] font-bold uppercase tracking-wider">Search</span>
      </button>
      
      <button 
        @click="settingsStore.openDrawer()"
        class="flex flex-col items-center justify-center w-full h-full space-y-1"
        style="color: var(--text-secondary)"
      >
        <Settings class="w-5 h-5" />
        <span class="text-[10px] font-bold uppercase tracking-wider">Settings</span>
      </button>
    </div>
  </nav>
</template>

<style scoped>
.pb-safe {
  padding-bottom: env(safe-area-inset-bottom, 20px);
}
</style>
</file>

<file path="src/components/layout/index.ts">
export { default as SplashScreen } from './SplashScreen.vue'
export { default as AppHeader } from './AppHeader.vue'
export { default as SettingsDrawer } from './SettingsDrawer.vue'
</file>

<file path="src/components/layout/SettingsDrawer.vue">
<script setup lang="ts">
import { ref, watch, onMounted, onUnmounted } from 'vue'
import { X, Sun, Moon, Monitor, Terminal, Volume2, VolumeX, Vibrate } from 'lucide-vue-next'
import { useSettingsStore, useLocationStore } from '@/stores'
import { DEFAULT_CITIES } from '@/types'
import type { Theme, TemperatureUnit, SpeedUnit, City } from '@/types'

const settingsStore = useSettingsStore()
const locationStore = useLocationStore()

const drawerRef = ref<HTMLElement | null>(null)

// Theme options
const themes: { value: Theme; label: string; icon: any }[] = [
  { value: 'light', label: 'Light', icon: Sun },
  { value: 'dark', label: 'Dark', icon: Moon },
  { value: 'system', label: 'System', icon: Monitor },
  { value: 'terminal', label: 'Terminal', icon: Terminal }
]

// Unit options
const tempUnits: { value: TemperatureUnit; label: string }[] = [
  { value: 'celsius', label: '°C' },
  { value: 'fahrenheit', label: '°F' }
]

const speedUnits: { value: SpeedUnit; label: string }[] = [
  { value: 'kmh', label: 'km/h' },
  { value: 'mph', label: 'mph' },
  { value: 'ms', label: 'm/s' }
]

// City selection
const selectCity = (city: City) => {
  locationStore.setCurrentCity(city)
  settingsStore.closeDrawer()
}

// Close drawer handlers
const handleClose = () => {
  settingsStore.closeDrawer()
}

const handleKeydown = (e: KeyboardEvent) => {
  if (e.key === 'Escape' && settingsStore.isDrawerOpen) {
    handleClose()
  }
}

const handleClickOutside = (e: MouseEvent) => {
  if (drawerRef.value && !drawerRef.value.contains(e.target as Node)) {
    handleClose()
  }
}

// Focus trap
onMounted(() => {
  document.addEventListener('keydown', handleKeydown)
})

onUnmounted(() => {
  document.removeEventListener('keydown', handleKeydown)
})

// Handle overlay click
watch(() => settingsStore.isDrawerOpen, (isOpen) => {
  if (isOpen) {
    setTimeout(() => {
      document.addEventListener('click', handleClickOutside)
    }, 100)
  } else {
    document.removeEventListener('click', handleClickOutside)
  }
})
</script>

<template>
  <!-- Backdrop -->
  <Transition name="fade">
    <div 
      v-if="settingsStore.isDrawerOpen"
      class="fixed inset-0 z-30 bg-black/50 backdrop-blur-sm"
      aria-hidden="true"
    />
  </Transition>
  
  <!-- Drawer -->
  <Transition name="slide">
    <aside
      v-if="settingsStore.isDrawerOpen"
      ref="drawerRef"
      id="settings-drawer"
      class="fixed inset-y-0 right-0 w-full md:w-[450px] z-40 flex flex-col shadow-2xl overflow-hidden"
      style="background-color: var(--bg-drawer)"
      role="dialog"
      aria-modal="true"
      aria-labelledby="drawer-title"
    >
      <!-- Header -->
      <div 
        class="p-8 flex justify-between items-end border-b"
        style="border-color: var(--border-default)"
      >
        <h2 
          id="drawer-title"
          class="font-display text-4xl font-bold italic"
          style="color: var(--text-primary)"
        >
          Settings
        </h2>
        
        <button
          @click="handleClose"
          class="text-sm uppercase tracking-widest hover:text-accent transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-accent"
          style="color: var(--text-muted)"
          aria-label="Close settings"
        >
          <X class="w-5 h-5" />
        </button>
      </div>
      
      <!-- Content -->
      <div class="flex-1 overflow-y-auto p-8 space-y-10">
        <!-- Theme Section -->
        <section>
          <h3 class="section-label">00 / Appearance</h3>
          <div class="flex gap-2 mt-4">
            <button
              v-for="t in themes"
              :key="t.value"
              @click="settingsStore.setTheme(t.value)"
              class="theme-btn flex-1 flex items-center justify-center gap-2 py-3 px-4 border text-xs font-bold uppercase tracking-wider transition-all"
              :class="{
                'active': settingsStore.theme === t.value
              }"
              :aria-pressed="settingsStore.theme === t.value"
            >
              <component :is="t.icon" class="w-4 h-4" />
              <span class="hidden sm:inline">{{ t.label }}</span>
            </button>
          </div>
        </section>
        
        <!-- Location Section -->
        <section>
          <h3 class="section-label">01 / Location</h3>
          <div class="mt-4 space-y-2">
            <button
              v-for="city in DEFAULT_CITIES"
              :key="city.id"
              @click="selectCity(city)"
              class="city-btn w-full text-left py-3 px-4 border transition-all"
              :class="{
                'active': locationStore.currentCity?.id === city.id
              }"
            >
              <span class="font-display text-xl font-bold">{{ city.name }}</span>
              <span class="text-xs uppercase tracking-wider ml-2" style="color: var(--text-muted)">
                {{ city.country }}
              </span>
            </button>
          </div>
        </section>
        
        <!-- Units Section -->
        <section>
          <h3 class="section-label">02 / Units</h3>
          
          <!-- Temperature -->
          <div class="mt-4">
            <label class="text-xs uppercase tracking-wider mb-2 block" style="color: var(--text-muted)">
              Temperature
            </label>
            <div class="flex gap-2">
              <button
                v-for="unit in tempUnits"
                :key="unit.value"
                @click="settingsStore.setTemperatureUnit(unit.value)"
                class="unit-btn flex-1 py-2 border text-sm font-bold transition-all"
                :class="{ 'active': settingsStore.temperatureUnit === unit.value }"
              >
                {{ unit.label }}
              </button>
            </div>
          </div>
          
          <!-- Wind Speed -->
          <div class="mt-4">
            <label class="text-xs uppercase tracking-wider mb-2 block" style="color: var(--text-muted)">
              Wind Speed
            </label>
            <div class="flex gap-2">
              <button
                v-for="unit in speedUnits"
                :key="unit.value"
                @click="settingsStore.setSpeedUnit(unit.value)"
                class="unit-btn flex-1 py-2 border text-sm font-bold transition-all"
                :class="{ 'active': settingsStore.speedUnit === unit.value }"
              >
                {{ unit.label }}
              </button>
            </div>
          </div>
        </section>
        
        <!-- Accessibility Section -->
        <section>
          <h3 class="section-label">03 / Accessibility</h3>
          
          <div class="mt-4 space-y-3">
            <!-- Reduced Motion -->
            <label class="toggle-row">
              <span class="toggle-label">Reduce motion</span>
              <button
                @click="settingsStore.toggleReducedMotion()"
                class="toggle-switch"
                :class="{ 'active': settingsStore.reducedMotion }"
                :aria-pressed="settingsStore.reducedMotion"
                role="switch"
              >
                <span class="toggle-thumb" />
              </button>
            </label>
            
            <!-- High Contrast -->
            <label class="toggle-row">
              <span class="toggle-label">High contrast</span>
              <button
                @click="settingsStore.toggleHighContrast()"
                class="toggle-switch"
                :class="{ 'active': settingsStore.highContrast }"
                :aria-pressed="settingsStore.highContrast"
                role="switch"
              >
                <span class="toggle-thumb" />
              </button>
            </label>
          </div>
        </section>
        
        <!-- Audio Section -->
        <section>
          <h3 class="section-label">04 / Audio</h3>
          
          <div class="mt-4 space-y-3">
            <!-- Ambient Audio -->
            <label class="toggle-row">
              <span class="toggle-label flex items-center gap-2">
                <component :is="settingsStore.ambientAudioEnabled ? Volume2 : VolumeX" class="w-4 h-4" />
                Ambient sounds
              </span>
              <button
                @click="settingsStore.toggleAmbientAudio()"
                class="toggle-switch"
                :class="{ 'active': settingsStore.ambientAudioEnabled }"
                :aria-pressed="settingsStore.ambientAudioEnabled"
                role="switch"
              >
                <span class="toggle-thumb" />
              </button>
            </label>
            
            <!-- Volume slider -->
            <div v-if="settingsStore.ambientAudioEnabled" class="pl-6">
              <input
                type="range"
                min="0"
                max="100"
                :value="settingsStore.ambientVolume"
                @input="settingsStore.setAmbientVolume(Number(($event.target as HTMLInputElement).value))"
                class="volume-slider w-full"
                aria-label="Volume"
              />
            </div>
            
            <!-- Haptics -->
            <label class="toggle-row">
              <span class="toggle-label flex items-center gap-2">
                <Vibrate class="w-4 h-4" />
                Haptic feedback
              </span>
              <button
                @click="settingsStore.toggleHaptics()"
                class="toggle-switch"
                :class="{ 'active': settingsStore.hapticsEnabled }"
                :aria-pressed="settingsStore.hapticsEnabled"
                role="switch"
              >
                <span class="toggle-thumb" />
              </button>
            </label>
          </div>
        </section>
      </div>
      
      <!-- Footer -->
      <div 
        class="p-6 border-t text-center"
        style="border-color: var(--border-default)"
      >
        <p class="text-xs" style="color: var(--text-muted)">
          WeatherVue 2.0 &middot; Built with Vue 3
        </p>
      </div>
    </aside>
  </Transition>
</template>

<style scoped>
.section-label {
  color: var(--accent);
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.2em;
}

.theme-btn {
  border-color: var(--border-default);
  color: var(--text-muted);
}

.theme-btn:hover {
  border-color: var(--text-primary);
  color: var(--text-primary);
}

.theme-btn.active {
  background-color: var(--text-primary);
  border-color: var(--text-primary);
  color: var(--bg-body);
}

.city-btn {
  border-color: var(--border-default);
  color: var(--text-primary);
}

.city-btn:hover {
  border-color: var(--accent);
}

.city-btn.active {
  border-color: var(--accent);
  background-color: var(--accent);
  color: white;
}

.unit-btn {
  border-color: var(--border-default);
  color: var(--text-muted);
}

.unit-btn:hover {
  border-color: var(--text-primary);
  color: var(--text-primary);
}

.unit-btn.active {
  background-color: var(--accent);
  border-color: var(--accent);
  color: white;
}

.toggle-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
}

.toggle-label {
  font-size: 0.875rem;
  color: var(--text-primary);
}

.toggle-switch {
  position: relative;
  width: 48px;
  height: 24px;
  border-radius: 12px;
  background-color: var(--border-default);
  transition: background-color 0.2s;
}

.toggle-switch.active {
  background-color: var(--accent);
}

.toggle-thumb {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: white;
  transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.toggle-switch.active .toggle-thumb {
  transform: translateX(24px);
}

.volume-slider {
  appearance: none;
  height: 4px;
  border-radius: 2px;
  background: var(--border-default);
}

.volume-slider::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}

/* Transitions */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.slide-enter-active {
  transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1);
}

.slide-leave-active {
  transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.slide-enter-from,
.slide-leave-to {
  transform: translateX(100%);
}
</style>
</file>

<file path="src/components/layout/SplashScreen.vue">
<script setup lang="ts">
import { ref, onMounted } from 'vue'

const isVisible = ref(true)
const isAnimating = ref(true)

onMounted(() => {
  // Hide splash after animation + delay
  setTimeout(() => {
    isAnimating.value = false
  }, 1500)
  
  setTimeout(() => {
    isVisible.value = false
  }, 2000)
})
</script>

<template>
  <Teleport to="body">
    <Transition
      name="fade"
      @after-leave="$emit('hidden')"
    >
      <div 
        v-if="isVisible"
        class="splash-screen fixed inset-0 z-[100] flex items-center justify-center"
        :class="{ 'pointer-events-none': !isAnimating }"
        style="background-color: var(--bg-body)"
      >
        <div class="text-center">
          <!-- Logo -->
          <h1 
            class="logo font-display text-[12vw] md:text-[10vw] leading-none font-black text-outline"
            :class="{ 'animate': isAnimating }"
          >
            WV
          </h1>
          
          <!-- Accent line -->
          <div 
            class="accent-line h-1 bg-accent mx-auto mt-4"
            :class="{ 'animate': isAnimating }"
          />
          
          <!-- Loading text -->
          <p 
            class="loading-text text-xs uppercase tracking-[0.3em] mt-6 text-muted"
            :class="{ 'animate': isAnimating }"
          >
            Loading atmosphere...
          </p>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<style scoped>
.text-outline {
  -webkit-text-stroke: 2px var(--text-secondary);
  color: transparent;
}

.text-muted {
  color: var(--text-muted);
}

/* Logo animation */
.logo {
  opacity: 0;
  transform: translateY(50px);
}

.logo.animate {
  animation: logoReveal 1.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
}

@keyframes logoReveal {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Accent line animation */
.accent-line {
  width: 0;
}

.accent-line.animate {
  animation: lineExpand 0.8s ease-out 0.5s forwards;
}

@keyframes lineExpand {
  to {
    width: 100px;
  }
}

/* Loading text animation */
.loading-text {
  opacity: 0;
}

.loading-text.animate {
  animation: fadeIn 0.5s ease-out 1s forwards;
}

@keyframes fadeIn {
  to {
    opacity: 1;
  }
}

/* Fade transition */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.8s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
</file>

<file path="src/components/search/CitySearchResults.vue">
<script setup lang="ts">
import { useLocationStore } from '@/stores/locationStore'
import { MapPin, ArrowRight } from 'lucide-vue-next'
import type { City } from '@/types'

const locationStore = useLocationStore()

const handleSelect = (city: City) => {
  locationStore.setCurrentCity(city)
  locationStore.clearSearch()
}
</script>

<template>
  <div v-if="locationStore.searchResults.length > 0" class="w-full">
    <h3 class="text-xs font-bold uppercase tracking-widest mb-4" style="color: var(--text-muted)">
      Search Results
    </h3>
    
    <div class="space-y-2">
      <button
        v-for="city in locationStore.searchResults"
        :key="city.id"
        @click="handleSelect(city)"
        class="group w-full flex items-center justify-between p-4 rounded-xl border transition-all duration-300 hover:scale-[1.02]"
        style="background: var(--bg-card); border-color: var(--border-default)"
      >
        <div class="flex items-center gap-4">
          <div 
            class="w-10 h-10 rounded-full flex items-center justify-center transition-colors group-hover:bg-accent group-hover:text-white"
            style="background: var(--bg-card-hover); color: var(--text-secondary)"
          >
            <MapPin class="w-5 h-5" />
          </div>
          
          <div class="text-left">
            <p class="font-display font-bold text-lg" style="color: var(--text-primary)">
              {{ city.name }}
            </p>
            <p class="text-xs uppercase tracking-wider" style="color: var(--text-muted)">
              {{ city.country }}
              <span v-if="city.admin1">· {{ city.admin1 }}</span>
            </p>
          </div>
        </div>
        
        <ArrowRight 
          class="w-5 h-5 opacity-0 -translate-x-4 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0"
          style="color: var(--accent)"
        />
      </button>
    </div>
  </div>
  
  <div v-else-if="locationStore.isSearching" class="text-center py-8">
    <div class="inline-block animate-spin w-6 h-6 border-2 border-current border-t-transparent rounded-full mb-2" style="color: var(--accent)" />
    <p class="text-sm" style="color: var(--text-muted)">Searching...</p>
  </div>
  
  <div v-else-if="locationStore.searchQuery && !locationStore.isSearching && locationStore.searchResults.length === 0" class="text-center py-8">
    <p class="text-sm" style="color: var(--text-muted)">No cities found</p>
  </div>
</template>
</file>

<file path="src/components/search/RecentCities.vue">
<script setup lang="ts">
import { useLocationStore } from '@/stores/locationStore'
import { Clock, X } from 'lucide-vue-next'
import type { City } from '@/types'

const locationStore = useLocationStore()

const handleSelect = (city: City) => {
  locationStore.setCurrentCity(city)
}

const handleRemove = (e: Event, cityId: string) => {
  e.stopPropagation()
  locationStore.removeFromRecentCities(cityId)
}
</script>

<template>
  <div v-if="locationStore.recentCities.length > 0" class="w-full mt-8">
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xs font-bold uppercase tracking-widest" style="color: var(--text-muted)">
        Recent Locations
      </h3>
      <button 
        @click="locationStore.clearRecentCities()"
        class="text-xs hover:underline"
        style="color: var(--accent)"
      >
        Clear All
      </button>
    </div>
    
    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
      <button
        v-for="city in locationStore.recentCities"
        :key="city.id"
        @click="handleSelect(city)"
        class="group relative flex items-center gap-3 p-3 rounded-lg border transition-all hover:border-accent"
        style="background: var(--bg-card); border-color: var(--border-default)"
      >
        <Clock class="w-4 h-4" style="color: var(--text-muted)" />
        
        <div class="flex-1 text-left overflow-hidden">
          <p class="font-bold truncate" style="color: var(--text-primary)">
            {{ city.name }}
          </p>
          <p class="text-xs truncate" style="color: var(--text-muted)">
            {{ city.country }}
          </p>
        </div>
        
        <div 
          role="button"
          tabindex="0"
          @click="(e) => handleRemove(e, city.id)"
          class="opacity-0 group-hover:opacity-100 p-1 rounded-full hover:bg-red-100 hover:text-red-600 transition-all"
        >
          <X class="w-3 h-3" />
        </div>
      </button>
    </div>
  </div>
</template>
</file>

<file path="src/components/ui/AnimatedNumber.vue">
<script setup lang="ts">
import { ref, watch, computed } from 'vue'

interface Props {
  value: number
  duration?: number
  decimals?: number
  prefix?: string
  suffix?: string
}

const props = withDefaults(defineProps<Props>(), {
  duration: 1000,
  decimals: 0,
  prefix: '',
  suffix: ''
})

const displayValue = ref(props.value)
const isAnimating = ref(false)

// Easing function (ease out expo)
const easeOutExpo = (t: number): number => {
  return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
}

// Animate when value changes
watch(() => props.value, (newVal, oldVal) => {
  if (oldVal === undefined) {
    displayValue.value = newVal
    return
  }
  
  const startValue = displayValue.value
  const startTime = performance.now()
  isAnimating.value = true
  
  const animate = (currentTime: number) => {
    const elapsed = currentTime - startTime
    const progress = Math.min(elapsed / props.duration, 1)
    const easedProgress = easeOutExpo(progress)
    
    displayValue.value = startValue + (newVal - startValue) * easedProgress
    
    if (progress < 1) {
      requestAnimationFrame(animate)
    } else {
      displayValue.value = newVal
      isAnimating.value = false
    }
  }
  
  requestAnimationFrame(animate)
}, { immediate: true })

const formattedValue = computed(() => {
  const val = props.decimals > 0 
    ? displayValue.value.toFixed(props.decimals)
    : Math.round(displayValue.value)
  return `${props.prefix}${val}${props.suffix}`
})
</script>

<template>
  <span 
    class="animated-number"
    :class="{ 'animating': isAnimating }"
    :aria-label="`${prefix}${value}${suffix}`"
  >
    {{ formattedValue }}
  </span>
</template>

<style scoped>
.animated-number {
  display: inline-block;
  font-variant-numeric: tabular-nums;
}
</style>
</file>

<file path="src/components/ui/ErrorDisplay.vue">
<script setup lang="ts">
 import { AlertTriangle, RefreshCw, WifiOff } from 'lucide-vue-next'
 
 defineProps<{
   error: Error | null
   isOffline?: boolean
   retrying?: boolean
 }>()
 
 const emit = defineEmits<{
   retry: []
 }>()
 </script>
 
 <template>
   <div 
     class="error-display flex flex-col items-center justify-center p-8 rounded-3xl border border-red-500/30 bg-red-500/10"
     role="alert"
     aria-live="assertive"
   >
     <div class="icon-wrapper mb-4">
       <WifiOff v-if="isOffline" class="w-12 h-12 text-red-500" />
       <AlertTriangle v-else class="w-12 h-12 text-red-500" />
     </div>
     
     <h3 class="text-lg font-bold mb-2" style="color: var(--text-primary)">
       {{ isOffline ? 'You are offline' : 'Something went wrong' }}
     </h3>
     
     <p class="text-sm text-center mb-6" style="color: var(--text-muted)">
       {{ isOffline 
         ? 'Check your internet connection and try again.' 
         : error?.message || 'Failed to load weather data. Please try again.' 
       }}
     </p>
     
     <button
       @click="emit('retry')"
       :disabled="retrying"
       class="retry-btn flex items-center gap-2 px-6 py-3 rounded-full font-bold text-sm uppercase tracking-wider transition-all hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
       :class="{ 'animate-pulse': retrying }"
     >
       <RefreshCw 
         class="w-4 h-4" 
         :class="{ 'animate-spin': retrying }"
       />
       {{ retrying ? 'Retrying...' : 'Try Again' }}
     </button>
   </div>
 </template>
 
 <style scoped>
 .retry-btn {
   background-color: var(--accent);
   color: white;
 }
 
 .retry-btn:hover:not(:disabled) {
   box-shadow: 0 4px 20px var(--accent);
 }
 </style>
</file>

<file path="src/components/ui/GlassmorphicCard.vue">
<script setup lang="ts">
interface Props {
  blur?: number
  opacity?: number
  border?: boolean
}

withDefaults(defineProps<Props>(), {
  blur: 20,
  opacity: 0.7,
  border: true
})
</script>

<template>
  <div 
    class="glassmorphic-card"
    :class="{ 'with-border': border }"
    :style="{
      '--blur': `${blur}px`,
      '--opacity': opacity
    }"
  >
    <slot />
  </div>
</template>

<style scoped>
.glassmorphic-card {
  background: rgba(var(--bg-card-rgb, 255, 255, 255), var(--opacity));
  backdrop-filter: blur(var(--blur));
  -webkit-backdrop-filter: blur(var(--blur));
  border-radius: 0.5rem;
  padding: 1.5rem;
}

.with-border {
  border: 1px solid var(--border-glass, rgba(255, 255, 255, 0.2));
}

[data-theme="dark"] .glassmorphic-card {
  background: rgba(0, 0, 0, var(--opacity));
}
</style>
</file>

<file path="src/components/ui/IconWrapper.vue">
<script setup lang="ts">
import type { Component } from 'vue'

defineProps<{
  icon: Component
  size?: string | number
  color?: string
  strokeWidth?: number
}>()
</script>

<template>
  <div 
    class="icon-wrapper flex items-center justify-center"
    :style="{ 
      width: typeof size === 'number' ? `${size}px` : size || '24px',
      height: typeof size === 'number' ? `${size}px` : size || '24px',
      color: color || 'currentColor'
    }"
  >
    <component 
      :is="icon" 
      :stroke-width="strokeWidth || 2"
      class="w-full h-full"
    />
  </div>
</template>
</file>

<file path="src/components/ui/index.ts">
export { default as AnimatedNumber } from './AnimatedNumber.vue'
export { default as WeatherIcon } from './WeatherIcon.vue'
export { default as MagneticButton } from './MagneticButton.vue'
export { default as GlassmorphicCard } from './GlassmorphicCard.vue'
export { default as WeatherCard } from './WeatherCard.vue'
</file>

<file path="src/components/ui/MagneticButton.vue">
<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useSettingsStore } from '@/stores'
import { Haptics } from '@/utils/haptics'

interface Props {
  strength?: number
  radius?: number
}

const props = withDefaults(defineProps<Props>(), {
  strength: 0.3,
  radius: 100
})

const settingsStore = useSettingsStore()
const buttonRef = ref<HTMLElement | null>(null)
const transform = ref({ x: 0, y: 0 })

let animationFrame: number | null = null

const handleMouseMove = (e: MouseEvent) => {
  if (!buttonRef.value || settingsStore.prefersReducedMotion) return
  
  const rect = buttonRef.value.getBoundingClientRect()
  const centerX = rect.left + rect.width / 2
  const centerY = rect.top + rect.height / 2
  
  const deltaX = e.clientX - centerX
  const deltaY = e.clientY - centerY
  const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2)
  
  if (distance < props.radius) {
    const strength = 1 - (distance / props.radius)
    const maxMove = 15
    
    transform.value = {
      x: Math.min(Math.max(deltaX * strength * props.strength, -maxMove), maxMove),
      y: Math.min(Math.max(deltaY * strength * props.strength, -maxMove), maxMove)
    }
  }
}

const handleMouseLeave = () => {
  if (settingsStore.prefersReducedMotion) return
  
  // Animate back to center with spring effect
  const startX = transform.value.x
  const startY = transform.value.y
  const duration = 500
  const startTime = performance.now()
  
  const animate = (currentTime: number) => {
    const elapsed = currentTime - startTime
    const progress = Math.min(elapsed / duration, 1)
    
    // Spring easing
    const eased = 1 - Math.pow(1 - progress, 3)
    
    transform.value = {
      x: startX * (1 - eased),
      y: startY * (1 - eased)
    }
    
    if (progress < 1) {
      animationFrame = requestAnimationFrame(animate)
    }
  }
  
  animationFrame = requestAnimationFrame(animate)
}

onMounted(() => {
  window.addEventListener('mousemove', handleMouseMove)
})

onUnmounted(() => {
  window.removeEventListener('mousemove', handleMouseMove)
  if (animationFrame) {
    cancelAnimationFrame(animationFrame)
  }
})

const handleClick = () => {
  if (settingsStore.hapticsEnabled) {
    Haptics.light()
  }
}
</script>

<template>
  <button
    ref="buttonRef"
    class="magnetic-button"
    :style="{
      transform: `translate(${transform.x}px, ${transform.y}px)`
    }"
    @mouseleave="handleMouseLeave"
    @click="handleClick"
  >
    <slot />
  </button>
</template>

<style scoped>
.magnetic-button {
  transition: box-shadow 0.2s ease;
}

.magnetic-button:hover {
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
}
</style>
</file>

<file path="src/components/ui/OfflineIndicator.vue">
<script setup lang="ts">
 import { ref, onMounted, onUnmounted } from 'vue'
 import { WifiOff, Wifi } from 'lucide-vue-next'
 
 const isOnline = ref(navigator.onLine)
 const showReconnected = ref(false)
 
 const handleOnline = () => {
   isOnline.value = true
   showReconnected.value = true
   setTimeout(() => {
     showReconnected.value = false
   }, 3000)
 }
 
 const handleOffline = () => {
   isOnline.value = false
   showReconnected.value = false
 }
 
 onMounted(() => {
   window.addEventListener('online', handleOnline)
   window.addEventListener('offline', handleOffline)
 })
 
 onUnmounted(() => {
   window.removeEventListener('online', handleOnline)
   window.removeEventListener('offline', handleOffline)
 })
 </script>
 
 <template>
   <Transition name="slide-up">
     <div 
       v-if="!isOnline || showReconnected"
       class="offline-indicator fixed bottom-6 left-1/2 -translate-x-1/2 z-50 flex items-center gap-3 px-6 py-3 rounded-full shadow-lg"
       :class="isOnline ? 'bg-green-500' : 'bg-red-500'"
       role="status"
       :aria-live="isOnline ? 'polite' : 'assertive'"
     >
       <Wifi v-if="isOnline" class="w-4 h-4 text-white" />
       <WifiOff v-else class="w-4 h-4 text-white" />
       <span class="text-white text-sm font-medium">
         {{ isOnline ? 'Back online' : 'You are offline' }}
       </span>
     </div>
   </Transition>
 </template>
 
 <style scoped>
 .slide-up-enter-active,
 .slide-up-leave-active {
   transition: all 0.3s cubic-bezier(0.22, 1, 0.36, 1);
 }
 
 .slide-up-enter-from,
 .slide-up-leave-to {
   opacity: 0;
   transform: translate(-50%, 100%);
 }
 </style>
</file>

<file path="src/components/ui/SkeletonLoader.vue">
<script setup lang="ts">
defineProps<{
  width?: string
  height?: string
  borderRadius?: string
}>()
</script>

<template>
  <div 
    class="skeleton-loader animate-pulse bg-gray-200 dark:bg-gray-700"
    :style="{ 
      width: width || '100%', 
      height: height || '20px', 
      borderRadius: borderRadius || '4px' 
    }"
  ></div>
</template>

<style scoped>
.skeleton-loader {
  background: linear-gradient(
    90deg,
    var(--bg-card) 25%,
    var(--bg-card-hover) 50%,
    var(--bg-card) 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}
</style>
</file>

<file path="src/components/ui/WeatherCard.vue">
<script setup lang="ts">
import { ref, type Component } from 'vue'
import { useSettingsStore } from '@/stores'

interface Props {
  title: string
  value: string | number
  unit?: string
  icon?: Component
  description?: string
  accent?: string
}

const props = defineProps<Props>()
const settingsStore = useSettingsStore()

const cardRef = ref<HTMLElement | null>(null)
const mousePos = ref({ x: 0, y: 0 })
const isHovered = ref(false)

const handleMouseMove = (e: MouseEvent) => {
  if (!cardRef.value || settingsStore.prefersReducedMotion) return
  
  const rect = cardRef.value.getBoundingClientRect()
  const x = (e.clientX - rect.left) / rect.width - 0.5
  const y = (e.clientY - rect.top) / rect.height - 0.5
  
  mousePos.value = { x, y }
}

const parallaxStyle = (factor: number) => {
  if (settingsStore.prefersReducedMotion || !isHovered.value) return {}
  
  return {
    transform: `translate(${mousePos.value.x * factor * 20}px, ${mousePos.value.y * factor * 20}px)`,
    transition: 'transform 0.1s ease-out'
  }
}
</script>

<template>
  <div 
    ref="cardRef"
    class="weather-card group relative overflow-hidden rounded-2xl p-6 border transition-all duration-500"
    :style="{
      background: 'var(--bg-card)',
      borderColor: isHovered ? (props.accent || 'var(--accent)') : 'var(--border-default)'
    }"
    @mousemove="handleMouseMove"
    @mouseenter="isHovered = true"
    @mouseleave="isHovered = false"
  >
    <!-- Background Watermark -->
    <div 
      class="absolute -bottom-8 -right-8 opacity-[0.03] group-hover:opacity-[0.08] transition-all duration-700 pointer-events-none"
      :style="parallaxStyle(0.5)"
    >
      <component :is="icon" v-if="icon" class="w-48 h-48" />
    </div>

    <!-- Content -->
    <div class="relative z-10 h-full flex flex-col justify-between">
      <div>
        <div class="flex items-center justify-between mb-2">
          <h3 class="text-xs font-bold uppercase tracking-[0.2em]" style="color: var(--text-muted)">
            {{ title }}
          </h3>
          <component :is="icon" v-if="icon" class="w-4 h-4" :style="{ color: accent || 'var(--accent)' }" />
        </div>
        
        <div class="flex items-baseline" :style="parallaxStyle(1)">
          <span class="font-display text-4xl font-bold">
            {{ value }}
          </span>
          <span v-if="unit" class="ml-1 text-lg font-medium" style="color: var(--text-secondary)">
            {{ unit }}
          </span>
        </div>
      </div>
      
      <p v-if="description" class="mt-4 text-xs" style="color: var(--text-muted)">
        {{ description }}
      </p>
    </div>

    <!-- Border Glow -->
    <div 
      class="absolute inset-0 opacity-0 group-hover:opacity-100 transition-opacity duration-500 pointer-events-none"
      :style="{
        boxShadow: `inset 0 0 20px ${accent || 'var(--accent)'}20`
      }"
    />
  </div>
</template>

<style scoped>
.weather-card:hover {
  transform: translateY(-4px);
  border-color: var(--accent);
}
</style>
</file>

<file path="src/components/ui/WeatherIcon.vue">
<script setup lang="ts">
import { computed } from 'vue'
import * as LucideIcons from 'lucide-vue-next'

interface Props {
  name: string
  size?: number | string
  strokeWidth?: number
}

const props = withDefaults(defineProps<Props>(), {
  size: 24,
  strokeWidth: 2
})

// Get icon component by name
const iconComponent = computed(() => {
  const icons = LucideIcons as Record<string, any>
  return icons[props.name] || icons['Cloud']
})
</script>

<template>
  <component 
    :is="iconComponent"
    :size="size"
    :stroke-width="strokeWidth"
    aria-hidden="true"
  />
</template>
</file>

<file path="src/components/weather/index.ts">
export { default as CurrentWeather } from './CurrentWeather.vue'
export { default as HourlyForecast } from './HourlyForecast.vue'
export { default as WeeklyForecast } from './WeeklyForecast.vue'
export { default as TimelineScrubber } from './TimelineScrubber.vue'
export { default as TemperatureGraph } from './TemperatureGraph.vue'
export { default as WindCompass } from './WindCompass.vue'
export { default as SunriseSunsetArc } from './SunriseSunsetArc.vue'
export { default as UVIndexGauge } from './UVIndexGauge.vue'
export { default as PrecipitationBar } from './PrecipitationBar.vue'
</file>

<file path="src/composables/useAudio.ts">
import { onMounted, watch } from 'vue'
import { useSettingsStore } from '@/stores/settingsStore'

export const useAudio = (audioUrl: string) => {
  const settingsStore = useSettingsStore()
  let audio: HTMLAudioElement | null = null

  const initAudio = () => {
    if (!audio) {
      audio = new Audio(audioUrl)
      audio.loop = true
      audio.volume = settingsStore.ambientVolume / 100
    }
  }

  const play = () => {
    if (settingsStore.ambientAudioEnabled && audio) {
      audio.play().catch(() => {
        // Autoplay policy might block this
      })
    }
  }

  const pause = () => {
    if (audio) {
      audio.pause()
    }
  }

  watch(() => settingsStore.ambientAudioEnabled, (enabled) => {
    if (enabled) play()
    else pause()
  })

  watch(() => settingsStore.ambientVolume, (volume) => {
    if (audio) {
      audio.volume = volume / 100
    }
  })

  onMounted(() => {
    initAudio()
    if (settingsStore.ambientAudioEnabled) {
      play()
    }
  })

  return {
    play,
    pause
  }
}
</file>

<file path="src/composables/useFocusTrap.ts">
import { ref, onUnmounted, type Ref } from 'vue'

export const useFocusTrap = (containerRef: Ref<HTMLElement | null>) => {
  const previousActiveElement = ref<HTMLElement | null>(null)
  
  const getFocusableElements = () => {
    if (!containerRef.value) return []
    
    const selectors = [
      'button:not([disabled])',
      'a[href]',
      'input:not([disabled])',
      'select:not([disabled])',
      'textarea:not([disabled])',
      '[tabindex]:not([tabindex="-1"])'
    ].join(', ')
    
    return Array.from(containerRef.value.querySelectorAll<HTMLElement>(selectors))
  }
  
  const handleKeyDown = (e: KeyboardEvent) => {
    if (e.key !== 'Tab') return
    
    const focusable = getFocusableElements()
    if (focusable.length === 0) return
    
    const firstElement = focusable[0]
    const lastElement = focusable[focusable.length - 1]
    
    if (e.shiftKey) {
      if (document.activeElement === firstElement) {
        e.preventDefault()
        lastElement?.focus()
      }
    } else {
      if (document.activeElement === lastElement) {
        e.preventDefault()
        firstElement?.focus()
      }
    }
  }
  
  const activate = () => {
    previousActiveElement.value = document.activeElement as HTMLElement
    document.addEventListener('keydown', handleKeyDown)
    
    const focusable = getFocusableElements()
    if (focusable.length > 0) {
      focusable[0]?.focus()
    }
  }
  
  const deactivate = () => {
    document.removeEventListener('keydown', handleKeyDown)
    previousActiveElement.value?.focus()
  }
  
  onUnmounted(() => {
    document.removeEventListener('keydown', handleKeyDown)
  })
  
  return {
    activate,
    deactivate
  }
}
</file>

<file path="src/composables/useGeolocation.ts">
import { ref } from 'vue'
import type { Location } from '@/types'

export const useGeolocation = () => {
  const coords = ref<Location | null>(null)
  const error = ref<string | null>(null)
  const loading = ref(false)
  const supported = 'geolocation' in navigator

  let watcherId: number | null = null

  const getPosition = (): Promise<GeolocationPosition> => {
    return new Promise((resolve, reject) => {
      navigator.geolocation.getCurrentPosition(resolve, reject, {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      })
    })
  }

  const updateLocation = async () => {
    if (!supported) {
      error.value = 'Geolocation is not supported by your browser'
      return
    }

    loading.value = true
    error.value = null

    try {
      const position = await getPosition()
      coords.value = {
        latitude: position.coords.latitude,
        longitude: position.coords.longitude
      }
    } catch (err: any) {
      error.value = err.message || 'Failed to get location'
    } finally {
      loading.value = false
    }
  }

  const watchLocation = () => {
    if (!supported || watcherId !== null) return

    watcherId = navigator.geolocation.watchPosition(
      (position) => {
        coords.value = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude
        }
        error.value = null
      },
      (err) => {
        error.value = err.message
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    )
  }

  const stopWatching = () => {
    if (watcherId !== null) {
      navigator.geolocation.clearWatch(watcherId)
      watcherId = null
    }
  }

  return {
    coords,
    error,
    loading,
    supported,
    updateLocation,
    watchLocation,
    stopWatching
  }
}
</file>

<file path="src/composables/useHaptics.ts">
import { useSettingsStore } from '@/stores/settingsStore'
import { Haptics } from '@/utils/haptics'

export const useHaptics = () => {
  const settingsStore = useSettingsStore()

  const vibrate = (pattern: 'light' | 'medium' | 'heavy' | 'success' | 'error' | 'selection') => {
    if (!settingsStore.hapticsEnabled) return

    switch (pattern) {
      case 'light':
        Haptics.light()
        break
      case 'medium':
        Haptics.medium()
        break
      case 'heavy':
        Haptics.heavy()
        break
      case 'success':
        Haptics.success()
        break
      case 'error':
        Haptics.error()
        break
      case 'selection':
        Haptics.selection()
        break
    }
  }

  return {
    vibrate
  }
}
</file>

<file path="src/composables/useKeyboardShortcuts.ts">
import { onMounted, onUnmounted } from 'vue'
 import { useSettingsStore, useWeatherStore } from '@/stores'
 
 export const useKeyboardShortcuts = () => {
   const settingsStore = useSettingsStore()
   const weatherStore = useWeatherStore()
   
   const handleKeyDown = (e: KeyboardEvent) => {
     // Skip if user is typing in an input
     if (
       e.target instanceof HTMLInputElement ||
       e.target instanceof HTMLTextAreaElement
     ) {
       return
     }
     
     // Keyboard shortcuts
     switch (e.key) {
       case 't':
       case 'T':
         // Toggle theme
         if (!e.ctrlKey && !e.metaKey) {
           settingsStore.cycleTheme()
         }
         break
         
       case ',':
         // Open settings
         if (!e.ctrlKey && !e.metaKey) {
           settingsStore.openDrawer()
         }
         break
         
       case 'Escape':
         // Close settings drawer
         if (settingsStore.isDrawerOpen) {
           settingsStore.closeDrawer()
         }
         break
         
       case 'r':
       case 'R':
         // Refresh weather (when not in input)
         if (!e.ctrlKey && !e.metaKey && weatherStore.hasData) {
           weatherStore.setLoading(true)
         }
         break
         
       case '/':
       case '?':
         // Focus search (could be implemented)
         if (!e.ctrlKey && !e.metaKey) {
           const searchInput = document.querySelector('[data-search-input]') as HTMLInputElement
           searchInput?.focus()
         }
         break
     }
   }
   
   onMounted(() => {
     document.addEventListener('keydown', handleKeyDown)
   })
   
   onUnmounted(() => {
     document.removeEventListener('keydown', handleKeyDown)
   })
 }
</file>

<file path="src/composables/useMagneticEffect.ts">
import { onMounted, onUnmounted, type Ref } from 'vue'
import gsap from 'gsap'
import { useSettingsStore } from '@/stores/settingsStore'

export const useMagneticEffect = (el: Ref<HTMLElement | null>, strength: number = 0.5) => {
  const settingsStore = useSettingsStore()
  
  const handleMouseMove = (e: MouseEvent) => {
    if (!el.value || settingsStore.prefersReducedMotion) return

    const { left, top, width, height } = el.value.getBoundingClientRect()
    const centerX = left + width / 2
    const centerY = top + height / 2

    const deltaX = Math.floor((e.clientX - centerX) * strength)
    const deltaY = Math.floor((e.clientY - centerY) * strength)

    gsap.to(el.value, {
      x: deltaX,
      y: deltaY,
      duration: 0.5,
      ease: 'power3.out'
    })
  }

  const handleMouseLeave = () => {
    if (!el.value) return
    
    gsap.to(el.value, {
      x: 0,
      y: 0,
      duration: 0.7,
      ease: 'elastic.out(1, 0.3)'
    })
  }

  onMounted(() => {
    if (el.value) {
      el.value.addEventListener('mousemove', handleMouseMove)
      el.value.addEventListener('mouseleave', handleMouseLeave)
    }
  })

  onUnmounted(() => {
    if (el.value) {
      el.value.removeEventListener('mousemove', handleMouseMove)
      el.value.removeEventListener('mouseleave', handleMouseLeave)
    }
  })
}
</file>

<file path="src/composables/useParallax.ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useSettingsStore } from '@/stores/settingsStore'

export const useParallax = (factor = 0.05) => {
  const settingsStore = useSettingsStore()
  const mouseX = ref(0)
  const mouseY = ref(0)
  
  const handleMouseMove = (event: MouseEvent) => {
    if (settingsStore.prefersReducedMotion) return
    
    const { innerWidth, innerHeight } = window
    mouseX.value = (event.clientX - innerWidth / 2) * factor
    mouseY.value = (event.clientY - innerHeight / 2) * factor
  }

  onMounted(() => {
    window.addEventListener('mousemove', handleMouseMove)
  })

  onUnmounted(() => {
    window.removeEventListener('mousemove', handleMouseMove)
  })

  return {
    mouseX,
    mouseY
  }
}
</file>

<file path="src/composables/useReducedMotion.ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useSettingsStore } from '@/stores/settingsStore'

export const useReducedMotion = () => {
  const settingsStore = useSettingsStore()
  const systemPrefersReducedMotion = ref(false)

  const updatePreference = (e: MediaQueryListEvent | MediaQueryList) => {
    systemPrefersReducedMotion.value = e.matches
  }

  onMounted(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)')
    updatePreference(mediaQuery)
    mediaQuery.addEventListener('change', updatePreference)
  })

  onUnmounted(() => {
    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)')
    mediaQuery.removeEventListener('change', updatePreference)
  })

  return {
    isReduced: settingsStore.prefersReducedMotion || systemPrefersReducedMotion
  }
}
</file>

<file path="src/composables/useSonification.ts">
import { watch } from 'vue'
import { useSettingsStore } from '@/stores/settingsStore'
import { sonification } from '@/services/sonification'

export const useSonification = () => {
  const settingsStore = useSettingsStore()

  const playTone = (temperature: number) => {
    if (settingsStore.sonificationEnabled) {
      sonification.playTemperatureTone(temperature)
    }
  }

  watch(() => settingsStore.ambientVolume, (val) => {
    sonification.setVolume(val)
  })

  return {
    playTone
  }
}
</file>

<file path="src/composables/useTheme.ts">
import { watch, computed, onMounted } from 'vue'
import { useSettingsStore } from '@/stores/settingsStore'
import { useWeatherStore } from '@/stores/weatherStore'

export const useTheme = () => {
  const settingsStore = useSettingsStore()
  const weatherStore = useWeatherStore()

  const currentTheme = computed(() => settingsStore.effectiveTheme)
  const currentWeatherType = computed(() => weatherStore.weatherType)
  const isDay = computed(() => {
    // Check interpolated weather if available, otherwise current
    if (weatherStore.interpolatedWeather) {
      return weatherStore.interpolatedWeather.isDay
    }
    return weatherStore.current?.isDay ?? true
  })

  const updateAttributes = () => {
    const root = document.documentElement
    
    // Theme attribute (light/dark/terminal)
    if (currentTheme.value === 'terminal') {
      root.setAttribute('data-theme', 'terminal')
    } else if (currentTheme.value === 'dark') {
      root.setAttribute('data-theme', 'dark')
    } else {
      root.removeAttribute('data-theme')
    }

    // Weather attribute
    if (weatherStore.hasData) {
      root.setAttribute('data-weather', currentWeatherType.value)
      root.setAttribute('data-time', isDay.value ? 'day' : 'night')
    } else {
      root.removeAttribute('data-weather')
      root.removeAttribute('data-time')
    }
    
    // Accessibility attributes
    if (settingsStore.prefersReducedMotion) {
      root.setAttribute('data-reduced-motion', 'true')
    } else {
      root.removeAttribute('data-reduced-motion')
    }
  }

  // Watch for changes and update
  watch([currentTheme, currentWeatherType, isDay, () => settingsStore.prefersReducedMotion], () => {
    updateAttributes()
  })

  onMounted(() => {
    settingsStore.init()
    updateAttributes()
  })

  return {
    currentTheme,
    currentWeatherType,
    isDay,
    updateAttributes
  }
}
</file>

<file path="src/config/env.ts">
// Environment configuration
 // API keys should be set via environment variables, not hardcoded
 // In production, use a backend proxy to avoid exposing keys to the client
 
 interface EnvConfig {
   azureTranslatorKey: string | undefined
   azureTranslatorRegion: string
   useTranslationProxy: boolean
   translationProxyUrl: string
 }
 
 export const env: EnvConfig = {
   // Azure Translator API - prefer proxy in production
   azureTranslatorKey: import.meta.env.VITE_AZURE_TRANSLATOR_KEY,
   azureTranslatorRegion: import.meta.env.VITE_AZURE_TRANSLATOR_REGION || 'eastus',
   
   // Use a backend proxy to hide API keys in production
   useTranslationProxy: import.meta.env.VITE_USE_TRANSLATION_PROXY === 'true',
   translationProxyUrl: import.meta.env.VITE_TRANSLATION_PROXY_URL || '/api/translate'
 }
 
 // Warn if API key is exposed in production
 if (import.meta.env.PROD && env.azureTranslatorKey && !env.useTranslationProxy) {
   console.warn(
     '[WeatherVue] Warning: Azure API key is exposed in production. ' +
     'Consider using VITE_USE_TRANSLATION_PROXY=true with a backend proxy.'
   )
 }
</file>

<file path="src/main.ts">
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'

import './styles/main.css'

const app = createApp(App)
const pinia = createPinia()

app.use(pinia)
app.mount('#app')
</file>

<file path="src/services/cache.test.ts">
import { describe, it, expect, beforeEach } from 'vitest'
 import { cache } from './cache'
 
 describe('cache', () => {
   beforeEach(() => {
     cache.clear()
   })
 
   it('should store and retrieve values', () => {
     cache.set('test-key', { value: 42 }, 60000)
     expect(cache.get('test-key')).toEqual({ value: 42 })
   })
 
   it('should return undefined for non-existent keys', () => {
    expect(cache.get('non-existent')).toBeNull()
   })
 
   it('should generate consistent weather keys', () => {
     const key1 = cache.weatherKey(40.7128, -74.006)
     const key2 = cache.weatherKey(40.7128, -74.006)
     expect(key1).toBe(key2)
   })
 
   it('should generate different keys for different locations', () => {
     const nyKey = cache.weatherKey(40.7128, -74.006)
     const laKey = cache.weatherKey(34.0522, -118.2437)
     expect(nyKey).not.toBe(laKey)
   })
 })
</file>

<file path="src/services/cache.ts">
import { CACHE_TTL } from '@/utils/constants'

interface CacheEntry<T> {
  data: T
  timestamp: number
  ttl: number
}

class CacheService {
  private cache: Map<string, CacheEntry<any>> = new Map()
  private prefix = 'weathervue-cache-'
  
  // Get from cache (memory first, then localStorage)
  get<T>(key: string): T | null {
    // Check memory cache
    const memoryEntry = this.cache.get(key)
    if (memoryEntry && !this.isExpired(memoryEntry)) {
      return memoryEntry.data
    }
    
    // Check localStorage
    try {
      const stored = localStorage.getItem(this.prefix + key)
      if (stored) {
        const entry: CacheEntry<T> = JSON.parse(stored)
        if (!this.isExpired(entry)) {
          // Restore to memory cache
          this.cache.set(key, entry)
          return entry.data
        } else {
          // Remove expired entry
          localStorage.removeItem(this.prefix + key)
        }
      }
    } catch {
      // Ignore localStorage errors
    }
    
    return null
  }
  
  // Set cache entry
  set<T>(key: string, data: T, ttl: number = CACHE_TTL.weather): void {
    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      ttl
    }
    
    // Set in memory
    this.cache.set(key, entry)
    
    // Persist to localStorage for longer TTLs
    if (ttl > 60000) { // > 1 minute
      try {
        localStorage.setItem(this.prefix + key, JSON.stringify(entry))
      } catch {
        // localStorage might be full
      }
    }
  }
  
  // Remove cache entry
  remove(key: string): void {
    this.cache.delete(key)
    try {
      localStorage.removeItem(this.prefix + key)
    } catch {
      // Ignore
    }
  }
  
  // Clear all cache
  clear(): void {
    this.cache.clear()
    
    try {
      const keys = Object.keys(localStorage)
      keys.forEach(key => {
        if (key.startsWith(this.prefix)) {
          localStorage.removeItem(key)
        }
      })
    } catch {
      // Ignore
    }
  }
  
  // Check if entry is expired
  private isExpired(entry: CacheEntry<any>): boolean {
    if (entry.ttl === Infinity) return false
    return Date.now() - entry.timestamp > entry.ttl
  }
  
  // Generate cache key for weather data
  weatherKey(lat: number, lng: number): string {
    // Round to 2 decimal places for cache efficiency
    const roundedLat = Math.round(lat * 100) / 100
    const roundedLng = Math.round(lng * 100) / 100
    return `weather-${roundedLat}-${roundedLng}`
  }
  
  // Generate cache key for geocoding
  geocodingKey(query: string): string {
    return `geo-${query.toLowerCase().trim()}`
  }
}

export const cache = new CacheService()

// SWR-like hook helper
export const fetchWithCache = async <T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl: number = CACHE_TTL.weather
): Promise<{ data: T; fromCache: boolean }> => {
  // Check cache first
  const cached = cache.get<T>(key)
  if (cached) {
    return { data: cached, fromCache: true }
  }
  
  // Fetch fresh data
  const data = await fetcher()
  
  // Cache the result
  cache.set(key, data, ttl)
  
  return { data, fromCache: false }
}
</file>

<file path="src/services/index.ts">
export { fetchWeatherData } from './weatherApi'
export { searchCities, reverseGeocode, debounce } from './geocodingApi'
export { cache, fetchWithCache } from './cache'
</file>

<file path="src/services/sonification.ts">
/**
 * Sonification Service
 * Translates weather data into sound using the Web Audio API.
 */

class SonificationService {
  private audioContext: AudioContext | null = null
  private masterGain: GainNode | null = null
  private oscillators: Map<string, OscillatorNode> = new Map()

  private init() {
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)()
      this.masterGain = this.audioContext.createGain()
      this.masterGain.connect(this.audioContext.destination)
      this.masterGain.gain.value = 0.1 // Default low volume
    }
  }

  public setVolume(volume: number) {
    if (this.masterGain) {
      this.masterGain.gain.setTargetAtTime(volume / 100, this.audioContext!.currentTime, 0.1)
    }
  }

  /**
   * Play a brief tone based on temperature
   */
  public playTemperatureTone(temp: number) {
    this.init()
    if (!this.audioContext || !this.masterGain) return

    const osc = this.audioContext.createOscillator()
    const gain = this.audioContext.createGain()

    // Map temp (-20 to 40) to frequency (200Hz to 800Hz)
    const freq = 200 + ((temp + 20) / 60) * 600
    
    osc.type = 'sine'
    osc.frequency.setValueAtTime(freq, this.audioContext.currentTime)
    
    gain.gain.setValueAtTime(0, this.audioContext.currentTime)
    gain.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.05)
    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5)

    osc.connect(gain)
    gain.connect(this.masterGain)

    osc.start()
    osc.stop(this.audioContext.currentTime + 0.5)
  }

  /**
   * Ambient weather sounds (simulated)
   */
  public updateAmbientWeather(_type: string, _intensity: number) {
    this.init()
    if (!this.audioContext || !this.masterGain) return

    // This is a simplified placeholder. 
    // In a real "award winning" app, you'd use white noise generators 
    // and filters to simulate rain/wind/etc.
  }

  public stopAll() {
    this.oscillators.forEach(osc => osc.stop())
    this.oscillators.clear()
  }
}

export const sonification = new SonificationService()
</file>

<file path="src/stores/index.ts">
export { useWeatherStore } from './weatherStore'
export { useLocationStore } from './locationStore'
export { useSettingsStore } from './settingsStore'
</file>

<file path="src/styles/animations.css">
/* Keyframe Animations */

/* Fade animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Slide animations */
@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

/* Scale animations */
@keyframes scaleIn {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes scaleUp {
  from {
    transform: scale(1);
  }
  to {
    transform: scale(1.05);
  }
}

/* Splash screen animations */
@keyframes logoReveal {
  0% {
    opacity: 0;
    transform: translateY(50px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes lineExpand {
  from { width: 0; }
  to { width: 100px; }
}

/* Floating/ambient animations */
@keyframes float {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

@keyframes pulseSlow {
  0%, 100% {
    opacity: 1;
    transform: scale(1);
  }
  50% {
    opacity: 0.8;
    transform: scale(1.02);
  }
}

/* Shimmer effect for loading states */
@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

/* Rotate */
@keyframes rotate {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes rotateReverse {
  from {
    transform: rotate(360deg);
  }
  to {
    transform: rotate(0deg);
  }
}

/* Weather-specific animations */
@keyframes rain {
  0% {
    transform: translateY(-100%);
  }
  100% {
    transform: translateY(100vh);
  }
}

@keyframes lightning {
  0%, 9%, 11%, 100% {
    opacity: 0;
  }
  10% {
    opacity: 0.8;
  }
}

@keyframes windBlow {
  0%, 100% {
    transform: translateX(0) skewX(0deg);
  }
  50% {
    transform: translateX(5px) skewX(-2deg);
  }
}

@keyframes snowfall {
  0% {
    transform: translateY(-10%) translateX(0);
  }
  50% {
    transform: translateY(50%) translateX(10px);
  }
  100% {
    transform: translateY(110%) translateX(0);
  }
}

/* Graph drawing animation */
@keyframes drawLine {
  from {
    stroke-dashoffset: 1000;
  }
  to {
    stroke-dashoffset: 0;
  }
}

/* Variable font weight shiver (for wind effect) */
@keyframes textShiver {
  0%, 100% {
    font-variation-settings: 'wght' 400;
  }
  25% {
    font-variation-settings: 'wght' 380;
  }
  75% {
    font-variation-settings: 'wght' 420;
  }
}

.animate-text-shiver {
  animation: textShiver 0.3s ease-in-out infinite;
}

/* Utility classes */
.animate-fade-in {
  animation: fadeIn var(--duration-normal) var(--ease-out) forwards;
}

.animate-fade-in-up {
  animation: fadeInUp var(--duration-slow) var(--ease-out) forwards;
}

.animate-fade-in-down {
  animation: fadeInDown var(--duration-slow) var(--ease-out) forwards;
}

.animate-slide-in-right {
  animation: slideInRight var(--duration-slow) var(--ease-out) forwards;
}

.animate-slide-in-left {
  animation: slideInLeft var(--duration-slow) var(--ease-out) forwards;
}

.animate-scale-in {
  animation: scaleIn var(--duration-normal) var(--ease-out-back) forwards;
}

.animate-float {
  animation: float 6s ease-in-out infinite;
}

.animate-pulse-slow {
  animation: pulseSlow 3s ease-in-out infinite;
}

.animate-shimmer {
  background: linear-gradient(
    90deg,
    var(--bg-card) 0%,
    var(--bg-card-hover) 50%,
    var(--bg-card) 100%
  );
  background-size: 200% 100%;
  animation: shimmer 2s linear infinite;
}

.animate-spin {
  animation: rotate 1s linear infinite;
}

.animate-draw-line {
  stroke-dasharray: 1000;
  stroke-dashoffset: 1000;
  animation: drawLine 1.5s ease-out forwards;
}

/* Stagger delays */
.stagger-1 { animation-delay: 0.1s; }
.stagger-2 { animation-delay: 0.2s; }
.stagger-3 { animation-delay: 0.3s; }
.stagger-4 { animation-delay: 0.4s; }
.stagger-5 { animation-delay: 0.5s; }
.stagger-6 { animation-delay: 0.6s; }
.stagger-7 { animation-delay: 0.7s; }
.stagger-8 { animation-delay: 0.8s; }
</file>

<file path="src/types/index.ts">
// Barrel exports
export * from './weather'
export * from './location'
export * from './theme'
</file>

<file path="src/types/location.ts">
// Location Types

export interface City {
  id: string
  name: string
  country: string
  countryCode: string
  latitude: number
  longitude: number
  timezone: string
  population?: number
  admin1?: string // State/Province
}

export interface Coordinates {
  latitude: number
  longitude: number
}

export type Location = Coordinates

export interface GeocodingResult {
  id: number
  name: string
  latitude: number
  longitude: number
  elevation?: number
  feature_code: string
  country_code: string
  country: string
  admin1?: string
  admin2?: string
  admin3?: string
  admin4?: string
  timezone: string
  population?: number
  postcodes?: string[]
  country_id: number
  admin1_id?: number
}

export interface GeocodingResponse {
  results?: GeocodingResult[]
  generationtime_ms: number
}

export interface GeolocationError {
  code: GeolocationPositionError['code']
  message: string
}

// Default cities for quick selection
export const DEFAULT_CITIES: City[] = [
  {
    id: 'rome',
    name: 'Rome',
    country: 'Italy',
    countryCode: 'IT',
    latitude: 41.9028,
    longitude: 12.4964,
    timezone: 'Europe/Rome'
  },
  {
    id: 'paris',
    name: 'Paris',
    country: 'France',
    countryCode: 'FR',
    latitude: 48.8566,
    longitude: 2.3522,
    timezone: 'Europe/Paris'
  },
  {
    id: 'london',
    name: 'London',
    country: 'United Kingdom',
    countryCode: 'GB',
    latitude: 51.5074,
    longitude: -0.1278,
    timezone: 'Europe/London'
  },
  {
    id: 'new-york',
    name: 'New York',
    country: 'United States',
    countryCode: 'US',
    latitude: 40.7128,
    longitude: -74.0060,
    timezone: 'America/New_York'
  },
  {
    id: 'tokyo',
    name: 'Tokyo',
    country: 'Japan',
    countryCode: 'JP',
    latitude: 35.6762,
    longitude: 139.6503,
    timezone: 'Asia/Tokyo'
  },
  {
    id: 'sydney',
    name: 'Sydney',
    country: 'Australia',
    countryCode: 'AU',
    latitude: -33.8688,
    longitude: 151.2093,
    timezone: 'Australia/Sydney'
  }
]
</file>

<file path="src/types/theme.ts">
// Theme Types

export type Theme = 'light' | 'dark' | 'system' | 'terminal'

export type TemperatureUnit = 'celsius' | 'fahrenheit'

export type SpeedUnit = 'kmh' | 'mph' | 'ms'

export type PressureUnit = 'hpa' | 'inhg' | 'mmhg'

export interface ThemeColors {
  bgBody: string
  bgCard: string
  bgCardHover: string
  bgDrawer: string
  bgGlass: string
  textPrimary: string
  textSecondary: string
  textMuted: string
  textInverse: string
  borderDefault: string
  borderStrong: string
  accent: string
}

export interface WeatherColors {
  skyStart: string
  skyEnd: string
  atmosphere: string
  particleColor?: string
}

export interface UserSettings {
  // Appearance
  theme: Theme
  reducedMotion: boolean
  
  // Units
  temperatureUnit: TemperatureUnit
  speedUnit: SpeedUnit
  pressureUnit: PressureUnit
  use24Hour: boolean
  
  // Accessibility
  highContrast: boolean
  sonificationEnabled: boolean
  
  // Audio
  ambientAudioEnabled: boolean
  ambientVolume: number
  
  // Haptics
  hapticsEnabled: boolean
  
  // Data
  autoRefresh: boolean
  refreshInterval: number // minutes
}

export const DEFAULT_SETTINGS: UserSettings = {
  theme: 'system',
  reducedMotion: false,
  temperatureUnit: 'celsius',
  speedUnit: 'kmh',
  pressureUnit: 'hpa',
  use24Hour: true,
  highContrast: false,
  sonificationEnabled: false,
  ambientAudioEnabled: false,
  ambientVolume: 50,
  hapticsEnabled: true,
  autoRefresh: true,
  refreshInterval: 15
}
</file>

<file path="src/utils/animations.ts">
import gsap from 'gsap'

export const fadeIn = (el: Element, duration = 0.5, delay = 0) => {
  return gsap.fromTo(el, 
    { opacity: 0 },
    { opacity: 1, duration, delay, ease: 'power2.out' }
  )
}

export const fadeInUp = (el: Element, duration = 0.6, delay = 0) => {
  return gsap.fromTo(el,
    { opacity: 0, y: 20 },
    { opacity: 1, y: 0, duration, delay, ease: 'power3.out' }
  )
}

export const staggerFadeInUp = (elements: Element[], stagger = 0.1) => {
  return gsap.fromTo(elements,
    { opacity: 0, y: 20 },
    { opacity: 1, y: 0, stagger, duration: 0.5, ease: 'power2.out' }
  )
}

export const slideInRight = (el: Element, duration = 0.5) => {
  return gsap.fromTo(el,
    { x: 50, opacity: 0 },
    { x: 0, opacity: 1, duration, ease: 'expo.out' }
  )
}

export const scaleIn = (el: Element) => {
  return gsap.fromTo(el,
    { scale: 0.8, opacity: 0 },
    { scale: 1, opacity: 1, duration: 0.4, ease: 'back.out(1.7)' }
  )
}
</file>

<file path="src/utils/haptics.ts">
/**
 * Haptic Feedback Utility
 * Uses the Vibration API to provide tactile feedback on supported devices.
 */

export const Haptics = {
  /**
   * Light tap (impact)
   */
  light: () => {
    if ('vibrate' in navigator) {
      navigator.vibrate(10)
    }
  },

  /**
   * Medium tap
   */
  medium: () => {
    if ('vibrate' in navigator) {
      navigator.vibrate(20)
    }
  },

  /**
   * Heavy tap
   */
  heavy: () => {
    if ('vibrate' in navigator) {
      navigator.vibrate(50)
    }
  },

  /**
   * Error/Success patterns
   */
  error: () => {
    if ('vibrate' in navigator) {
      navigator.vibrate([50, 30, 50])
    }
  },

  success: () => {
    if ('vibrate' in navigator) {
      navigator.vibrate([10, 30, 10])
    }
  },

  /**
   * Selection change (very light)
   */
  selection: () => {
    if ('vibrate' in navigator) {
      navigator.vibrate(5)
    }
  }
}
</file>

<file path="src/utils/index.ts">
export * from './weatherCodes'
export * from './formatters'
export * from './constants'
</file>

<file path="src/utils/interpolation.ts">
/**
 * Linear interpolation between two values
 */
export const lerp = (start: number, end: number, t: number): number => {
  return start * (1 - t) + end * t
}

/**
 * Inverse linear interpolation
 * Returns a value between 0 and 1 representing where v lies between a and b
 */
export const invLerp = (a: number, b: number, v: number): number => {
  return (v - a) / (b - a)
}

/**
 * Remap a value from one range to another
 */
export const remap = (
  v: number,
  inMin: number,
  inMax: number,
  outMin: number,
  outMax: number
): number => {
  const t = invLerp(inMin, inMax, v)
  return lerp(outMin, outMax, t)
}

/**
 * Smooth step interpolation
 */
export const smoothStep = (edge0: number, edge1: number, x: number): number => {
  const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)))
  return t * t * (3 - 2 * t)
}

/**
 * Clamp a value between min and max
 */
export const clamp = (value: number, min: number, max: number): number => {
  return Math.min(Math.max(value, min), max)
}
</file>

<file path="src/utils/weatherCodes.test.ts">
import { describe, it, expect } from 'vitest'
 import { getWeatherType, interpolateValue } from './weatherCodes'
 
 describe('getWeatherType', () => {
   it('should return clear for weather code 0', () => {
     expect(getWeatherType(0)).toBe('clear')
   })
 
   it('should return clear for weather code 1', () => {
     expect(getWeatherType(1)).toBe('clear')
   })
 
   it('should return cloudy for weather codes 2-3', () => {
     expect(getWeatherType(2)).toBe('cloudy')
     expect(getWeatherType(3)).toBe('cloudy')
   })
 
   it('should return fog for weather codes 45 and 48', () => {
     expect(getWeatherType(45)).toBe('fog')
     expect(getWeatherType(48)).toBe('fog')
   })
 
   it('should return rain for rain weather codes', () => {
     expect(getWeatherType(61)).toBe('rain')
     expect(getWeatherType(63)).toBe('rain')
     expect(getWeatherType(65)).toBe('rain')
   })
 
   it('should return snow for snow weather codes', () => {
     expect(getWeatherType(71)).toBe('snow')
     expect(getWeatherType(73)).toBe('snow')
     expect(getWeatherType(75)).toBe('snow')
   })
 
   it('should return storm for thunderstorm codes', () => {
     expect(getWeatherType(95)).toBe('storm')
     expect(getWeatherType(96)).toBe('storm')
     expect(getWeatherType(99)).toBe('storm')
   })
 })
 
 describe('interpolateValue', () => {
   it('should return start value when fraction is 0', () => {
     expect(interpolateValue(10, 20, 0)).toBe(10)
   })
 
   it('should return end value when fraction is 1', () => {
     expect(interpolateValue(10, 20, 1)).toBe(20)
   })
 
   it('should return midpoint when fraction is 0.5', () => {
     expect(interpolateValue(10, 20, 0.5)).toBe(15)
   })
 
   it('should handle negative values', () => {
     expect(interpolateValue(-10, 10, 0.5)).toBe(0)
   })
 })
</file>

<file path="src/utils/weatherCodes.ts">
import type { WeatherCode, WeatherType, WeatherCodeInfo } from '@/types'

// WMO Weather Code mappings
export const WEATHER_CODES: Record<WeatherCode, WeatherCodeInfo> = {
  0: { code: 0, description: 'Clear Sky', type: 'clear', icon: 'Sun' },
  1: { code: 1, description: 'Mainly Clear', type: 'clear', icon: 'Sun' },
  2: { code: 2, description: 'Partly Cloudy', type: 'cloudy', icon: 'CloudSun' },
  3: { code: 3, description: 'Overcast', type: 'cloudy', icon: 'Cloud' },
  45: { code: 45, description: 'Foggy', type: 'fog', icon: 'CloudFog' },
  48: { code: 48, description: 'Rime Fog', type: 'fog', icon: 'CloudFog' },
  51: { code: 51, description: 'Light Drizzle', type: 'rain', icon: 'CloudDrizzle' },
  53: { code: 53, description: 'Moderate Drizzle', type: 'rain', icon: 'CloudDrizzle' },
  55: { code: 55, description: 'Dense Drizzle', type: 'rain', icon: 'CloudDrizzle' },
  56: { code: 56, description: 'Light Freezing Drizzle', type: 'rain', icon: 'CloudDrizzle' },
  57: { code: 57, description: 'Dense Freezing Drizzle', type: 'rain', icon: 'CloudDrizzle' },
  61: { code: 61, description: 'Slight Rain', type: 'rain', icon: 'CloudRain' },
  63: { code: 63, description: 'Moderate Rain', type: 'rain', icon: 'CloudRain' },
  65: { code: 65, description: 'Heavy Rain', type: 'rain', icon: 'CloudRainWind' },
  66: { code: 66, description: 'Light Freezing Rain', type: 'rain', icon: 'CloudRain' },
  67: { code: 67, description: 'Heavy Freezing Rain', type: 'rain', icon: 'CloudRainWind' },
  71: { code: 71, description: 'Slight Snow', type: 'snow', icon: 'Snowflake' },
  73: { code: 73, description: 'Moderate Snow', type: 'snow', icon: 'Snowflake' },
  75: { code: 75, description: 'Heavy Snow', type: 'snow', icon: 'Snowflake' },
  77: { code: 77, description: 'Snow Grains', type: 'snow', icon: 'Snowflake' },
  80: { code: 80, description: 'Slight Rain Showers', type: 'rain', icon: 'CloudRain' },
  81: { code: 81, description: 'Moderate Rain Showers', type: 'rain', icon: 'CloudRain' },
  82: { code: 82, description: 'Violent Rain Showers', type: 'storm', icon: 'CloudRainWind' },
  85: { code: 85, description: 'Slight Snow Showers', type: 'snow', icon: 'CloudSnow' },
  86: { code: 86, description: 'Heavy Snow Showers', type: 'snow', icon: 'CloudSnow' },
  95: { code: 95, description: 'Thunderstorm', type: 'storm', icon: 'CloudLightning' },
  96: { code: 96, description: 'Thunderstorm with Hail', type: 'storm', icon: 'CloudLightning' },
  99: { code: 99, description: 'Heavy Thunderstorm', type: 'storm', icon: 'CloudLightning' }
}

export const getWeatherType = (code: WeatherCode): WeatherType => {
  return WEATHER_CODES[code]?.type ?? 'clear'
}

export const getWeatherDescription = (code: WeatherCode): string => {
  return WEATHER_CODES[code]?.description ?? 'Unknown'
}

export const getWeatherIcon = (code: WeatherCode, isDay: boolean = true): string => {
  const info = WEATHER_CODES[code]
  if (!info) return 'Cloud'
  
  // Use moon for clear nights
  if ((code === 0 || code === 1) && !isDay) {
    return 'Moon'
  }
  
  return info.icon
}

// Linear interpolation
export const interpolateValue = (a: number, b: number, t: number): number => {
  return a + (b - a) * t
}

// Clamp value between min and max
export const clamp = (value: number, min: number, max: number): number => {
  return Math.max(min, Math.min(max, value))
}

// Map value from one range to another
export const mapRange = (
  value: number, 
  inMin: number, 
  inMax: number, 
  outMin: number, 
  outMax: number
): number => {
  return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin
}
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  darkMode: ['class', '[data-theme="dark"]'],
  theme: {
    extend: {
      colors: {
        // Base neutrals
        gray: {
          50: '#fafafa',
          100: '#f4f4f5',
          200: '#e4e4e7',
          300: '#d4d4d8',
          400: '#a1a1aa',
          500: '#71717a',
          600: '#52525b',
          700: '#3f3f46',
          800: '#27272a',
          900: '#18181b',
          950: '#09090b',
        },
        // Primary accent
        accent: {
          DEFAULT: '#dc2626',
          light: '#ef4444',
          dark: '#b91c1c',
        },
        // Terminal theme
        terminal: {
          bg: '#0a0a0a',
          text: '#00ff00',
          muted: '#009900',
        },
        // Temperature colors
        temp: {
          freezing: '#60a5fa',
          cold: '#93c5fd',
          cool: '#bfdbfe',
          mild: '#fef3c7',
          warm: '#fcd34d',
          hot: '#f97316',
          extreme: '#dc2626',
        },
      },
      fontFamily: {
        display: ['Playfair Display', 'Georgia', 'Times New Roman', 'serif'],
        body: ['Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'sans-serif'],
        mono: ['JetBrains Mono', 'Fira Code', 'Consolas', 'monospace'],
      },
      fontSize: {
        'hero': 'clamp(3rem, 10vw, 8rem)',
        'display': 'clamp(2rem, 6vw, 4rem)',
      },
      letterSpacing: {
        'mega': '0.2em',
        'ultra': '0.3em',
      },
      animation: {
        'fade-in': 'fadeIn 0.5s ease-out forwards',
        'fade-in-up': 'fadeInUp 0.6s ease-out forwards',
        'slide-in-right': 'slideInRight 0.5s ease-out forwards',
        'pulse-slow': 'pulse 3s ease-in-out infinite',
        'float': 'float 6s ease-in-out infinite',
        'shimmer': 'shimmer 2s linear infinite',
        'draw-line': 'drawLine 1.5s ease-out forwards',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        fadeInUp: {
          '0%': { opacity: '0', transform: 'translateY(20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        slideInRight: {
          '0%': { opacity: '0', transform: 'translateX(20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        float: {
          '0%, 100%': { transform: 'translateY(0)' },
          '50%': { transform: 'translateY(-10px)' },
        },
        shimmer: {
          '0%': { backgroundPosition: '-200% 0' },
          '100%': { backgroundPosition: '200% 0' },
        },
        drawLine: {
          '0%': { strokeDashoffset: '1000' },
          '100%': { strokeDashoffset: '0' },
        },
      },
      backdropBlur: {
        xs: '2px',
      },
      transitionTimingFunction: {
        'out-expo': 'cubic-bezier(0.16, 1, 0.3, 1)',
        'out-back': 'cubic-bezier(0.34, 1.56, 0.64, 1)',
        'in-out-expo': 'cubic-bezier(0.87, 0, 0.13, 1)',
      },
      boxShadow: {
        'glass': '0 8px 32px rgba(0, 0, 0, 0.1)',
        'glass-dark': '0 8px 32px rgba(0, 0, 0, 0.5)',
        'glow': '0 0 20px rgba(220, 38, 38, 0.3)',
        'glow-sun': '0 0 60px rgba(255, 200, 50, 0.4)',
      },
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "skipLibCheck": true,
    "strict": true,
    "types": ["node"]
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.d.ts">
declare const _default: import("vite").UserConfig;
export default _default;
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { VitePWA } from 'vite-plugin-pwa';
import { fileURLToPath, URL } from 'node:url';
// https://vitejs.dev/config/
export default defineConfig({
    base: '/WeatherVue/',
    plugins: [
        vue(),
        VitePWA({
            registerType: 'autoUpdate',
            includeAssets: ['favicon.ico', 'robots.txt', 'apple-touch-icon.png'],
            manifest: {
                name: 'WeatherVue',
                short_name: 'WeatherVue',
                description: 'Award-winning weather application with immersive atmospheric design',
                theme_color: '#000000',
                background_color: '#000000',
                display: 'standalone',
                icons: [
                    {
                        src: 'pwa-192x192.png',
                        sizes: '192x192',
                        type: 'image/png'
                    },
                    {
                        src: 'pwa-512x512.png',
                        sizes: '512x512',
                        type: 'image/png'
                    },
                    {
                        src: 'pwa-512x512.png',
                        sizes: '512x512',
                        type: 'image/png',
                        purpose: 'maskable'
                    }
                ]
            },
            workbox: {
                globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
                runtimeCaching: [
                    {
                        urlPattern: /^https:\/\/api\.open-meteo\.com\/.*/i,
                        handler: 'NetworkFirst',
                        options: {
                            cacheName: 'weather-api-cache',
                            expiration: {
                                maxEntries: 10,
                                maxAgeSeconds: 60 * 5 // 5 minutes
                            },
                            cacheableResponse: {
                                statuses: [0, 200]
                            }
                        }
                    },
                    {
                        urlPattern: /^https:\/\/geocoding-api\.open-meteo\.com\/.*/i,
                        handler: 'CacheFirst',
                        options: {
                            cacheName: 'geocoding-cache',
                            expiration: {
                                maxEntries: 100,
                                maxAgeSeconds: 60 * 60 * 24 * 7 // 1 week
                            }
                        }
                    }
                ]
            }
        })
    ],
    resolve: {
        alias: {
            '@': fileURLToPath(new URL('./src', import.meta.url)),
            '@components': fileURLToPath(new URL('./src/components', import.meta.url)),
            '@composables': fileURLToPath(new URL('./src/composables', import.meta.url)),
            '@stores': fileURLToPath(new URL('./src/stores', import.meta.url)),
            '@services': fileURLToPath(new URL('./src/services', import.meta.url)),
            '@types': fileURLToPath(new URL('./src/types', import.meta.url)),
            '@utils': fileURLToPath(new URL('./src/utils', import.meta.url))
        }
    },
    build: {
        rollupOptions: {
            output: {
                manualChunks: {
                    'three': ['three'],
                    'd3': ['d3'],
                    'gsap': ['gsap'],
                    'vendor': ['vue', 'vue-router', 'pinia']
                }
            }
        }
    }
});
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config'
 import vue from '@vitejs/plugin-vue'
 import { fileURLToPath, URL } from 'node:url'
 
 export default defineConfig({
   plugins: [vue()],
   test: {
     environment: 'happy-dom',
     globals: true,
     include: ['src/**/*.{test,spec}.{js,ts}'],
     coverage: {
       provider: 'v8',
       reporter: ['text', 'json', 'html'],
       exclude: [
         'node_modules/',
         'dist/',
         '**/*.d.ts',
         '**/*.config.*',
         '**/index.ts'
       ]
     }
   },
   resolve: {
     alias: {
       '@': fileURLToPath(new URL('./src', import.meta.url))
     }
   }
 })
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Node modules
node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs
*.njsproj
*.sln
*.sw?

# API config
api-config.js
.env
.env.*
!.env.example

# Build artifacts
tsconfig.tsbuildinfo
tsconfig.node.tsbuildinfo
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="icon" type="image/svg+xml" href="/vite.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="WeatherVue - Award-winning weather application with immersive atmospheric design">
  <meta name="theme-color" content="#000000">
  
  <!-- Open Graph / Social -->
  <meta property="og:title" content="WeatherVue | Atmospheric Weather">
  <meta property="og:description" content="Award-winning weather application with immersive atmospheric design">
  <meta property="og:type" content="website">
  
  <!-- Preload critical fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400&display=swap" rel="stylesheet">
  
  <title>WeatherVue | Atmospheric Weather</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>
</file>

<file path="README.md">
# WeatherVue 2.0

<div align="center">
  <h3>Atmospheric Intelligence for the Modern Age</h3>
  <p>A next-generation weather dashboard featuring glassmorphism, WebGL visualizations, and award-winning UI/UX.</p>
</div>

![WeatherVue Preview](https://github.com/tzii/WeatherVue/raw/feature/award-winning-redesign/docs/preview.png)

## ✨ Features

- **🎨 Award-Winning Design**: Immersive Glassmorphic UI with dynamic, weather-reactive backgrounds (Three.js WebGL).
- **⏱️ Precision Timeline**: Interactive scrubber to travel through time and see 48-hour forecasts instantly.
- **📊 Advanced Visualization**: D3.js powered temperature graphs with gradient fills and interactive inspection.
- **🌍 Global Coverage**: Real-time data from Open-Meteo API for any location on Earth.
- **🌗 Smart Theming**: Automatically adapts to day/night cycles and weather conditions (Rain, Snow, Clear, etc.).
- **⚡ Performance First**: Built with Vite + Vue 3 for blazing fast load times and smooth 60fps animations.
- **📱 Fully Responsive**: Optimized experience across mobile, tablet, and desktop.
- **♿ Accessible**: Full keyboard navigation, screen reader support, and "Terminal" high-contrast theme.

## 🛠️ Tech Stack

- **Framework**: [Vue 3](https://vuejs.org/) (Composition API, Script Setup)
- **State Management**: [Pinia](https://pinia.vuejs.org/)
- **Build Tool**: [Vite](https://vitejs.dev/)
- **Styling**: [Tailwind CSS](https://tailwindcss.com/) + Custom CSS Variables
- **Visualizations**: [D3.js](https://d3js.org/) (Charts), [Three.js](https://threejs.org/) (Backgrounds)
- **Animations**: [GSAP](https://greensock.com/gsap/)
- **Icons**: [Lucide Vue](https://lucide.dev/)
- **Data Source**: [Open-Meteo API](https://open-meteo.com/)

## 🚀 Getting Started

### Prerequisites

- Node.js 18+
- npm or pnpm

### Installation

1.  **Clone the repository**

    ```bash
    git clone https://github.com/tzii/WeatherVue.git
    cd WeatherVue
    ```

2.  **Install dependencies**

    ```bash
    npm install
    ```

3.  **Start development server**

    ```bash
    npm run dev
    ```

4.  **Build for production**
    ```bash
    npm run build
    ```

## ⚙️ Configuration

Create a `.env` file in the root directory to configure optional services (like Azure Translation):

```env
VITE_AZURE_TRANSLATOR_KEY=your_key_here
VITE_AZURE_TRANSLATOR_REGION=eastus
```

_Note: The core weather functionality works out-of-the-box without any API keys!_

## 📂 Project Structure

```
src/
├── components/        # Vue components
│   ├── canvas/        # WebGL/Three.js background effects
│   ├── weather/       # Weather visualization components (Graphs, Forecasts)
│   └── ui/            # Reusable UI elements (Cards, Buttons)
├── composables/       # Shared logic (Hooks)
├── stores/            # Pinia state stores
├── services/          # API integrations
├── styles/            # Global CSS & Tailwind config
└── utils/             # Helper functions & constants
```

## 🤝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## 📄 License

This project is open source and available under the [MIT License](LICENSE).
</file>

<file path="src/components/canvas/ParticleSystem.ts">
import * as THREE from 'three'
import vertexShader from './shaders/rain.vert?raw'
import fragmentShader from './shaders/rain.frag?raw'

export interface ParticleConfig {
  count: number
  color: number
  speed: number
  range: { x: number; y: number; z: number }
  size: number
}

export class ParticleSystem {
  mesh: THREE.Points
  geometry: THREE.BufferGeometry
  material: THREE.ShaderMaterial
  private count: number
  // private rangeY: number // Removed unused

  constructor(config: ParticleConfig) {
    this.count = config.count
    // this.rangeY = config.range.y // Removed unused

    // Geometry
    this.geometry = new THREE.BufferGeometry()
    const positions = new Float32Array(this.count * 3)
    const speeds = new Float32Array(this.count)
    const velocities = new Float32Array(this.count * 3)

    for (let i = 0; i < this.count; i++) {
      const i3 = i * 3
      positions[i3] = (Math.random() - 0.5) * config.range.x
      positions[i3 + 1] = (Math.random() - 0.5) * config.range.y
      positions[i3 + 2] = (Math.random() - 0.5) * config.range.z

      speeds[i] = config.speed * (0.5 + Math.random() * 0.5)
      
      // Slight wind variation
      velocities[i3] = (Math.random() - 0.5) * 2
      velocities[i3 + 1] = -1 // Falling down
      velocities[i3 + 2] = (Math.random() - 0.5) * 2
    }

    this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
    this.geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1))
    this.geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3))

    // Material
    this.material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      uniforms: {
        time: { value: 0 },
        color: { value: new THREE.Color(config.color) },
        rangeY: { value: config.range.y }
      },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    })

    this.mesh = new THREE.Points(this.geometry, this.material)
  }

  update(deltaTime: number) {
    const timeUniform = this.material.uniforms['time']
    if (timeUniform) {
      timeUniform.value += deltaTime
    }
  }

  setColor(color: number) {
    const colorUniform = this.material.uniforms['color']
    if (colorUniform) {
      colorUniform.value.setHex(color)
    }
  }

  setSpeed(_speed: number) {
    // Requires rebuilding buffer or attribute update, usually overkill for simple weather changes
    // Alternatively, update a uniform multiplier
  }

  dispose() {
    this.geometry.dispose()
    this.material.dispose()
  }
}
</file>

<file path="src/components/search/CitySearch.vue">
<script setup lang="ts">
import { ref, watch } from 'vue'
import { Search, MapPin, Loader2, X, Navigation } from 'lucide-vue-next'
import { searchCities, debounce, reverseGeocode } from '@/services/geocodingApi'
import { useLocationStore } from '@/stores/locationStore'
import { useGeolocation } from '@/composables/useGeolocation'
import type { City } from '@/types'

const locationStore = useLocationStore()
const { updateLocation, coords, loading: geoLoading } = useGeolocation()

const query = ref('')
const results = ref<City[]>([])
const isSearching = ref(false)
const showResults = ref(false)

const performSearch = async (val: string) => {
  if (val.length < 2) {
    results.value = []
    isSearching.value = false
    return
  }

  isSearching.value = true
  try {
    results.value = await searchCities(val)
  } catch (error) {
    console.error('Search failed:', error)
  } finally {
    isSearching.value = false
  }
}

const debouncedSearch = debounce(performSearch, 300)

watch(query, (newVal) => {
  showResults.value = true
  debouncedSearch(newVal)
})

const selectCity = (city: City) => {
  locationStore.setCurrentCity(city)
  query.value = ''
  showResults.value = false
}

const handleUseLocation = async () => {
  await updateLocation()
  if (coords.value) {
    const city = await reverseGeocode(coords.value.latitude, coords.value.longitude)
    if (city) {
      locationStore.setCurrentCity(city)
      query.value = ''
      showResults.value = false
    }
  }
}

const clearSearch = () => {
  query.value = ''
  results.value = []
}
</script>

<template>
  <div class="city-search relative w-full max-w-2xl mx-auto">
    <div class="relative group">
      <div class="absolute inset-y-0 left-4 flex items-center pointer-events-none">
        <Search class="w-5 h-5 transition-colors group-focus-within:text-accent" style="color: var(--text-muted)" />
      </div>
      
      <input
        v-model="query"
        type="text"
        placeholder="Search for a city..."
        class="w-full h-14 pl-12 pr-24 bg-transparent border-b-2 transition-all outline-none font-display text-xl"
        style="border-color: var(--border-default)"
        @focus="showResults = true"
      />
      
      <div class="absolute inset-y-0 right-4 flex items-center gap-2">
        <button 
          v-if="!query"
          @click="handleUseLocation"
          class="p-2 hover:text-accent transition-colors relative group/tooltip"
          :disabled="geoLoading"
          aria-label="Use my current location"
        >
          <Navigation v-if="!geoLoading" class="w-5 h-5" :class="{ 'animate-pulse': geoLoading }" style="color: var(--text-muted)" />
          <Loader2 v-else class="w-5 h-5 animate-spin" style="color: var(--accent)" />
          <span class="absolute -top-10 left-1/2 -translate-x-1/2 px-2 py-1 bg-black text-white text-[10px] rounded opacity-0 group-hover/tooltip:opacity-100 transition-opacity whitespace-nowrap">
            Current Location
          </span>
        </button>
        <Loader2 v-if="isSearching" class="w-5 h-5 animate-spin" style="color: var(--accent)" />
        <button v-else-if="query" @click="clearSearch">
          <X class="w-5 h-5 hover:text-accent transition-colors" style="color: var(--text-muted)" />
        </button>
      </div>
    </div>

    <!-- Results Dropdown -->
    <Transition
      enter-active-class="transition duration-200 ease-out"
      enter-from-class="translate-y-2 opacity-0"
      enter-to-class="translate-y-0 opacity-100"
      leave-active-class="transition duration-150 ease-in"
      leave-from-class="translate-y-0 opacity-100"
      leave-to-class="translate-y-2 opacity-0"
    >
      <div
        v-if="showResults && results.length > 0"
        class="absolute top-full left-0 right-0 mt-2 z-50 overflow-hidden rounded-xl border shadow-2xl"
        style="background: var(--bg-card); border-color: var(--border-default)"
      >
        <ul class="py-2">
          <li v-for="city in results" :key="city.id">
            <button
              class="w-full flex items-center px-4 py-3 hover:bg-accent/10 transition-colors text-left"
              @click="selectCity(city)"
            >
              <MapPin class="w-4 h-4 mr-3 opacity-50" />
              <div>
                <span class="font-bold">{{ city.name }}</span>
                <span class="ml-2 text-xs opacity-60">{{ city.admin1 }}, {{ city.country }}</span>
              </div>
            </button>
          </li>
        </ul>
      </div>
    </Transition>
  </div>
</template>

<style scoped>
input:focus {
  border-color: var(--accent);
}
</style>
</file>

<file path="src/components/weather/CurrentWeather.vue">
<script setup lang="ts">
import { computed } from 'vue'
import { MapPin } from 'lucide-vue-next'
import { useWeatherStore, useLocationStore, useSettingsStore } from '@/stores'
import { formatTemperature } from '@/utils/formatters'
import { getWeatherDescription, getWeatherIcon } from '@/utils/weatherCodes'
import AnimatedNumber from '@/components/ui/AnimatedNumber.vue'
import WeatherIcon from '@/components/ui/WeatherIcon.vue'

const weatherStore = useWeatherStore()
const locationStore = useLocationStore()
const settingsStore = useSettingsStore()

const current = computed(() => weatherStore.displayWeather)

const temperature = computed(() => {
  if (!current.value) return 0
  return settingsStore.temperatureUnit === 'fahrenheit'
    ? (current.value.temperature * 9) / 5 + 32
    : current.value.temperature
})

const feelsLike = computed(() => {
  if (!current.value) return ''
  return formatTemperature(current.value.feelsLike, settingsStore.temperatureUnit)
})

const condition = computed(() => {
  if (!current.value) return ''
  return getWeatherDescription(current.value.weatherCode)
})

const iconName = computed(() => {
  if (!current.value) return 'Cloud'
  return getWeatherIcon(current.value.weatherCode, current.value.isDay)
})

const isDay = computed(() => current.value?.isDay ?? true)
</script>

<template>
  <section v-if="current" class="current-weather" aria-labelledby="current-weather-heading">
    <!-- Location -->
    <div class="flex items-center gap-2 mb-4">
      <MapPin class="w-4 h-4 text-accent" aria-hidden="true" />
      <span class="text-xs font-bold uppercase tracking-[0.2em]" style="color: var(--text-muted)">
        {{ locationStore.cityDisplayName }}
      </span>
    </div>

    <h2 id="current-weather-heading" class="sr-only">Current Weather</h2>

    <!-- Main temperature display -->
    <div class="flex flex-col md:flex-row md:items-end gap-4 md:gap-12">
      <!-- Temperature -->
      <div class="temperature" :class="{ 'animate-text-shiver': (current?.windSpeed ?? 0) > 20 }">
        <span
          class="font-display text-hero font-black tracking-tight leading-none"
          style="color: var(--text-primary)"
        >
          <AnimatedNumber :value="Math.round(temperature)" />
        </span>
        <span class="text-4xl md:text-6xl font-display mb-4 md:mb-12" style="color: var(--accent)">
          {{ settingsStore.temperatureUnit === 'celsius' ? '°C' : '°F' }}
        </span>
      </div>

      <!-- Condition -->
      <div class="condition pb-4 md:pb-12">
        <div class="flex items-center gap-4 mb-2">
          <WeatherIcon
            :name="iconName"
            class="w-12 h-12 md:w-20 md:h-20"
            style="color: var(--text-primary)"
          />
          <p
            class="text-2xl md:text-4xl font-display font-bold italic"
            style="color: var(--text-primary)"
          >
            {{ condition }}
          </p>
        </div>
        <p
          class="text-sm md:text-base uppercase tracking-widest font-bold"
          style="color: var(--text-muted)"
        >
          Feels like {{ feelsLike }} &middot; {{ isDay ? 'Daytime' : 'Night' }}
        </p>
      </div>
    </div>
  </section>
</template>

<style scoped>
.temperature {
  display: flex;
  align-items: flex-start;
}
</style>
</file>

<file path="src/components/weather/HourlyForecast.vue">
<script setup lang="ts">
import { computed, ref } from 'vue'
import { useWeatherStore, useSettingsStore } from '@/stores'
import { formatTemperature, formatTime } from '@/utils/formatters'
import { getWeatherIcon } from '@/utils/weatherCodes'
import WeatherIcon from '@/components/ui/WeatherIcon.vue'

const weatherStore = useWeatherStore()
const settingsStore = useSettingsStore()

const scrollContainer = ref<HTMLElement | null>(null)

// Get next 24 hours
const hours = computed(() => {
  const selectedIndex = weatherStore.selectedDayIndex

  // We only have 48 hours of data, covering today (index 0) and tomorrow (index 1)
  if (selectedIndex > 1) return []

  const selectedDate = weatherStore.daily[selectedIndex]?.date
  if (!selectedDate) return []

  return weatherStore.hourly.filter(h => h.time.startsWith(selectedDate))
})

// Find current hour index (only relevant for today)
const currentHourIndex = computed(() => {
  if (weatherStore.selectedDayIndex !== 0) return -1

  const now = new Date()
  return hours.value.findIndex(h => {
    const hourTime = new Date(h.time)
    return hourTime.getHours() === now.getHours()
  })
})
</script>

<template>
  <section class="hourly-forecast" aria-labelledby="hourly-heading">
    <h3
      id="hourly-heading"
      class="text-xs font-bold uppercase tracking-[0.2em] mb-4"
      style="color: var(--accent)"
    >
      {{ weatherStore.selectedDayIndex === 0 ? 'Hourly Forecast' : '24-Hour Forecast' }}
    </h3>

    <div v-if="hours.length === 0" class="text-center py-8 text-muted text-sm">
      Hourly data not available for this date
    </div>

    <div
      v-else
      ref="scrollContainer"
      class="flex gap-3 overflow-x-auto pb-4 -mx-4 px-4 scroll-smooth snap-x snap-mandatory mask-scroll"
      role="list"
      aria-label="24-hour forecast"
    >
      <div
        v-for="(hour, index) in hours"
        :key="hour.time"
        class="hour-card flex-shrink-0 snap-start"
        :class="{ current: index === currentHourIndex }"
        role="listitem"
        :aria-current="index === currentHourIndex ? 'time' : undefined"
      >
        <!-- Time -->
        <span class="time">
          {{ index === currentHourIndex ? 'Now' : formatTime(hour.time, settingsStore.use24Hour) }}
        </span>

        <!-- Icon -->
        <WeatherIcon :name="getWeatherIcon(hour.weatherCode, hour.isDay)" class="w-8 h-8 my-3" />

        <!-- Temperature -->
        <span class="temp">
          {{ formatTemperature(hour.temperature, settingsStore.temperatureUnit, false) }}°
        </span>

        <!-- Precipitation -->
        <span v-if="hour.precipitationProbability > 0" class="precip">
          {{ hour.precipitationProbability }}%
        </span>
      </div>
    </div>
  </section>
</template>

<style scoped>
.hour-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  min-width: 80px;
  border: 1px solid var(--border-default);
  border-radius: 0.5rem;
  background: var(--bg-glass);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  transition: all 0.2s ease;
}

.hour-card:hover {
  border-color: var(--accent);
  transform: translateY(-2px);
}

.hour-card.current {
  border-color: var(--accent);
  background: var(--accent);
}

.hour-card.current .time,
.hour-card.current .temp {
  color: white;
}

.time {
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-muted);
}

.temp {
  font-family: theme('fontFamily.display');
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-primary);
}

.precip {
  font-size: 0.65rem;
  font-weight: 600;
  color: #60a5fa;
  margin-top: 0.25rem;
}

/* Hide scrollbar but keep functionality */
.overflow-x-auto {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.overflow-x-auto::-webkit-scrollbar {
  display: none;
}

.mask-scroll {
  mask-image: linear-gradient(to right, black calc(100% - 40px), transparent 100%);
  -webkit-mask-image: linear-gradient(to right, black calc(100% - 40px), transparent 100%);
}
</style>
</file>

<file path="src/components/weather/PrecipitationBar.vue">
<script setup lang="ts">
import { computed } from "vue";
import { Droplets } from "lucide-vue-next";

interface Props {
  probability: number;
  amount?: number;
}

const props = defineProps<Props>();

const height = computed(() => `${props.probability}%`);
</script>

<template>
  <div class="precip-bar flex flex-col items-center">
    <h3
      class="text-xs font-bold uppercase tracking-widest mb-6"
      style="color: var(--text-muted)"
    >
      Precipitation
    </h3>

    <div
      class="relative w-12 h-32 bg-card rounded-xl border border-default overflow-hidden"
    >
      <!-- Grid lines -->
      <div
        class="absolute inset-0 flex flex-col justify-between py-4 pointer-events-none opacity-20"
      >
        <div class="border-t border-muted w-full" />
        <div class="border-t border-muted w-full" />
        <div class="border-t border-muted w-full" />
      </div>

      <!-- Fill -->
      <div
        class="absolute bottom-0 left-0 right-0 bg-accent transition-all duration-1000 ease-out flex items-start justify-center pt-2"
        :style="{
          height,
          background:
            'linear-gradient(to top, var(--accent), var(--accent-light))',
        }"
      >
        <Droplets class="w-3 h-3 text-white opacity-50" />
      </div>
    </div>

    <div class="text-center mt-4">
      <span class="text-xl font-bold font-display"
        >{{ Math.round(probability) }}%</span
      >
      <p
        v-if="amount !== undefined"
        class="text-[10px] uppercase font-bold tracking-widest text-muted"
      >
        {{ amount.toFixed(1) }} mm
      </p>
    </div>
  </div>
</template>

<style scoped>
.bg-card {
  background-color: var(--bg-card);
}
.border-default {
  border-color: var(--border-default);
}
.text-muted {
  color: var(--text-muted);
}
.border-muted {
  border-color: var(--text-muted);
}
</style>
</file>

<file path="src/components/weather/SunriseSunsetArc.vue">
<script setup lang="ts">
import { computed } from 'vue'
import { Sun, Moon } from 'lucide-vue-next'
import { formatTime } from '@/utils/formatters'
import { useSettingsStore } from '@/stores'

interface Props {
  sunrise: string
  sunset: string
  currentTime?: string
}

const props = defineProps<Props>()
const settingsStore = useSettingsStore()

const sunriseTime = computed(() => new Date(props.sunrise))
const sunsetTime = computed(() => new Date(props.sunset))
const now = computed(() => (props.currentTime ? new Date(props.currentTime) : new Date()))

const progress = computed(() => {
  const total = sunsetTime.value.getTime() - sunriseTime.value.getTime()
  const elapsed = now.value.getTime() - sunriseTime.value.getTime()
  return Math.max(0, Math.min(1, elapsed / total))
})

const isDaylight = computed(() => {
  return now.value >= sunriseTime.value && now.value <= sunsetTime.value
})

const formattedSunrise = computed(() => formatTime(props.sunrise, settingsStore.use24Hour))
const formattedSunset = computed(() => formatTime(props.sunset, settingsStore.use24Hour))

// Path for the arc
const arcPath = 'M 10,90 A 80,80 0 0 1 170,90'

// Calculate point on arc
const getPointOnArc = (p: number) => {
  const angle = Math.PI + p * Math.PI
  const radius = 80
  const centerX = 90
  const centerY = 90
  return {
    x: centerX + radius * Math.cos(angle),
    y: centerY + radius * Math.sin(angle)
  }
}

const sunPos = computed(() => getPointOnArc(progress.value))
</script>

<template>
  <div class="sunrise-sunset-arc flex flex-col items-center">
    <h3 class="text-xs font-bold uppercase tracking-widest mb-6" style="color: var(--text-muted)">
      Sunrise & Sunset
    </h3>

    <div class="relative w-full max-w-[200px] aspect-[4/3]">
      <svg viewBox="0 0 180 130" class="w-full h-full">
        <!-- Background Arc -->
        <path
          :d="arcPath"
          fill="none"
          stroke="var(--border-default)"
          stroke-width="2"
          stroke-dasharray="4,4"
        />

        <!-- Progress Arc -->
        <path
          v-if="isDaylight"
          :d="arcPath"
          fill="none"
          stroke="var(--accent)"
          stroke-width="3"
          :stroke-dasharray="`${progress * 251.3} 251.3`"
        />

        <!-- Sun/Moon Icon on Arc -->
        <g
          :transform="`translate(${sunPos.x - 8}, ${sunPos.y - 8})`"
          class="transition-all duration-1000"
        >
          <circle
            cx="8"
            cy="8"
            r="10"
            :fill="isDaylight ? 'var(--accent)' : 'var(--text-muted)'"
            opacity="0.2"
          />
          <Sun v-if="isDaylight" class="w-4 h-4" style="color: var(--accent)" />
          <Moon v-else class="w-4 h-4" style="color: var(--text-muted)" />
        </g>

        <!-- Horizon Line -->
        <line x1="0" y1="90" x2="180" y2="90" stroke="var(--border-default)" stroke-width="1" />
      </svg>

      <!-- Time Labels -->
      <div class="absolute bottom-0 left-0 flex flex-col items-start">
        <span class="text-[10px] uppercase font-bold text-muted">Sunrise</span>
        <span class="text-xs font-bold">{{ formattedSunrise }}</span>
      </div>

      <div class="absolute bottom-0 right-0 flex flex-col items-end">
        <span class="text-[10px] uppercase font-bold text-muted">Sunset</span>
        <span class="text-xs font-bold">{{ formattedSunset }}</span>
      </div>
    </div>
  </div>
</template>

<style scoped>
.text-muted {
  color: var(--text-muted);
}
</style>
</file>

<file path="src/components/weather/TimelineScrubber.vue">
<script setup lang="ts">
import { ref, computed } from 'vue'
import { useWeatherStore, useSettingsStore } from '@/stores'
import { formatTime, formatTemperature } from '@/utils/formatters'
import { Haptics } from '@/utils/haptics'
import { sonification } from '@/services/sonification'

const weatherStore = useWeatherStore()
const settingsStore = useSettingsStore()

const isDragging = ref(false)
const trackRef = ref<HTMLElement | null>(null)

const position = computed({
  get: () => weatherStore.timelinePosition,
  set: (val) => {
    const oldVal = weatherStore.timelinePosition
    weatherStore.setTimelinePosition(val)
    
    // Provide haptic and audio feedback for every 1-hour step change
    const totalHours = weatherStore.hourly.length - 1
    if (totalHours > 0) {
      const oldHour = Math.round(oldVal * totalHours)
      const newHour = Math.round(val * totalHours)
      
      if (oldHour !== newHour) {
        if (settingsStore.hapticsEnabled) {
          Haptics.selection()
        }
        
        if (settingsStore.sonificationEnabled) {
          const hourData = weatherStore.hourly[newHour]
          if (hourData) {
            sonification.playTemperatureTone(hourData.temperature)
          }
        }
      }
    }
  }
})

// Time display for current position
const timeAtPosition = computed(() => {
  if (weatherStore.hourly.length === 0) return ''
  
  const index = Math.floor(position.value * (weatherStore.hourly.length - 1))
  const hour = weatherStore.hourly[index]
  if (!hour) return ''
  
  return formatTime(hour.time, settingsStore.use24Hour)
})

// Temperature at current position
const tempAtPosition = computed(() => {
  const interpolated = weatherStore.interpolatedWeather
  if (!interpolated) return ''
  
  return formatTemperature(
    interpolated.temperature,
    settingsStore.temperatureUnit,
    false
  )
})

// Handle drag
const updatePosition = (clientX: number) => {
  if (!trackRef.value) return
  
  const rect = trackRef.value.getBoundingClientRect()
  const x = clientX - rect.left
  const newPosition = Math.max(0, Math.min(1, x / rect.width))
  position.value = newPosition
}

const handleMouseDown = (e: MouseEvent) => {
  isDragging.value = true
  updatePosition(e.clientX)
  
  const handleMouseMove = (e: MouseEvent) => {
    updatePosition(e.clientX)
  }
  
  const handleMouseUp = () => {
    isDragging.value = false
    document.removeEventListener('mousemove', handleMouseMove)
    document.removeEventListener('mouseup', handleMouseUp)
  }
  
  document.addEventListener('mousemove', handleMouseMove)
  document.addEventListener('mouseup', handleMouseUp)
}

const handleTouchStart = (e: TouchEvent) => {
  isDragging.value = true
  const touch = e.touches[0]
  if (touch) {
    updatePosition(touch.clientX)
  }
}

const handleTouchMove = (e: TouchEvent) => {
  if (isDragging.value) {
    const touch = e.touches[0]
    if (touch) {
      updatePosition(touch.clientX)
    }
  }
}

const handleTouchEnd = () => {
  isDragging.value = false
}

// Keyboard navigation
const handleKeydown = (e: KeyboardEvent) => {
  const step = 1 / (weatherStore.hourly.length - 1)
  
  switch (e.key) {
    case 'ArrowLeft':
    case 'ArrowDown':
      e.preventDefault()
      position.value = Math.max(0, position.value - step)
      break
    case 'ArrowRight':
    case 'ArrowUp':
      e.preventDefault()
      position.value = Math.min(1, position.value + step)
      break
    case 'Home':
      e.preventDefault()
      position.value = 0
      break
    case 'End':
      e.preventDefault()
      position.value = 1
      break
  }
}

// Reset to current time
const resetToNow = () => {
  weatherStore.resetTimelineToNow()
}
</script>

<template>
  <section 
    class="timeline-scrubber"
    aria-labelledby="timeline-heading"
  >
    <div class="flex justify-between items-center mb-4">
      <h3 
        id="timeline-heading"
        class="text-xs font-bold uppercase tracking-[0.2em]"
        style="color: var(--accent)"
      >
        Timeline
      </h3>
      
      <button
        @click="resetToNow"
        class="text-xs uppercase tracking-wider hover:text-accent transition-colors"
        style="color: var(--text-muted)"
      >
        Reset to Now
      </button>
    </div>
    
    <!-- Current time/temp display -->
    <div class="text-center mb-6">
      <span 
        class="font-display text-5xl font-bold"
        style="color: var(--text-primary)"
      >
        {{ tempAtPosition }}°
      </span>
      <span 
        class="block text-sm mt-1"
        style="color: var(--text-muted)"
      >
        {{ timeAtPosition }}
      </span>
    </div>
    
    <!-- Track -->
    <div 
      ref="trackRef"
      class="track relative h-12 cursor-pointer"
      role="slider"
      :aria-valuenow="Math.round(position * 100)"
      aria-valuemin="0"
      aria-valuemax="100"
      aria-label="Timeline scrubber"
      tabindex="0"
      @mousedown="handleMouseDown"
      @touchstart.passive="handleTouchStart"
      @touchmove.passive="handleTouchMove"
      @touchend="handleTouchEnd"
      @keydown="handleKeydown"
    >
      <!-- Background -->
      <div class="absolute inset-0 bg-gradient-to-r from-blue-500/20 via-yellow-500/20 to-orange-500/20 rounded" />
      
      <!-- Progress -->
      <div 
        class="absolute inset-y-0 left-0 bg-accent/30 rounded-l"
        :style="{ width: `${position * 100}%` }"
      />
      
      <!-- Thumb -->
      <div 
        class="thumb absolute top-1/2 -translate-y-1/2 -translate-x-1/2 w-6 h-6 bg-accent rounded-full shadow-lg transition-transform"
        :class="{ 'scale-125': isDragging }"
        :style="{ left: `${position * 100}%` }"
      >
        <div class="absolute inset-0 rounded-full bg-white/30 animate-ping" v-if="isDragging" />
      </div>
      
      <!-- Time markers -->
      <div class="absolute -bottom-6 left-0 right-0 flex justify-between text-xs" style="color: var(--text-muted)">
        <span>Now</span>
        <span>+12h</span>
        <span>+24h</span>
        <span>+36h</span>
        <span>+48h</span>
      </div>
    </div>
  </section>
</template>

<style scoped>
.track:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 4px;
}

.thumb {
  cursor: grab;
}

.thumb:active {
  cursor: grabbing;
}
</style>
</file>

<file path="src/components/weather/UVIndexGauge.vue">
<script setup lang="ts">
import { computed } from "vue";

interface Props {
  value: number;
}

const props = defineProps<Props>();

const uvLevel = computed(() => {
  if (props.value < 3) return { label: "Low", color: "#10b981" };
  if (props.value < 6) return { label: "Moderate", color: "#f59e0b" };
  if (props.value < 8) return { label: "High", color: "#ef4444" };
  if (props.value < 11) return { label: "Very High", color: "#dc2626" };
  return { label: "Extreme", color: "#7c3aed" };
});

// SVG Configuration
const radius = 40;
const strokeWidth = 12;
const circumference = Math.PI * radius; // Semi-circle circumference

const progressOffset = computed(() => {
  const p = Math.min(props.value / 12, 1);
  return circumference * (1 - p);
});

const needleRotation = computed(() => {
  const p = Math.min(props.value / 12, 1);
  return -90 + p * 180;
});
</script>

<template>
  <div class="uv-gauge flex flex-col items-center">
    <h3
      class="text-xs font-bold uppercase tracking-widest mb-6"
      style="color: var(--text-muted)"
    >
      UV Index
    </h3>

    <div class="relative w-32 h-20 overflow-hidden">
      <!-- SVG Gauge -->
      <svg viewBox="0 0 100 55" class="w-full h-full overflow-visible">
        <!-- Background Track -->
        <path
          d="M 10 50 A 40 40 0 0 1 90 50"
          fill="none"
          stroke="var(--border-default)"
          :stroke-width="strokeWidth"
          stroke-linecap="round"
        />

        <!-- Colored Progress -->
        <path
          d="M 10 50 A 40 40 0 0 1 90 50"
          fill="none"
          :stroke="uvLevel.color"
          :stroke-width="strokeWidth"
          stroke-linecap="round"
          :stroke-dasharray="circumference"
          :stroke-dashoffset="progressOffset"
          class="transition-all duration-1000 ease-out opacity-80"
        />
      </svg>

      <!-- Needle -->
      <div
        class="absolute bottom-0 left-1/2 -translate-x-1/2 w-1 h-14 origin-bottom transition-transform duration-1000 ease-out"
        :style="{ transform: `translateX(-50%) rotate(${needleRotation}deg)` }"
      >
        <div
          class="w-full h-full bg-primary rounded-full shadow-lg"
          :style="{ backgroundColor: uvLevel.color }"
        />
      </div>
    </div>

    <div class="text-center mt-2">
      <span class="text-2xl font-bold font-display">{{
        Math.round(value)
      }}</span>
      <p
        class="text-[10px] uppercase font-bold tracking-widest"
        :style="{ color: uvLevel.color }"
      >
        {{ uvLevel.label }}
      </p>
    </div>
  </div>
</template>

<style scoped>
/* No specific styles needed as we use Tailwind classes */
</style>
</file>

<file path="src/components/weather/WindCompass.vue">
<script setup lang="ts">
import { computed } from 'vue'
import { Wind } from 'lucide-vue-next'
import { useSettingsStore } from '@/stores'
import { formatWindSpeed } from '@/utils/formatters'

interface Props {
  speed: number
  direction: number
}

const props = defineProps<Props>()
const settingsStore = useSettingsStore()

const rotationStyle = computed(() => ({
  transform: `rotate(${props.direction}deg)`
}))

const displaySpeed = computed(() => {
  return formatWindSpeed(props.speed, settingsStore.speedUnit, false)
})

const unitLabel = computed(() => {
  switch (settingsStore.speedUnit) {
    case 'mph':
      return 'mph'
    case 'ms':
      return 'm/s'
    default:
      return 'km/h'
  }
})
</script>

<template>
  <div class="wind-compass flex flex-col items-center">
    <h3 class="text-xs font-bold uppercase tracking-[0.2em] mb-6" style="color: var(--accent)">
      Wind
    </h3>

    <div
      class="relative w-32 h-32 flex items-center justify-center rounded-full border border-dashed"
      style="border-color: var(--border-default)"
    >
      <!-- Direction arrow -->
      <div
        class="absolute inset-0 flex items-center justify-center transition-transform duration-700 ease-out"
        :style="rotationStyle"
      >
        <div class="w-1 h-16 bg-accent rounded-full relative">
          <div
            class="absolute -top-1 left-1/2 -translate-x-1/2 w-0 h-0 border-l-[6px] border-r-[6px] border-b-[10px] border-l-transparent border-r-transparent border-b-accent"
          />
        </div>
      </div>

      <!-- Center display -->
      <div class="z-10 bg-body rounded-full p-2 text-center">
        <Wind class="w-5 h-5 mx-auto mb-1" style="color: var(--text-secondary)" />
        <span class="text-xl font-bold font-display leading-none block">
          {{ displaySpeed }}
        </span>
        <span class="text-[10px] uppercase tracking-tighter" style="color: var(--text-muted)">
          {{ unitLabel }}
        </span>
      </div>

      <!-- Compass points -->
      <span class="absolute top-1 text-[10px] font-bold" style="color: var(--text-muted)">N</span>
      <span class="absolute right-1 text-[10px] font-bold" style="color: var(--text-muted)">E</span>
      <span class="absolute bottom-1 text-[10px] font-bold" style="color: var(--text-muted)"
        >S</span
      >
      <span class="absolute left-1 text-[10px] font-bold" style="color: var(--text-muted)">W</span>
    </div>
  </div>
</template>

<style scoped>
.bg-body {
  background-color: var(--bg-body);
}
</style>
</file>

<file path="src/services/geocodingApi.ts">
import type { City, GeocodingResponse, GeocodingResult } from '@/types'
import { API_ENDPOINTS } from '@/utils/constants'

export const searchCities = async (
  query: string,
  count: number = 10,
  language: string = 'en'
): Promise<City[]> => {
  if (!query || query.length < 2) {
    return []
  }
  
  const params = new URLSearchParams({
    name: query,
    count: count.toString(),
    language,
    format: 'json'
  })
  
  const response = await fetch(`${API_ENDPOINTS.GEOCODING}?${params}`)
  
  if (!response.ok) {
    throw new Error(`Geocoding API error: ${response.statusText}`)
  }
  
  const data: GeocodingResponse = await response.json()
  
  if (!data.results) {
    return []
  }
  
  return data.results.map(transformGeocodingResult)
}

const transformGeocodingResult = (result: GeocodingResult): City => {
  const city: City = {
    id: `${result.id}`,
    name: result.name,
    country: result.country,
    countryCode: result.country_code,
    latitude: result.latitude,
    longitude: result.longitude,
    timezone: result.timezone
  }
  
  if (result.population !== undefined) {
    city.population = result.population
  }
  
  if (result.admin1 !== undefined) {
    city.admin1 = result.admin1
  }
  
  return city
}

// Reverse geocoding (coordinates to city)
export const reverseGeocode = async (
  latitude: number,
  longitude: number
): Promise<City | null> => {
  // Open-Meteo doesn't have reverse geocoding
  // Use a simple city name based on coordinates
  // In production, you'd use a service like Nominatim or Google Geocoding
  
  // Attempt to find nearby city
  // This is a workaround - ideally use a proper reverse geocoding API
  try {
    // For now, return a generic location
    return {
      id: `loc-${latitude}-${longitude}`,
      name: 'Current Location',
      country: 'Unknown',
      countryCode: 'XX',
      latitude,
      longitude,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    }
  } catch {
    return null
  }
}

// Debounce helper for search
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeoutId: ReturnType<typeof setTimeout> | null = null
  
  return (...args: Parameters<T>) => {
    if (timeoutId) {
      clearTimeout(timeoutId)
    }
    
    timeoutId = setTimeout(() => {
      func(...args)
    }, wait)
  }
}
</file>

<file path="src/services/translationApi.ts">
const BASE_URL = 'https://api.cognitive.microsofttranslator.com/translate'
const API_VERSION = '3.0'

import { env } from '@/config/env'

interface TranslationResult {
  translations: {
    text: string
    to: string
  }[]
}

// Translation via backend proxy (recommended for production)
const translateViaProxy = async (text: string, to: string): Promise<string> => {
  try {
    const response = await fetch(env.translationProxyUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ text, to })
    })

    if (!response.ok) {
      throw new Error(`Proxy translation failed: ${response.statusText}`)
    }

    const data = await response.json()
    return data.translation || text
  } catch (error) {
    console.error('Proxy translation error:', error)
    return text
  }
}

// Direct translation (only for development)
const translateDirect = async (text: string, to: string): Promise<string> => {
  const apiKey = env.azureTranslatorKey
  const region = env.azureTranslatorRegion
  
  if (!apiKey) {
    console.warn('Azure Translator API key not configured')
    return text
  }
  
  try {
    const url = `${BASE_URL}?api-version=${API_VERSION}&to=${to}`
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Ocp-Apim-Subscription-Key': apiKey,
        'Ocp-Apim-Subscription-Region': region,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify([{ Text: text }])
    })

    if (!response.ok) {
      throw new Error(`Translation failed: ${response.statusText}`)
    }

    const data: TranslationResult[] = await response.json()
    const firstResult = data[0]
    const firstTranslation = firstResult?.translations[0]
    return firstTranslation?.text || text
  } catch (error) {
    console.error('Translation error:', error)
    return text
  }
}

// Main translation function - uses proxy if configured
export const translateText = async (text: string, to: string): Promise<string> => {
  if (!text) return text
  
  if (env.useTranslationProxy) {
    return translateViaProxy(text, to)
  }
  
  return translateDirect(text, to)
}

// Legacy function for backward compatibility
export const translateTextWithKey = async (
  text: string, 
  to: string, 
  apiKey: string, 
  region: string
): Promise<string> => {
  if (!apiKey || !text) return text
  
  try {
    const url = `${BASE_URL}?api-version=${API_VERSION}&to=${to}`
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Ocp-Apim-Subscription-Key': apiKey,
        'Ocp-Apim-Subscription-Region': region,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify([{ Text: text }])
    })

    if (!response.ok) {
      throw new Error(`Translation failed: ${response.statusText}`)
    }

    const data: TranslationResult[] = await response.json()
    const firstResult = data[0]
    const firstTranslation = firstResult?.translations[0]
    return firstTranslation?.text || text
  } catch (error) {
    console.error('Translation error:', error)
    return text
  }
}
</file>

<file path="src/stores/locationStore.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { City, Coordinates, GeolocationError } from '@/types'
import { DEFAULT_CITIES } from '@/types'

const RECENT_CITIES_KEY = 'weathervue-recent-cities'
const CURRENT_CITY_KEY = 'weathervue-current-city'
const MAX_RECENT_CITIES = 5

export const useLocationStore = defineStore('location', () => {
  // State
  const currentCity = ref<City | null>(null)
  const coordinates = ref<Coordinates | null>(null)
  
  const searchQuery = ref('')
  const searchResults = ref<City[]>([])
  const isSearching = ref(false)
  
  const recentCities = ref<City[]>([])
  const favoriteCities = ref<City[]>([])
  
  const isGeolocating = ref(false)
  const geoError = ref<GeolocationError | null>(null)
  
  // Getters
  const cityDisplayName = computed(() => {
    if (!currentCity.value) return ''
    return `${currentCity.value.name}, ${currentCity.value.country}`
  })
  
  const hasLocation = computed(() => currentCity.value !== null)
  
  const defaultCities = computed(() => DEFAULT_CITIES)
  
  // Actions
  const setCurrentCity = (city: City) => {
    currentCity.value = city
    coordinates.value = {
      latitude: city.latitude,
      longitude: city.longitude
    }
    
    // Add to recent cities
    addToRecentCities(city)
    
    // Persist
    localStorage.setItem(CURRENT_CITY_KEY, JSON.stringify(city))
  }
  
  const setCoordinates = (coords: Coordinates) => {
    coordinates.value = coords
  }
  
  const setSearchQuery = (query: string) => {
    searchQuery.value = query
  }
  
  const setSearchResults = (results: City[]) => {
    searchResults.value = results
  }
  
  const setSearching = (searching: boolean) => {
    isSearching.value = searching
  }
  
  const clearSearch = () => {
    searchQuery.value = ''
    searchResults.value = []
    isSearching.value = false
  }
  
  const addToRecentCities = (city: City) => {
    // Remove if already exists
    const filtered = recentCities.value.filter(c => c.id !== city.id)
    
    // Add to front
    recentCities.value = [city, ...filtered].slice(0, MAX_RECENT_CITIES)
    
    // Persist
    localStorage.setItem(RECENT_CITIES_KEY, JSON.stringify(recentCities.value))
  }
  
  const removeFromRecentCities = (cityId: string) => {
    recentCities.value = recentCities.value.filter(c => c.id !== cityId)
    localStorage.setItem(RECENT_CITIES_KEY, JSON.stringify(recentCities.value))
  }
  
  const clearRecentCities = () => {
    recentCities.value = []
    localStorage.removeItem(RECENT_CITIES_KEY)
  }
  
  const toggleFavorite = (city: City) => {
    const index = favoriteCities.value.findIndex(c => c.id === city.id)
    if (index >= 0) {
      favoriteCities.value.splice(index, 1)
    } else {
      favoriteCities.value.push(city)
    }
  }
  
  const isFavorite = (cityId: string) => {
    return favoriteCities.value.some(c => c.id === cityId)
  }
  
  const setGeolocating = (locating: boolean) => {
    isGeolocating.value = locating
    if (locating) {
      geoError.value = null
    }
  }
  
  const setGeoError = (error: GeolocationError | null) => {
    geoError.value = error
    isGeolocating.value = false
  }
  
  // Initialize from localStorage
  const init = () => {
    // Load recent cities
    const storedRecent = localStorage.getItem(RECENT_CITIES_KEY)
    if (storedRecent) {
      try {
        recentCities.value = JSON.parse(storedRecent)
      } catch {
        recentCities.value = []
      }
    }
    
    // Load current city
    const storedCurrent = localStorage.getItem(CURRENT_CITY_KEY)
    if (storedCurrent) {
      try {
        const city = JSON.parse(storedCurrent) as City
        currentCity.value = city
        coordinates.value = {
          latitude: city.latitude,
          longitude: city.longitude
        }
      } catch {
        // Use default
        const defaultCity = DEFAULT_CITIES[0]
        if (defaultCity) {
          setCurrentCity(defaultCity)
        }
      }
    }
  }
  
  return {
    // State
    currentCity,
    coordinates,
    searchQuery,
    searchResults,
    isSearching,
    recentCities,
    favoriteCities,
    isGeolocating,
    geoError,
    
    // Getters
    cityDisplayName,
    hasLocation,
    defaultCities,
    
    // Actions
    setCurrentCity,
    setCoordinates,
    setSearchQuery,
    setSearchResults,
    setSearching,
    clearSearch,
    addToRecentCities,
    removeFromRecentCities,
    clearRecentCities,
    toggleFavorite,
    isFavorite,
    setGeolocating,
    setGeoError,
    init
  }
})
</file>

<file path="src/stores/settingsStore.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { Theme, TemperatureUnit, SpeedUnit, UserSettings } from '@/types'
import { DEFAULT_SETTINGS } from '@/types'

const SETTINGS_KEY = 'weathervue-settings'

export const useSettingsStore = defineStore('settings', () => {
  // State - initialized from defaults
  const theme = ref<Theme>(DEFAULT_SETTINGS.theme)
  const reducedMotion = ref(DEFAULT_SETTINGS.reducedMotion)
  
  const temperatureUnit = ref<TemperatureUnit>(DEFAULT_SETTINGS.temperatureUnit)
  const speedUnit = ref<SpeedUnit>(DEFAULT_SETTINGS.speedUnit)
  const use24Hour = ref(DEFAULT_SETTINGS.use24Hour)
  
  const highContrast = ref(DEFAULT_SETTINGS.highContrast)
  const sonificationEnabled = ref(DEFAULT_SETTINGS.sonificationEnabled)
  
  const ambientAudioEnabled = ref(DEFAULT_SETTINGS.ambientAudioEnabled)
  const ambientVolume = ref(DEFAULT_SETTINGS.ambientVolume)
  
  const hapticsEnabled = ref(DEFAULT_SETTINGS.hapticsEnabled)
  
  const autoRefresh = ref(DEFAULT_SETTINGS.autoRefresh)
  const refreshInterval = ref(DEFAULT_SETTINGS.refreshInterval)
  
  // Drawer state
  const isDrawerOpen = ref(false)
  
  // Computed
  const effectiveTheme = computed<'light' | 'dark' | 'terminal'>(() => {
    if (theme.value === 'terminal') return 'terminal'
    if (theme.value === 'system') {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
    }
    return theme.value
  })
  
  const prefersReducedMotion = computed(() => {
    return reducedMotion.value || 
      window.matchMedia('(prefers-reduced-motion: reduce)').matches
  })
  
  // Actions
  const setTheme = (newTheme: Theme) => {
    theme.value = newTheme
    applyTheme()
    persist()
  }
  
  const toggleTheme = () => {
    const themes: Theme[] = ['light', 'dark', 'system', 'terminal']
    const currentIndex = themes.indexOf(theme.value)
    const nextIndex = (currentIndex + 1) % themes.length
    const nextTheme = themes[nextIndex]
    if (nextTheme) {
      setTheme(nextTheme)
    }
  }
  
  const cycleTheme = () => {
    // Simple cycle: light -> dark -> system
    if (theme.value === 'light') setTheme('dark')
    else if (theme.value === 'dark') setTheme('system')
    else setTheme('light')
  }
  
  const setTemperatureUnit = (unit: TemperatureUnit) => {
    temperatureUnit.value = unit
    persist()
  }
  
  const setSpeedUnit = (unit: SpeedUnit) => {
    speedUnit.value = unit
    persist()
  }
  
  const toggleReducedMotion = () => {
    reducedMotion.value = !reducedMotion.value
    persist()
  }
  
  const toggleHighContrast = () => {
    highContrast.value = !highContrast.value
    if (highContrast.value) {
      setTheme('terminal')
    }
    persist()
  }
  
  const toggleSonification = () => {
    sonificationEnabled.value = !sonificationEnabled.value
    persist()
  }
  
  const toggleAmbientAudio = () => {
    ambientAudioEnabled.value = !ambientAudioEnabled.value
    persist()
  }
  
  const setAmbientVolume = (volume: number) => {
    ambientVolume.value = Math.max(0, Math.min(100, volume))
    persist()
  }
  
  const toggleHaptics = () => {
    hapticsEnabled.value = !hapticsEnabled.value
    persist()
  }
  
  const openDrawer = () => {
    isDrawerOpen.value = true
  }
  
  const closeDrawer = () => {
    isDrawerOpen.value = false
  }
  
  const toggleDrawer = () => {
    isDrawerOpen.value = !isDrawerOpen.value
  }
  
  // Apply theme to document
  const applyTheme = () => {
    const root = document.documentElement
    const effective = effectiveTheme.value
    
    if (effective === 'terminal') {
      root.setAttribute('data-theme', 'terminal')
    } else if (effective === 'dark') {
      root.setAttribute('data-theme', 'dark')
    } else {
      root.removeAttribute('data-theme')
    }
  }
  
  // Persist to localStorage
  const persist = () => {
    const settings: Partial<UserSettings> = {
      theme: theme.value,
      reducedMotion: reducedMotion.value,
      temperatureUnit: temperatureUnit.value,
      speedUnit: speedUnit.value,
      use24Hour: use24Hour.value,
      highContrast: highContrast.value,
      sonificationEnabled: sonificationEnabled.value,
      ambientAudioEnabled: ambientAudioEnabled.value,
      ambientVolume: ambientVolume.value,
      hapticsEnabled: hapticsEnabled.value,
      autoRefresh: autoRefresh.value,
      refreshInterval: refreshInterval.value
    }
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings))
  }
  
  // Load from localStorage
  const init = () => {
    const stored = localStorage.getItem(SETTINGS_KEY)
    if (stored) {
      try {
        const settings = JSON.parse(stored) as Partial<UserSettings>
        
        if (settings.theme) theme.value = settings.theme
        if (settings.reducedMotion !== undefined) reducedMotion.value = settings.reducedMotion
        if (settings.temperatureUnit) temperatureUnit.value = settings.temperatureUnit
        if (settings.speedUnit) speedUnit.value = settings.speedUnit
        if (settings.use24Hour !== undefined) use24Hour.value = settings.use24Hour
        if (settings.highContrast !== undefined) highContrast.value = settings.highContrast
        if (settings.sonificationEnabled !== undefined) sonificationEnabled.value = settings.sonificationEnabled
        if (settings.ambientAudioEnabled !== undefined) ambientAudioEnabled.value = settings.ambientAudioEnabled
        if (settings.ambientVolume !== undefined) ambientVolume.value = settings.ambientVolume
        if (settings.hapticsEnabled !== undefined) hapticsEnabled.value = settings.hapticsEnabled
      } catch {
        // Use defaults
      }
    }
    
    // Apply theme on init
    applyTheme()
    
    // Listen for system theme changes
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
      if (theme.value === 'system') {
        applyTheme()
      }
    })
  }
  
  return {
    // State
    theme,
    reducedMotion,
    temperatureUnit,
    speedUnit,
    use24Hour,
    highContrast,
    sonificationEnabled,
    ambientAudioEnabled,
    ambientVolume,
    hapticsEnabled,
    autoRefresh,
    refreshInterval,
    isDrawerOpen,
    
    // Getters
    effectiveTheme,
    prefersReducedMotion,
    
    // Actions
    setTheme,
    toggleTheme,
    cycleTheme,
    setTemperatureUnit,
    setSpeedUnit,
    toggleReducedMotion,
    toggleHighContrast,
    toggleSonification,
    toggleAmbientAudio,
    setAmbientVolume,
    toggleHaptics,
    openDrawer,
    closeDrawer,
    toggleDrawer,
    applyTheme,
    init
  }
})
</file>

<file path="src/styles/main.css">
@import './variables.css';
@import './animations.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base styles */
body {
  font-family: theme('fontFamily.body');
  background-color: var(--bg-body);
  color: var(--text-primary);
  transition: background-color 0.5s ease, color 0.5s ease;
  overflow-x: hidden;
}

/* Font families */
.font-display {
  font-family: theme('fontFamily.display');
}

.font-mono {
  font-family: theme('fontFamily.mono');
}

/* Scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-card);
}

::-webkit-scrollbar-thumb {
  background: var(--text-muted);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-secondary);
}

/* Selection */
::selection {
  background-color: var(--accent);
  color: white;
}

/* Skip link for accessibility */
.skip-link {
  @apply absolute -top-10 left-0 z-[9999] bg-accent text-white px-4 py-2;
  transition: top 0.3s;
}

.skip-link:focus {
  top: 0;
}

/* Screen reader only */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

.sr-only-focusable:focus,
.sr-only-focusable:focus-within {
  position: static;
  width: auto;
  height: auto;
  padding: inherit;
  margin: inherit;
  overflow: visible;
  clip: auto;
  white-space: normal;
}

/* Focus styles */
:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

:focus:not(:focus-visible) {
  outline: none;
}

/* Glassmorphism */
.glass {
  background: var(--bg-glass);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--border-glass);
}

/* Text outline effect */
.text-outline {
  -webkit-text-stroke: 2px var(--text-secondary);
  color: transparent;
}

[data-theme="dark"] .text-outline {
  -webkit-text-stroke-color: rgba(255, 255, 255, 0.2);
}

/* Reduced motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}
</file>

<file path="src/styles/variables.css">
/* CSS Custom Properties - Design Tokens */

:root {
  /* Durations */
  --duration-instant: 0ms;
  --duration-fast: 150ms;
  --duration-normal: 300ms;
  --duration-slow: 500ms;
  --duration-slower: 700ms;
  
  /* Easings */
  --ease-default: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-in: cubic-bezier(0.4, 0, 1, 0.2);
  --ease-out: cubic-bezier(0, 0, 0.2, 1);
  --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
  --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
  
  /* Light Theme (default) */
  --bg-body: #ffffff;
  --bg-card: #f4f4f5;
  --bg-card-hover: #e4e4e7;
  --bg-drawer: #fafafa;
  --bg-glass: rgba(255, 255, 255, 0.7);
  
  --text-primary: #000000;
  --text-secondary: #52525b;
  --text-muted: #71717a;
  --text-inverse: #ffffff;
  
  --border-default: #e4e4e7;
  --border-strong: #a1a1aa;
  --border-glass: rgba(255, 255, 255, 0.2);
  
  --accent: #dc2626;
  --accent-light: #ef4444;
  --accent-dark: #b91c1c;
  
  /* Weather-reactive (defaults) */
  --sky-start: #87CEEB;
  --sky-end: #1E90FF;
  --atmosphere: rgba(255, 215, 0, 0.1);
  
  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
  --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.15);
  
  /* Z-index scale */
  --z-below: -1;
  --z-base: 0;
  --z-above: 1;
  --z-header: 10;
  --z-dropdown: 20;
  --z-drawer: 30;
  --z-modal: 40;
  --z-toast: 50;
  --z-splash: 100;
}

/* Dark Theme */
:root[data-theme="dark"] {
  --bg-body: #000000;
  --bg-card: #18181b;
  --bg-card-hover: #27272a;
  --bg-drawer: #09090b;
  --bg-glass: rgba(0, 0, 0, 0.7);
  
  --text-primary: #ffffff;
  --text-secondary: #a1a1aa;
  --text-muted: #71717a;
  --text-inverse: #000000;
  
  --border-default: #27272a;
  --border-strong: #3f3f46;
  --border-glass: rgba(255, 255, 255, 0.1);
  
  /* Weather-reactive (night defaults) */
  --sky-start: #0f0f23;
  --sky-end: #1a1a2e;
  --atmosphere: rgba(100, 100, 200, 0.1);
}

/* Terminal Theme (High Contrast Accessibility) */
:root[data-theme="terminal"] {
  --bg-body: #0a0a0a;
  --bg-card: #0f0f0f;
  --bg-card-hover: #1a1a1a;
  --bg-drawer: #050505;
  --bg-glass: rgba(0, 255, 0, 0.1);
  
  --text-primary: #00ff00;
  --text-secondary: #00cc00;
  --text-muted: #009900;
  --text-inverse: #000000;
  
  --border-default: #003300;
  --border-strong: #00ff00;
  --border-glass: rgba(0, 255, 0, 0.2);
  
  --accent: #00ff00;
  --accent-light: #33ff33;
  --accent-dark: #00cc00;
}

/* Terminal theme overrides */
[data-theme="terminal"] * {
  font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace !important;
  border-radius: 0 !important;
}

[data-theme="terminal"]::after {
  content: '';
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    rgba(0, 0, 0, 0.1) 0px,
    rgba(0, 0, 0, 0.1) 1px,
    transparent 1px,
    transparent 2px
  );
  pointer-events: none;
  z-index: 9999;
}

/* Weather-reactive color palettes */
:root[data-weather="clear"][data-time="day"] {
  --sky-start: #87CEEB;
  --sky-end: #1E90FF;
  --atmosphere: rgba(255, 215, 0, 0.1);
}

:root[data-weather="clear"][data-time="night"] {
  --sky-start: #0f0f23;
  --sky-end: #1a1a2e;
  --atmosphere: rgba(100, 100, 200, 0.1);
}

:root[data-weather="cloudy"] {
  --sky-start: #94a3b8;
  --sky-end: #64748b;
  --atmosphere: rgba(150, 150, 150, 0.2);
}

:root[data-weather="rain"] {
  --sky-start: #4a5568;
  --sky-end: #2d3748;
  --atmosphere: rgba(100, 150, 200, 0.2);
}

:root[data-weather="storm"] {
  --sky-start: #1a202c;
  --sky-end: #0d1117;
  --atmosphere: rgba(80, 50, 120, 0.3);
}

:root[data-weather="snow"] {
  --sky-start: #e2e8f0;
  --sky-end: #cbd5e0;
  --atmosphere: rgba(220, 230, 240, 0.3);
}

:root[data-weather="fog"] {
  --sky-start: #d1d5db;
  --sky-end: #9ca3af;
  --atmosphere: rgba(180, 180, 180, 0.5);
}
</file>

<file path="src/utils/formatters.ts">
import type { TemperatureUnit, SpeedUnit } from '@/types'

// Temperature formatting
export const formatTemperature = (
  celsius: number, 
  unit: TemperatureUnit = 'celsius',
  showUnit: boolean = true
): string => {
  let value: number
  let symbol: string
  
  if (unit === 'fahrenheit') {
    value = (celsius * 9/5) + 32
    symbol = '°F'
  } else {
    value = celsius
    symbol = '°C'
  }
  
  const rounded = Math.round(value)
  return showUnit ? `${rounded}${symbol}` : `${rounded}`
}

// Wind speed formatting
export const formatWindSpeed = (
  kmh: number,
  unit: SpeedUnit = 'kmh',
  showUnit: boolean = true
): string => {
  let value: number
  let symbol: string
  
  switch (unit) {
    case 'mph':
      value = kmh * 0.621371
      symbol = 'mph'
      break
    case 'ms':
      value = kmh / 3.6
      symbol = 'm/s'
      break
    default:
      value = kmh
      symbol = 'km/h'
  }
  
  const rounded = Math.round(value)
  return showUnit ? `${rounded} ${symbol}` : `${rounded}`
}

export const formatSpeed = formatWindSpeed

// Wind direction to cardinal
export const formatWindDirection = (degrees: number): string => {
  const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
                      'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']
  const index = Math.round(degrees / 22.5) % 16
  return directions[index] ?? 'N'
}

// Percentage formatting
export const formatPercent = (value: number): string => {
  return `${Math.round(value)}%`
}

// Pressure formatting
export const formatPressure = (hPa: number, unit: 'hpa' | 'inhg' | 'mmhg' = 'hpa'): string => {
  switch (unit) {
    case 'inhg':
      return `${(hPa * 0.02953).toFixed(2)} inHg`
    case 'mmhg':
      return `${Math.round(hPa * 0.750062)} mmHg`
    default:
      return `${Math.round(hPa)} hPa`
  }
}

// Time formatting
export const formatTime = (
  date: Date | string, 
  use24Hour: boolean = true,
  timezone?: string
): string => {
  const d = typeof date === 'string' ? new Date(date) : date
  
  const options: Intl.DateTimeFormatOptions = {
    hour: 'numeric',
    minute: '2-digit',
    hour12: !use24Hour,
    ...(timezone && { timeZone: timezone })
  }
  
  return d.toLocaleTimeString('en-US', options)
}

// Date formatting
export const formatDate = (
  date: Date | string,
  format: 'short' | 'medium' | 'long' = 'medium',
  timezone?: string
): string => {
  const d = typeof date === 'string' ? new Date(date) : date
  
  const options: Intl.DateTimeFormatOptions = {
    ...(timezone && { timeZone: timezone })
  }
  
  switch (format) {
    case 'short':
      options.weekday = 'short'
      break
    case 'long':
      options.weekday = 'long'
      options.month = 'long'
      options.day = 'numeric'
      break
    default:
      options.weekday = 'short'
      options.month = 'short'
      options.day = 'numeric'
  }
  
  return d.toLocaleDateString('en-US', options)
}

// Relative time (e.g., "5 minutes ago")
export const formatRelativeTime = (date: Date | string): string => {
  const d = typeof date === 'string' ? new Date(date) : date
  const now = new Date()
  const diffMs = now.getTime() - d.getTime()
  const diffMins = Math.floor(diffMs / 60000)
  
  if (diffMins < 1) return 'Just now'
  if (diffMins < 60) return `${diffMins}m ago`
  
  const diffHours = Math.floor(diffMins / 60)
  if (diffHours < 24) return `${diffHours}h ago`
  
  const diffDays = Math.floor(diffHours / 24)
  return `${diffDays}d ago`
}

// UV Index description
export const formatUVIndex = (uv: number): { value: number; level: string; color: string } => {
  const value = Math.round(uv)
  
  if (value <= 2) return { value, level: 'Low', color: '#22c55e' }
  if (value <= 5) return { value, level: 'Moderate', color: '#eab308' }
  if (value <= 7) return { value, level: 'High', color: '#f97316' }
  if (value <= 10) return { value, level: 'Very High', color: '#ef4444' }
  return { value, level: 'Extreme', color: '#a855f7' }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_AZURE_TRANSLATOR_KEY?: string
  readonly VITE_AZURE_TRANSLATOR_REGION?: string
  readonly VITE_USE_TRANSLATION_PROXY?: string
  readonly VITE_TRANSLATION_PROXY_URL?: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

declare module '*.vue' {
  import type { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",

    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitReturns": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "forceConsistentCasingInFileNames": true,

    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@composables/*": ["src/composables/*"],
      "@stores/*": ["src/stores/*"],
      "@services/*": ["src/services/*"],
      "@types/*": ["src/types/*"],
      "@utils/*": ["src/utils/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { VitePWA } from 'vite-plugin-pwa'
import { fileURLToPath, URL } from 'node:url'

// https://vitejs.dev/config/
export default defineConfig({
  base: '/WeatherVue/',
  plugins: [
    vue(),
    VitePWA({
      registerType: 'autoUpdate',
      includeAssets: ['favicon.ico', 'robots.txt', 'apple-touch-icon.png'],
      manifest: {
        name: 'WeatherVue',
        short_name: 'WeatherVue',
        description: 'Award-winning weather application with immersive atmospheric design',
        theme_color: '#000000',
        background_color: '#000000',
        display: 'standalone',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png',
            purpose: 'maskable'
          }
        ]
      },
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/api\.open-meteo\.com\/.*/i,
            handler: 'NetworkFirst',
            options: {
              cacheName: 'weather-api-cache',
              expiration: {
                maxEntries: 10,
                maxAgeSeconds: 60 * 5 // 5 minutes
              },
              cacheableResponse: {
                statuses: [0, 200]
              }
            }
          },
          {
            urlPattern: /^https:\/\/geocoding-api\.open-meteo\.com\/.*/i,
            handler: 'CacheFirst',
            options: {
              cacheName: 'geocoding-cache',
              expiration: {
                maxEntries: 100,
                maxAgeSeconds: 60 * 60 * 24 * 7 // 1 week
              }
            }
          }
        ]
      }
    })
  ],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url)),
      '@components': fileURLToPath(new URL('./src/components', import.meta.url)),
      '@composables': fileURLToPath(new URL('./src/composables', import.meta.url)),
      '@stores': fileURLToPath(new URL('./src/stores', import.meta.url)),
      '@services': fileURLToPath(new URL('./src/services', import.meta.url)),
      '@types': fileURLToPath(new URL('./src/types', import.meta.url)),
      '@utils': fileURLToPath(new URL('./src/utils', import.meta.url))
    }
  },
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          'three': ['three'],
          'd3': ['d3'],
          'gsap': ['gsap'],
          'vendor': ['vue', 'vue-router', 'pinia']
        }
      }
    }
  }
})
</file>

<file path="package.json">
{
  "name": "weathervue",
  "version": "2.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc -b && vite build",
    "preview": "vite preview",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "format": "prettier --write src/",
    "deploy": "gh-pages -d dist",
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage",
    "typecheck": "vue-tsc --noEmit"
  },
  "dependencies": {
    "@vueuse/core": "^10.7.0",
    "d3": "^7.8.0",
    "gsap": "^3.12.0",
    "lucide-vue-next": "^0.300.0",
    "pinia": "^2.1.0",
    "three": "^0.160.0",
    "vue": "^3.4.0",
    "vue-router": "^4.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.0.0",
    "@types/d3": "^7.4.0",
    "@types/node": "^25.0.3",
    "@types/three": "^0.160.0",
    "@typescript-eslint/parser": "^8.52.0",
    "@vitejs/plugin-vue": "^5.0.0",
    "@vitest/coverage-v8": "^4.0.16",
    "@vue/test-utils": "^2.4.6",
    "@vue/tsconfig": "^0.5.0",
    "autoprefixer": "^10.4.0",
    "eslint": "^9.0.0",
    "eslint-plugin-vue": "^9.0.0",
    "gh-pages": "^6.3.0",
    "happy-dom": "^20.1.0",
    "postcss": "^8.4.0",
    "prettier": "^3.2.0",
    "tailwindcss": "^3.4.0",
    "typescript": "~5.3.0",
    "vite": "^5.0.0",
    "vite-plugin-pwa": "^0.17.0",
    "vitest": "^4.0.16",
    "vue-tsc": "^2.0.0"
  }
}
</file>

<file path="src/App.vue">
<script setup lang="ts">
import { onMounted, watch, computed, ref, defineAsyncComponent } from "vue";
import { useSettingsStore, useLocationStore, useWeatherStore } from "@/stores";
import { useTheme } from "@/composables/useTheme";
import { useWeather } from "@/composables/useWeather";
import { useKeyboardShortcuts } from "@/composables/useKeyboardShortcuts";
import gsap from "gsap";

// Components
import SplashScreen from "@/components/layout/SplashScreen.vue";
import AppHeader from "@/components/layout/AppHeader.vue";
import SettingsDrawer from "@/components/layout/SettingsDrawer.vue";
import CurrentWeather from "@/components/weather/CurrentWeather.vue";
import HourlyForecast from "@/components/weather/HourlyForecast.vue";
import WeeklyForecast from "@/components/weather/WeeklyForecast.vue";
import TimelineScrubber from "@/components/weather/TimelineScrubber.vue";
import TemperatureGraph from "@/components/weather/TemperatureGraph.vue";
import WindCompass from "@/components/weather/WindCompass.vue";
import SunriseSunsetArc from "@/components/weather/SunriseSunsetArc.vue";
import UVIndexGauge from "@/components/weather/UVIndexGauge.vue";
import PrecipitationBar from "@/components/weather/PrecipitationBar.vue";
import CitySearch from "@/components/search/CitySearch.vue";
import WeatherCard from "@/components/ui/WeatherCard.vue";
import ErrorDisplay from "@/components/ui/ErrorDisplay.vue";
import OfflineIndicator from "@/components/ui/OfflineIndicator.vue";

// Lazy-load heavy Three.js canvas for better performance
const WeatherCanvas = defineAsyncComponent(() =>
  import("@/components/canvas/WeatherCanvas.vue")
);

// Lucide Icons
import { Droplets, Cloud, Eye, Gauge } from "lucide-vue-next";

// Stores
const settingsStore = useSettingsStore();
const locationStore = useLocationStore();
const weatherStore = useWeatherStore();

// Composables
useTheme();
useKeyboardShortcuts();
const { retryWithBackoff, isRetrying } = useWeather(computed(() => locationStore.coordinates));

// Online status
const isOnline = ref(navigator.onLine);
onMounted(() => {
  window.addEventListener('online', () => isOnline.value = true);
  window.addEventListener('offline', () => isOnline.value = false);
});

// Computed
const showSplash = computed(
  () => !weatherStore.hasData && weatherStore.isLoading,
);
const weather = computed(
  () => weatherStore.interpolatedWeather || weatherStore.current,
);
const daily = computed(() => weatherStore.daily[0]);

const mainContentRef = ref<HTMLElement | null>(null);

// Watch for city changes to trigger transition
watch(
  () => locationStore.currentCity,
  () => {
    if (mainContentRef.value && !settingsStore.prefersReducedMotion) {
      gsap.fromTo(
        mainContentRef.value,
        { opacity: 0, scale: 0.95 },
        { opacity: 1, scale: 1, duration: 1, ease: "expo.out" },
      );
    } else if (mainContentRef.value) {
      // Instant switch for reduced motion
      gsap.set(mainContentRef.value, { opacity: 1, scale: 1 });
    }
  },
);

// Initialize on mount
onMounted(() => {
  settingsStore.init();
  locationStore.init();
});
</script>

<template>
  <div class="app min-h-screen relative overflow-hidden">
    <!-- Skip link for accessibility -->
    <a href="#main-content" class="skip-link sr-only-focusable">
      Skip to main content
    </a>

    <!-- WebGL Background -->
    <WeatherCanvas class="fixed inset-0 z-0" />

    <!-- Splash Screen -->
    <SplashScreen v-if="showSplash" />

    <!-- Header -->
    <AppHeader />

    <!-- Main Content -->
    <main
      id="main-content"
      ref="mainContentRef"
      class="relative z-10 min-h-screen w-full pt-28 pb-32 px-4 md:px-8"
    >
      <div class="max-w-[1400px] mx-auto">
        <!-- Search Section -->
        <div
          v-if="!weatherStore.hasData"
          class="flex flex-col items-center justify-center h-[70vh] text-center"
        >
          <h1
            class="font-display text-7xl md:text-9xl font-black tracking-tighter mb-8 animate-fade-in"
          >
            Weather<span class="text-outline">Vue</span>
          </h1>
          <CitySearch />
          <p
            class="mt-8 text-xs uppercase tracking-[0.4em] text-muted animate-pulse-slow"
          >
            Atmospheric Intelligence for the Modern Age
          </p>

          <!-- Error Display -->
          <ErrorDisplay
            v-if="weatherStore.error"
            :error="weatherStore.error"
            :is-offline="!isOnline"
            :retrying="isRetrying"
            class="mt-8 max-w-md"
            @retry="retryWithBackoff"
          />
        </div>

        <template v-else>
          <!-- Hero Section -->
          <div class="grid grid-cols-1 lg:grid-cols-12 gap-8 mb-12">
            <div class="lg:col-span-8">
              <CurrentWeather />
            </div>
            <div class="lg:col-span-4 flex flex-col justify-end">
              <TimelineScrubber />
            </div>
          </div>

          <!-- Bento Grid Layout -->
          <div
            class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-12 gap-6 mb-12"
          >
            <!-- Temperature Graph (Large) -->
            <div
              class="lg:col-span-8 bg-glass p-8 rounded-3xl border border-default shadow-glass"
            >
              <TemperatureGraph />
            </div>

            <!-- Wind (Medium) -->
            <div
              class="lg:col-span-4 bg-glass p-8 rounded-3xl border border-default shadow-glass flex items-center justify-center"
            >
              <WindCompass
                v-if="weather"
                :speed="weather.windSpeed"
                :direction="weatherStore.current?.windDirection || 0"
              />
            </div>

            <!-- Sunrise / Sunset (Medium) -->
            <div
              v-if="daily"
              class="lg:col-span-4 bg-glass p-8 rounded-3xl border border-default shadow-glass"
            >
              <SunriseSunsetArc
                :sunrise="daily.sunrise"
                :sunset="daily.sunset"
              />
            </div>

            <!-- UV Index (Small) -->
            <div
              class="lg:col-span-4 bg-glass p-8 rounded-3xl border border-default shadow-glass"
            >
              <UVIndexGauge v-if="weather" :value="weather.uvIndex" />
            </div>

            <!-- Precipitation (Small) -->
            <div
              class="lg:col-span-4 bg-glass p-8 rounded-3xl border border-default shadow-glass"
            >
              <PrecipitationBar
                v-if="weather"
                :probability="
                  'precipitationProbability' in weather
                    ? (weather.precipitationProbability ?? 0)
                    : 0
                "
                :amount="weather.precipitation"
              />
            </div>

            <!-- Secondary Metrics -->
            <div class="lg:col-span-3">
              <WeatherCard
                title="Humidity"
                :value="Math.round(weather?.humidity || 0)"
                unit="%"
                :icon="Droplets"
                description="The current relative humidity"
                accent="#3b82f6"
              />
            </div>
            <div class="lg:col-span-3">
              <WeatherCard
                title="Pressure"
                :value="Math.round(weatherStore.current?.pressure || 0)"
                unit="hPa"
                :icon="Gauge"
                description="Atmospheric pressure at sea level"
              />
            </div>
            <div class="lg:col-span-3">
              <WeatherCard
                title="Cloud Cover"
                :value="Math.round(weatherStore.current?.cloudCover || 0)"
                unit="%"
                :icon="Cloud"
                description="Percentage of the sky covered"
              />
            </div>
            <div class="lg:col-span-3">
              <WeatherCard
                title="Visibility"
                :value="Math.round(weatherStore.current?.visibility || 10)"
                unit="km"
                :icon="Eye"
                description="Distance you can see clearly"
              />
            </div>
          </div>

          <!-- Forecast Section -->
          <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <div class="lg:col-span-4">
              <WeeklyForecast />
            </div>
            <div class="lg:col-span-8">
              <HourlyForecast />
            </div>
          </div>
        </template>
      </div>
    </main>

    <!-- Settings Drawer -->
    <SettingsDrawer />

    <!-- Offline Indicator -->
    <OfflineIndicator />

    <!-- Screen reader announcements -->
    <div
      id="announcer"
      role="status"
      aria-live="polite"
      aria-atomic="true"
      class="sr-only"
    />
  </div>
</template>

<style scoped>
.bg-glass {
  background: var(--bg-glass);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
}

.border-default {
  border-color: var(--border-default);
}

.shadow-glass {
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

[data-theme="dark"] .shadow-glass {
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
}

.skip-link {
  position: absolute;
  top: -100%;
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent);
  color: white;
  padding: 0.75rem 1.5rem;
  border-radius: 0.5rem;
  font-weight: 600;
  z-index: 100;
  transition: top 0.2s ease;
}

.skip-link:focus {
  top: 1rem;
  outline: 2px solid white;
  outline-offset: 2px;
}
</style>
</file>

<file path="src/components/weather/TemperatureGraph.vue">
<script setup lang="ts">
import { ref, onMounted, watch, onUnmounted, computed } from 'vue'
import * as d3 from 'd3'
import { useWeatherStore, useSettingsStore } from '@/stores'

const weatherStore = useWeatherStore()
const settingsStore = useSettingsStore()

const svgRef = ref<SVGSVGElement | null>(null)
const containerRef = ref<HTMLDivElement | null>(null)

const margin = { top: 20, right: 20, bottom: 30, left: 40 }
const height = 200

// Filter data based on selected day
const graphData = computed(() => {
  const index = weatherStore.selectedDayIndex
  // Only show graph for today (0) and tomorrow (1) as we have 48h data
  if (index > 1) return []

  const selectedDate = weatherStore.daily[index]?.date
  if (!selectedDate) return []

  return weatherStore.hourly.filter(h => h.time.startsWith(selectedDate))
})

const drawGraph = () => {
  if (!svgRef.value || !containerRef.value || graphData.value.length === 0) return

  const width = containerRef.value.clientWidth - margin.left - margin.right
  const data = graphData.value

  // Clear previous content
  d3.select(svgRef.value).selectAll('*').remove()

  const svg = d3
    .select(svgRef.value)
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`)

  // X scale
  const x = d3
    .scaleTime()
    .domain(d3.extent(data, d => new Date(d.time)) as [Date, Date])
    .range([0, width])

  // Y scale
  const y = d3
    .scaleLinear()
    .domain([d3.min(data, d => d.temperature)! - 2, d3.max(data, d => d.temperature)! + 2])
    .range([height, 0])

  // Area generator
  const area = d3
    .area<any>()
    .x(d => x(new Date(d.time)))
    .y0(height)
    .y1(d => y(d.temperature))
    .curve(d3.curveMonotoneX)

  // Line generator
  const line = d3
    .line<any>()
    .x(d => x(new Date(d.time)))
    .y(d => y(d.temperature))
    .curve(d3.curveMonotoneX)

  // Gradient
  const gradient = svg
    .append('defs')
    .append('linearGradient')
    .attr('id', 'temp-gradient')
    .attr('x1', '0%')
    .attr('y1', '0%')
    .attr('x2', '0%')
    .attr('y2', '100%')

  gradient
    .append('stop')
    .attr('offset', '0%')
    .attr('stop-color', 'var(--accent)')
    .attr('stop-opacity', 0.4)

  gradient
    .append('stop')
    .attr('offset', '100%')
    .attr('stop-color', 'var(--accent)')
    .attr('stop-opacity', 0)

  // Add area
  svg.append('path').datum(data).attr('fill', 'url(#temp-gradient)').attr('d', area)

  // Add line
  svg
    .append('path')
    .datum(data)
    .attr('fill', 'none')
    .attr('stroke', 'var(--accent)')
    .attr('stroke-width', 3)
    .attr('d', line)

  // Add X axis
  svg
    .append('g')
    .attr('transform', `translate(0,${height})`)
    .call(
      d3
        .axisBottom(x)
        .ticks(6)
        .tickFormat(d3.timeFormat('%H:%M') as any)
    )
    .attr('color', 'var(--text-muted)')
    .select('.domain')
    .remove()

  // Add Y axis
  svg
    .append('g')
    .call(d3.axisLeft(y).ticks(5))
    .attr('color', 'var(--text-muted)')
    .select('.domain')
    .remove()

  // Add interactive vertical line
  const focus = svg.append('g').style('display', 'none')

  focus
    .append('line')
    .attr('class', 'focus-line')
    .attr('y1', 0)
    .attr('y2', height)
    .attr('stroke', 'var(--text-secondary)')
    .attr('stroke-width', 1)
    .attr('stroke-dasharray', '3,3')

  // Update focus line based on timeline position (only if viewing today)
  if (weatherStore.selectedDayIndex === 0) {
    watch(
      () => weatherStore.timelinePosition,
      pos => {
        // Need to map global timeline pos to this day's graph
        // But timelinePosition is 0-1 across 48h.
        // This is tricky.
        // If graph is 24h, we need to adapt.
        // Simplification: Only show scrubber line on "Today" graph

        const totalHours = data.length - 1
        // timelinePosition is 0-1 for 48h.
        // Today is 0-0.5 of timeline.

        const relativePos = pos * 2 // Scale up
        if (relativePos <= 1) {
          const index = Math.round(relativePos * totalHours)
          const d = data[index]
          if (d) {
            const px = x(new Date(d.time))
            focus.style('display', null)
            focus.select('.focus-line').attr('x1', px).attr('x2', px)
          }
        } else {
          focus.style('display', 'none')
        }
      },
      { immediate: true }
    )
  }
}

function debounce<T extends (...args: any[]) => void>(fn: T, delay: number) {
  let timeout: ReturnType<typeof setTimeout>
  return (...args: Parameters<T>) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => fn(...args), delay)
  }
}

const handleResize = debounce(() => {
  drawGraph()
}, 250)

onMounted(() => {
  drawGraph()
  window.addEventListener('resize', handleResize)
})

onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
})

watch(graphData, drawGraph)
watch(() => settingsStore.temperatureUnit, drawGraph)
</script>

<template>
  <div ref="containerRef" class="temperature-graph w-full overflow-hidden">
    <h3 class="text-xs font-bold uppercase tracking-[0.2em] mb-4" style="color: var(--accent)">
      {{ weatherStore.selectedDayIndex === 0 ? 'Temperature Trend' : '24-Hour Forecast' }}
    </h3>
    <div
      v-if="graphData.length === 0"
      class="flex items-center justify-center h-[200px] text-muted text-sm"
    >
      Graph data not available for this date
    </div>
    <svg v-else ref="svgRef"></svg>
  </div>
</template>

<style scoped>
.temperature-graph {
  min-height: 250px;
}

:deep(.tick text) {
  font-family: var(--font-mono);
  font-size: 10px;
}
</style>
</file>

<file path="src/composables/useWeather.ts">
import { ref, watch, type Ref } from 'vue'
import { useWeatherStore } from '@/stores/weatherStore'
import { fetchWeatherData } from '@/services/weatherApi'
import { cache } from '@/services/cache'
import { CACHE_TTL, RETRY_CONFIG } from '@/utils/constants'
import type { Location, WeatherData } from '@/types'

export const useWeather = (location: Ref<Location | null>) => {
  const store = useWeatherStore()
  const lastFetchTime = ref<number>(0)
  const retryCount = ref(0)
  const isRetrying = ref(false)

  const refreshWeather = async (force = false) => {
    if (!location.value) return

    const { latitude, longitude } = location.value
    const cacheKey = cache.weatherKey(latitude, longitude)

    // Check if we need to fetch
    if (!force) {
      const cachedData = cache.get<WeatherData>(cacheKey)
      if (cachedData) {
        store.setWeatherData(cachedData)
        return
      }
    }

    store.setLoading(true)
    try {
      const data = await fetchWeatherData(latitude, longitude)
      store.setWeatherData(data)
      cache.set(cacheKey, data, CACHE_TTL.weather)
      lastFetchTime.value = Date.now()
      retryCount.value = 0
    } catch (err: any) {
      store.setError(err)
    } finally {
      store.setLoading(false)
    }
  }

  const retryWithBackoff = async () => {
    if (!location.value || retryCount.value >= RETRY_CONFIG.maxRetries) return

    isRetrying.value = true
    const delay = RETRY_CONFIG.baseDelay * Math.pow(2, retryCount.value)

    await new Promise(resolve => setTimeout(resolve, delay))
    retryCount.value++

    try {
      await refreshWeather(true)
      isRetrying.value = false
    } catch {
      isRetrying.value = false
      if (retryCount.value < RETRY_CONFIG.maxRetries) {
        await retryWithBackoff()
      }
    }
  }

  // SWR Pattern: Return cached data immediately, then fetch fresh data in background
  const getSwrWeather = async () => {
    if (!location.value) return

    const { latitude, longitude } = location.value
    const cacheKey = cache.weatherKey(latitude, longitude)

    const cachedData = cache.get<WeatherData>(cacheKey)
    if (cachedData) {
      store.setWeatherData(cachedData)

      // If data is older than threshold, revalidate in background
      const isStale =
        Date.now() - new Date(cachedData.lastUpdated).getTime() > RETRY_CONFIG.staleThreshold
      if (isStale) {
        // Background fetch
        fetchWeatherData(latitude, longitude)
          .then(data => {
            store.setWeatherData(data)
            cache.set(cacheKey, data, CACHE_TTL.weather)
          })
          .catch(console.error)
      }
    } else {
      // No cache, full fetch
      await refreshWeather(true)
    }
  }

  // Watch for location changes
  watch(
    () => location.value,
    newLoc => {
      if (newLoc) {
        getSwrWeather()
      }
    },
    { deep: true }
  )

  return {
    refreshWeather,
    getSwrWeather,
    retryWithBackoff,
    isRetrying,
    retryCount
  }
}
</file>

<file path="src/services/weatherApi.ts">
import type {
  WeatherData,
  CurrentWeather,
  HourlyForecast,
  DailyForecast,
  WeatherCode
} from '@/types'
import { API_ENDPOINTS, CURRENT_PARAMS, HOURLY_PARAMS, DAILY_PARAMS } from '@/utils/constants'

interface OpenMeteoCurrentResponse {
  time: string
  temperature_2m: number
  relative_humidity_2m: number
  apparent_temperature: number
  is_day: number
  precipitation: number
  rain: number
  weather_code: number
  cloud_cover: number
  pressure_msl: number
  wind_speed_10m: number
  wind_direction_10m: number
  uv_index: number
  visibility: number
}

interface OpenMeteoHourlyResponse {
  time: string[]
  temperature_2m: number[]
  relative_humidity_2m: number[]
  precipitation_probability: number[]
  precipitation: number[]
  weather_code: number[]
  wind_speed_10m: number[]
  wind_direction_10m: number[]
  uv_index: number[]
  is_day: number[]
  cloud_cover: number[]
}

interface OpenMeteoDailyResponse {
  time: string[]
  weather_code: number[]
  temperature_2m_max: number[]
  temperature_2m_min: number[]
  sunrise: string[]
  sunset: string[]
  uv_index_max: number[]
  precipitation_probability_max: number[]
  precipitation_sum: number[]
  wind_speed_10m_max: number[]
}

interface OpenMeteoResponse {
  latitude: number
  longitude: number
  generationtime_ms: number
  utc_offset_seconds: number
  timezone: string
  timezone_abbreviation: string
  elevation: number
  current?: OpenMeteoCurrentResponse
  hourly?: OpenMeteoHourlyResponse
  daily?: OpenMeteoDailyResponse
}

export const fetchWeatherData = async (
  latitude: number,
  longitude: number
): Promise<WeatherData> => {
  const params = new URLSearchParams({
    latitude: latitude.toString(),
    longitude: longitude.toString(),
    current: CURRENT_PARAMS.join(','),
    hourly: HOURLY_PARAMS.join(','),
    daily: DAILY_PARAMS.join(','),
    timezone: 'auto',
    forecast_days: '7',
    forecast_hours: '48'
  })

  const response = await fetch(`${API_ENDPOINTS.WEATHER}?${params}`)

  if (!response.ok) {
    throw new Error(`Weather API error: ${response.statusText}`)
  }

  const data: OpenMeteoResponse = await response.json()

  return transformWeatherData(data)
}

const transformWeatherData = (data: OpenMeteoResponse): WeatherData => {
  if (!data.current || !data.hourly || !data.daily) {
    throw new Error('Invalid weather data response')
  }

  const current = transformCurrentWeather(data.current)
  const hourly = transformHourlyForecast(data.hourly)
  const daily = transformDailyForecast(data.daily)

  // Add precipitation probability from first hour of forecast
  const firstHour = hourly[0]
  if (firstHour) {
    current.precipitationProbability = firstHour.precipitationProbability
  }

  return {
    current,
    hourly,
    daily,
    timezone: data.timezone,
    lastUpdated: new Date()
  }
}

const transformCurrentWeather = (data: OpenMeteoCurrentResponse): CurrentWeather => {
  return {
    time: data.time,
    temperature: data.temperature_2m,
    feelsLike: data.apparent_temperature,
    humidity: data.relative_humidity_2m,
    precipitation: data.precipitation,
    rain: data.rain,
    weatherCode: data.weather_code as WeatherCode,
    cloudCover: data.cloud_cover,
    pressure: data.pressure_msl,
    windSpeed: data.wind_speed_10m,
    windDirection: data.wind_direction_10m,
    uvIndex: data.uv_index,
    isDay: data.is_day === 1,
    visibility: data.visibility / 1000
  }
}

const transformHourlyForecast = (data: OpenMeteoHourlyResponse): HourlyForecast[] => {
  return data.time.map((time, i) => ({
    time,
    temperature: data.temperature_2m[i] ?? 0,
    humidity: data.relative_humidity_2m[i] ?? 0,
    precipitationProbability: data.precipitation_probability[i] ?? 0,
    precipitation: data.precipitation[i] ?? 0,
    weatherCode: (data.weather_code[i] ?? 0) as WeatherCode,
    windSpeed: data.wind_speed_10m[i] ?? 0,
    windDirection: data.wind_direction_10m[i] ?? 0,
    uvIndex: data.uv_index[i] ?? 0,
    isDay: (data.is_day[i] ?? 1) === 1,
    cloudCover: data.cloud_cover[i] ?? 0
  }))
}

const transformDailyForecast = (data: OpenMeteoDailyResponse): DailyForecast[] => {
  return data.time.map((date, i) => ({
    date,
    weatherCode: (data.weather_code[i] ?? 0) as WeatherCode,
    temperatureMax: data.temperature_2m_max[i] ?? 0,
    temperatureMin: data.temperature_2m_min[i] ?? 0,
    sunrise: data.sunrise[i] ?? '',
    sunset: data.sunset[i] ?? '',
    uvIndexMax: data.uv_index_max[i] ?? 0,
    precipitationProbabilityMax: data.precipitation_probability_max[i] ?? 0,
    precipitationSum: data.precipitation_sum[i] ?? 0,
    windSpeedMax: data.wind_speed_10m_max[i] ?? 0
  }))
}
</file>

<file path="src/types/weather.ts">
// Weather Types

export interface CurrentWeather {
  time: string
  temperature: number
  feelsLike: number
  humidity: number
  precipitation: number
  precipitationProbability?: number
  rain: number
  weatherCode: WeatherCode
  cloudCover: number
  pressure: number
  windSpeed: number
  windDirection: number
  uvIndex: number
  visibility: number
  isDay: boolean
}

export interface HourlyForecast {
  time: string
  temperature: number
  humidity: number
  precipitationProbability: number
  precipitation: number
  weatherCode: WeatherCode
  cloudCover: number
  windSpeed: number
  windDirection: number
  uvIndex: number
  isDay: boolean
}

export interface DailyForecast {
  date: string
  weatherCode: WeatherCode
  temperatureMax: number
  temperatureMin: number
  sunrise: string
  sunset: string
  uvIndexMax: number
  precipitationProbabilityMax: number
  precipitationSum: number
  windSpeedMax: number
}

export interface WeatherData {
  current: CurrentWeather
  hourly: HourlyForecast[]
  daily: DailyForecast[]
  timezone: string
  lastUpdated: Date
}

// WMO Weather Codes
export type WeatherCode =
  | 0 // Clear sky
  | 1 // Mainly clear
  | 2 // Partly cloudy
  | 3 // Overcast
  | 45 // Fog
  | 48 // Rime fog
  | 51 // Light drizzle
  | 53 // Moderate drizzle
  | 55 // Dense drizzle
  | 56 // Light freezing drizzle
  | 57 // Dense freezing drizzle
  | 61 // Slight rain
  | 63 // Moderate rain
  | 65 // Heavy rain
  | 66 // Light freezing rain
  | 67 // Heavy freezing rain
  | 71 // Slight snow
  | 73 // Moderate snow
  | 75 // Heavy snow
  | 77 // Snow grains
  | 80 // Slight rain showers
  | 81 // Moderate rain showers
  | 82 // Violent rain showers
  | 85 // Slight snow showers
  | 86 // Heavy snow showers
  | 95 // Thunderstorm
  | 96 // Thunderstorm with slight hail
  | 99 // Thunderstorm with heavy hail

export type WeatherType = 'clear' | 'cloudy' | 'rain' | 'storm' | 'snow' | 'fog'

export interface WeatherCodeInfo {
  code: WeatherCode
  description: string
  type: WeatherType
  icon: string
}

// Interpolated weather for timeline scrubbing
export interface InterpolatedWeather {
  temperature: number
  humidity: number
  precipitation: number
  precipitationProbability: number
  windSpeed: number
  uvIndex: number
  cloudCover: number
  isDay: boolean
  weatherType: WeatherType
}
</file>

<file path="src/components/weather/WeeklyForecast.vue">
<script setup lang="ts">
import { computed, ref } from 'vue'
import { useWeatherStore, useSettingsStore } from '@/stores'
import { formatTemperature, formatDate, formatTime, formatWindSpeed } from '@/utils/formatters'
import { getWeatherIcon } from '@/utils/weatherCodes'
import WeatherIcon from '@/components/ui/WeatherIcon.vue'
import { Wind, Sunrise, Sunset, Droplets, Sun } from 'lucide-vue-next'

const weatherStore = useWeatherStore()
const settingsStore = useSettingsStore()

const days = computed(() => weatherStore.daily)
const expandedDay = ref<number | null>(null)

const toggleDay = (index: number) => {
  expandedDay.value = expandedDay.value === index ? null : index
  weatherStore.selectDay(index)
}

// Get temperature range for the week (for bar visualization)
const tempRange = computed(() => {
  if (days.value.length === 0) return { min: 0, max: 30 }

  const allTemps = days.value.flatMap(d => [d.temperatureMin, d.temperatureMax])
  return {
    min: Math.min(...allTemps),
    max: Math.max(...allTemps)
  }
})

// Calculate bar position for a temperature
const getTempPosition = (temp: number) => {
  const { min, max } = tempRange.value
  const range = max - min || 1
  return ((temp - min) / range) * 100
}
</script>

<template>
  <section class="weekly-forecast" aria-labelledby="weekly-heading">
    <h3
      id="weekly-heading"
      class="text-xs font-bold uppercase tracking-[0.2em] mb-4"
      style="color: var(--accent)"
    >
      7-Day Forecast
    </h3>

    <div class="space-y-2" role="list" aria-label="7-day forecast">
      <div
        v-for="(day, index) in days"
        :key="day.date"
        class="day-container bg-glass rounded-lg overflow-hidden transition-all duration-300 border border-transparent hover:border-accent/50"
        :class="{ 'border-accent': expandedDay === index }"
      >
        <button
          class="day-row w-full text-left cursor-pointer focus:outline-none focus:bg-white/5"
          :class="{ today: index === 0 }"
          @click="toggleDay(index)"
          :aria-expanded="expandedDay === index"
          :aria-label="`${index === 0 ? 'Today' : formatDate(day.date, 'long')}: Low ${formatTemperature(day.temperatureMin, settingsStore.temperatureUnit)}, High ${formatTemperature(day.temperatureMax, settingsStore.temperatureUnit)}. Click for more details.`"
        >
          <!-- Day name -->
          <div class="day-name">
            {{ index === 0 ? 'Today' : formatDate(day.date, 'short') }}
          </div>

          <!-- Weather icon -->
          <div class="day-icon">
            <WeatherIcon :name="getWeatherIcon(day.weatherCode, true)" class="w-6 h-6" />
          </div>

          <!-- Precipitation probability -->
          <div class="day-precip">
            <span v-if="day.precipitationProbabilityMax > 0" class="text-blue-400">
              {{ day.precipitationProbabilityMax }}%
            </span>
          </div>

          <!-- Temperature bar -->
          <div class="day-temp-bar">
            <!-- Min temp -->
            <span class="temp-min">
              {{ formatTemperature(day.temperatureMin, settingsStore.temperatureUnit, false) }}°
            </span>

            <!-- Bar -->
            <div class="bar-container">
              <div
                class="bar"
                :style="{
                  left: `${getTempPosition(day.temperatureMin)}%`,
                  right: `${100 - getTempPosition(day.temperatureMax)}%`
                }"
              />
            </div>

            <!-- Max temp -->
            <span class="temp-max">
              {{ formatTemperature(day.temperatureMax, settingsStore.temperatureUnit, false) }}°
            </span>
          </div>
        </button>

        <!-- Expanded Details -->
        <div v-show="expandedDay === index" class="day-details px-4 pb-4 pt-2">
          <div class="grid grid-cols-2 gap-4 text-xs">
            <div class="flex items-center gap-2 text-muted">
              <Sunrise class="w-4 h-4" />
              <span
                >Sunrise:
                <span class="text-primary font-mono">{{ formatTime(day.sunrise) }}</span></span
              >
            </div>
            <div class="flex items-center gap-2 text-muted">
              <Sunset class="w-4 h-4" />
              <span
                >Sunset:
                <span class="text-primary font-mono">{{ formatTime(day.sunset) }}</span></span
              >
            </div>
            <div class="flex items-center gap-2 text-muted">
              <Wind class="w-4 h-4" />
              <span
                >Max Wind:
                <span class="text-primary font-mono">{{
                  formatWindSpeed(day.windSpeedMax, settingsStore.speedUnit)
                }}</span></span
              >
            </div>
            <div class="flex items-center gap-2 text-muted">
              <Droplets class="w-4 h-4" />
              <span
                >Precip:
                <span class="text-primary font-mono">{{ day.precipitationSum }} mm</span></span
              >
            </div>
            <div class="flex items-center gap-2 text-muted">
              <Sun class="w-4 h-4" />
              <span
                >UV Max:
                <span class="text-primary font-mono">{{ Math.round(day.uvIndexMax) }}</span></span
              >
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
</template>

<style scoped>
.bg-glass {
  background: var(--bg-glass);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

.day-row {
  display: grid;
  grid-template-columns: 80px 40px 50px 1fr;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem 1rem;
}

.day-name {
  font-size: 0.875rem;
  font-weight: 600;
  color: var(--text-primary);
}

.day-icon {
  display: flex;
  justify-content: center;
  color: var(--text-primary);
}

.day-precip {
  font-size: 0.75rem;
  font-weight: 600;
  text-align: center;
}

.day-temp-bar {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.temp-min,
.temp-max {
  font-family: theme('fontFamily.display');
  font-size: 0.875rem;
  font-weight: 500;
  width: 32px;
  text-align: center;
}

.temp-min {
  color: var(--text-muted);
}

.temp-max {
  color: var(--text-primary);
}

.bar-container {
  flex: 1;
  height: 4px;
  background: var(--border-default);
  border-radius: 2px;
  position: relative;
}

.bar {
  position: absolute;
  top: 0;
  bottom: 0;
  border-radius: 2px;
  background: linear-gradient(90deg, #60a5fa, #fcd34d, #f97316);
}

.text-muted {
  color: var(--text-muted);
}
.text-primary {
  color: var(--text-primary);
}
.border-accent {
  border-color: var(--accent);
}
</style>
</file>

<file path="src/stores/weatherStore.ts">
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type {
  WeatherData,
  CurrentWeather,
  HourlyForecast,
  DailyForecast,
  WeatherType,
  InterpolatedWeather
} from '@/types'
import { getWeatherType, interpolateValue } from '@/utils/weatherCodes'

export const useWeatherStore = defineStore('weather', () => {
  // State
  const current = ref<CurrentWeather | null>(null)
  const hourly = ref<HourlyForecast[]>([])
  const daily = ref<DailyForecast[]>([])
  const timezone = ref<string>('')
  const lastUpdated = ref<Date | null>(null)

  const isLoading = ref(false)
  const error = ref<Error | null>(null)

  // Timeline scrubber position (0-1 representing 48 hours)
  const timelinePosition = ref(0)

  // Selected day index (0 = today, 1 = tomorrow, etc.)
  const selectedDayIndex = ref(0)

  // Getters
  const hasData = computed(() => current.value !== null)

  const weatherType = computed<WeatherType>(() => {
    // If viewing a future day, use that day's weather code
    const futureDay = daily.value[selectedDayIndex.value]
    if (selectedDayIndex.value > 0 && futureDay) {
      return getWeatherType(futureDay.weatherCode)
    }

    if (!current.value) return 'clear'
    return getWeatherType(current.value.weatherCode)
  })

  // Weather to display in the main Hero section
  const displayWeather = computed<CurrentWeather | null>(() => {
    // If today (index 0), return current weather (or interpolated if scrubbing)
    if (selectedDayIndex.value === 0) {
      if (interpolatedWeather.value && current.value) {
        // Merge interpolated data with current data structure
        return {
          ...current.value,
          temperature: interpolatedWeather.value.temperature,
          humidity: interpolatedWeather.value.humidity,
          precipitation: interpolatedWeather.value.precipitation,
          precipitationProbability: interpolatedWeather.value.precipitationProbability,
          windSpeed: interpolatedWeather.value.windSpeed,
          uvIndex: interpolatedWeather.value.uvIndex,
          cloudCover: interpolatedWeather.value.cloudCover,
          isDay: interpolatedWeather.value.isDay,
          weatherCode:
            interpolatedWeather.value.weatherType === 'clear' ? 0 : current.value.weatherCode // Approximation
        }
      }
      return current.value
    }

    // If future day, map DailyForecast to CurrentWeather structure
    const day = daily.value[selectedDayIndex.value]
    if (!day) return null

    // Create a synthetic CurrentWeather object from daily forecast
    return {
      time: day.date,
      temperature: day.temperatureMax, // Show max temp as primary
      feelsLike: day.temperatureMax, // Approx
      humidity: 0, // Not available in daily
      precipitation: day.precipitationSum,
      rain: day.precipitationSum,
      weatherCode: day.weatherCode,
      cloudCover: 0, // Not available
      pressure: 1013, // Standard pressure default
      windSpeed: day.windSpeedMax,
      windDirection: 0,
      uvIndex: day.uvIndexMax,
      isDay: true, // Always show day theme for future forecasts
      visibility: 10, // Default good visibility
      precipitationProbability: day.precipitationProbabilityMax
    } as CurrentWeather
  })

  // Interpolated weather based on timeline position
  const interpolatedWeather = computed<InterpolatedWeather | null>(() => {
    if (hourly.value.length < 2) return null

    const totalHours = hourly.value.length - 1
    const exactIndex = timelinePosition.value * totalHours
    const lowerIndex = Math.floor(exactIndex)
    const upperIndex = Math.min(lowerIndex + 1, totalHours)
    const fraction = exactIndex - lowerIndex

    const lower = hourly.value[lowerIndex]
    const upper = hourly.value[upperIndex]

    if (!lower || !upper) return null

    return {
      temperature: interpolateValue(lower.temperature, upper.temperature, fraction),
      humidity: interpolateValue(lower.humidity, upper.humidity, fraction),
      precipitation: interpolateValue(lower.precipitation, upper.precipitation, fraction),
      precipitationProbability: interpolateValue(
        lower.precipitationProbability,
        upper.precipitationProbability,
        fraction
      ),
      windSpeed: interpolateValue(lower.windSpeed, upper.windSpeed, fraction),
      uvIndex: interpolateValue(lower.uvIndex, upper.uvIndex, fraction),
      cloudCover: interpolateValue(lower.cloudCover || 0, upper.cloudCover || 0, fraction), // Fixed: was using humidity
      isDay: fraction < 0.5 ? lower.isDay : upper.isDay,
      weatherType: getWeatherType(fraction < 0.5 ? lower.weatherCode : upper.weatherCode)
    }
  })

  // Current time position on timeline (0-1)
  const currentTimePosition = computed(() => {
    if (hourly.value.length === 0) return 0

    const now = new Date()
    const firstHourData = hourly.value[0]
    const lastHourData = hourly.value[hourly.value.length - 1]

    if (!firstHourData || !lastHourData) return 0

    const firstHour = new Date(firstHourData.time)
    const lastHour = new Date(lastHourData.time)

    const totalMs = lastHour.getTime() - firstHour.getTime()
    const elapsedMs = now.getTime() - firstHour.getTime()

    return Math.max(0, Math.min(1, elapsedMs / totalMs))
  })

  // Actions
  const setWeatherData = (data: WeatherData) => {
    current.value = data.current
    hourly.value = data.hourly
    daily.value = data.daily
    timezone.value = data.timezone
    lastUpdated.value = data.lastUpdated
    error.value = null
  }

  const setLoading = (loading: boolean) => {
    isLoading.value = loading
  }

  const setError = (err: Error | null) => {
    error.value = err
    isLoading.value = false
  }

  const setTimelinePosition = (position: number) => {
    timelinePosition.value = Math.max(0, Math.min(1, position))
    // If scrubbing, ensure we're looking at today
    if (selectedDayIndex.value !== 0) {
      selectedDayIndex.value = 0
    }
  }

  const resetTimelineToNow = () => {
    timelinePosition.value = currentTimePosition.value
    selectedDayIndex.value = 0
  }

  const selectDay = (index: number) => {
    if (index >= 0 && index < daily.value.length) {
      selectedDayIndex.value = index
      // Reset timeline if switching days
      timelinePosition.value = 0
    }
  }

  const clearData = () => {
    current.value = null
    hourly.value = []
    daily.value = []
    timezone.value = ''
    lastUpdated.value = null
    error.value = null
    timelinePosition.value = 0
    selectedDayIndex.value = 0
  }

  return {
    // State
    current,
    hourly,
    daily,
    timezone,
    lastUpdated,
    isLoading,
    error,
    timelinePosition,
    selectedDayIndex,

    // Getters
    hasData,
    weatherType,
    displayWeather,
    interpolatedWeather,
    currentTimePosition,

    // Actions
    setWeatherData,
    setLoading,
    setError,
    setTimelinePosition,
    resetTimelineToNow,
    selectDay,
    clearData
  }
})
</file>

<file path="src/utils/constants.ts">
// API Endpoints
export const API_ENDPOINTS = {
  WEATHER: 'https://api.open-meteo.com/v1/forecast',
  GEOCODING: 'https://geocoding-api.open-meteo.com/v1/search',
  TRANSLATION: 'https://api.cognitive.microsofttranslator.com/translate'
} as const

// Weather API parameters
export const CURRENT_PARAMS = [
  'temperature_2m',
  'relative_humidity_2m',
  'apparent_temperature',
  'is_day',
  'precipitation',
  'rain',
  'weather_code',
  'cloud_cover',
  'pressure_msl',
  'wind_speed_10m',
  'wind_direction_10m',
  'uv_index',
  'visibility'
] as const

export const HOURLY_PARAMS = [
  'temperature_2m',
  'relative_humidity_2m',
  'precipitation_probability',
  'precipitation',
  'weather_code',
  'wind_speed_10m',
  'wind_direction_10m',
  'uv_index',
  'is_day',
  'cloud_cover'
] as const

export const DAILY_PARAMS = [
  'weather_code',
  'temperature_2m_max',
  'temperature_2m_min',
  'sunrise',
  'sunset',
  'uv_index_max',
  'precipitation_probability_max',
  'precipitation_sum',
  'wind_speed_10m_max'
] as const

// Animation durations (ms)
export const DURATIONS = {
  instant: 0,
  fastest: 100,
  fast: 200,
  normal: 300,
  slow: 500,
  slower: 700,
  slowest: 1000,
  stagger: {
    fast: 50,
    normal: 100,
    slow: 150
  }
} as const

// Breakpoints (px)
export const BREAKPOINTS = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  '2xl': 1536
} as const

// Z-index scale
export const Z_INDEX = {
  below: -1,
  base: 0,
  above: 1,
  header: 10,
  dropdown: 20,
  drawer: 30,
  modal: 40,
  toast: 50,
  splash: 100
} as const

// Languages for translation
export const LANGUAGES = {
  en: 'English',
  de: 'German',
  fr: 'French',
  es: 'Spanish',
  it: 'Italian',
  pt: 'Portuguese',
  ru: 'Russian',
  ja: 'Japanese',
  zh: 'Chinese',
  ar: 'Arabic',
  ko: 'Korean',
  nl: 'Dutch',
  pl: 'Polish',
  tr: 'Turkish',
  sv: 'Swedish'
} as const

// Cache TTLs (ms)
export const CACHE_TTL = {
  weather: 5 * 60 * 1000, // 5 minutes
  geocoding: 24 * 60 * 60 * 1000, // 24 hours
  settings: Infinity
} as const

// Network Retries
export const RETRY_CONFIG = {
  maxRetries: 3,
  baseDelay: 1000,
  staleThreshold: 5 * 60 * 1000
} as const

// Haptic patterns
export const HAPTIC_PATTERNS = {
  tap: [10],
  success: [10, 50, 10],
  error: [50, 100, 50],
  lightRain: [50, 100, 50, 100, 50],
  heavyRain: [100, 50, 100, 50, 100, 50, 100],
  thunder: [200, 100, 500],
  snow: [30, 200, 30, 200, 30],
  wind: [20, 80, 20, 80, 20, 80, 20]
} as const
</file>

</files>
